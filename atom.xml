<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>devin&#39;s blog</title>
  
  <subtitle>vinya</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-28T10:44:48.969Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>devin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/04/28/hello-world/"/>
    <id>http://example.com/2023/04/28/hello-world/</id>
    <published>2023-04-28T10:44:48.968Z</published>
    <updated>2023-04-28T10:44:48.969Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>1、TCPIP网络模型</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/1%E3%80%81TCPIP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/1%E3%80%81TCPIP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-04-28T10:40:04.953Z</published>
    <updated>2023-04-28T10:44:48.972Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一、TCP-x2F-IP网络模型"><a href="#一、TCP-x2F-IP网络模型" class="headerlink" title="一、TCP&#x2F;IP网络模型"></a>一、TCP&#x2F;IP网络模型</h3><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信，使用哪种语言进行通信、怎样结束通信等规则都事先确定。</p><p>TCP&#x2F;IP是互联网相关的是互联网相关的各类协议簇的总称，比如TCP，UDP，IP，FTP，HTTP，ICMP，SMTP等属于TCP&#x2F;IP族内的协议。</p><p>TCP&#x2F;IP模型是互联网的基础，它是一些列网络协议的总称，这些协议可以分为四层。</p><ul><li><strong>链路层</strong>：负责封装和解封装IP报文，发送和接收ARP&#x2F;RARP报文等。</li><li><strong>网络层</strong>：负责路由以及把分组报文发送给目标网络或主机</li><li><strong>传输层</strong>：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li><li><strong>应用层</strong>：负责向用户提供应用程序，比如HTTP，FTP，Telnet，DNS，SMTP等。</li></ul><table><thead><tr><th>OSI七层模型</th><th>TCP&#x2F;IP概念层模型</th><th>功能</th><th>TCP&#x2F;IP协议簇</th></tr></thead><tbody><tr><td>应用层</td><td></td><td>文件传输，电子邮件，文件服务，虚拟终端</td><td>TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td></tr><tr><td>表示层</td><td></td><td>数据格式化，代码转换，数据加密</td><td>没有协议</td></tr><tr><td>会话层</td><td>应用层</td><td>解除或建立与别的接点的联系</td><td>没有协议</td></tr><tr><td>传输层</td><td>传输层</td><td>提供对端的接口</td><td>TCP，UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>为数据包选择路由</td><td>IP，TCMP，RIP，OSPF，ICMP</td></tr><tr><td>数据链路层</td><td></td><td>传输有地址的帧以及错误检测功能</td><td>SLIP，CSLIP，PPP，ARP，MTV</td></tr><tr><td>物理层</td><td>链路层</td><td>以二进制数据形式在物理媒体上传输数据</td><td>ISO2110，IEEE802，IEEE802.2</td></tr></tbody></table><h3 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h3><p>UDP协议全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OIS，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组，组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><h4 id="1、面向无连接"><a href="#1、面向无连接" class="headerlink" title="1、面向无连接"></a>1、面向无连接</h4><p>首先UDP是不需要和TP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体就是：</p><ul><li>在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传输给网络层了。</li><li>在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不回拼接操作。</li></ul><h4 id="2、有单播、多播、广播功能"><a href="#2、有单播、多播、广播功能" class="headerlink" title="2、有单播、多播、广播功能"></a>2、有单播、多播、广播功能</h4><p>UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。</p><h4 id="3、UDP是面向报文的"><a href="#3、UDP是面向报文的" class="headerlink" title="3、UDP是面向报文的"></a>3、UDP是面向报文的</h4><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交给IP层。UDP对应用层交下来的报文，既不合并也不拆分，而是保留这些报文的边界。因此。应用程序必须选择合适大小的报文。</p><h4 id="4、不可靠性"><a href="#4、不可靠性" class="headerlink" title="4、不可靠性"></a>4、不可靠性</h4><p>首先不可靠性体现在无连接上，通信都不需要建立连接。想发就发。这样的情况不可靠。</p><p>并且收到什么数据就传递什么数据，并且不会备份数据，发送数据也不回关心对方是否已经正确接收数据。</p><p>网络环境时好时坏，但是UDP没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不回对发送频率调整，这样的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景(比如电话会议)就需要使用UDP而不是TCP。</p><h4 id="5、头部开销小，传输数据报文时很高效。"><a href="#5、头部开销小，传输数据报文时很高效。" class="headerlink" title="5、头部开销小，传输数据报文时很高效。"></a>5、头部开销小，传输数据报文时很高效。</h4><ul><li><p>两个十六位的端口号，分别为源端口（可选字段）和目标端口</p></li><li><p>整个数据报文的长度</p></li><li><p>整个数据报文的校验和(IPv4可选字段)，该字段用于头部信息和数据中的错误。</p><p>  因此UDP的头部开销少，只有八字节，相比TCP的至少二十字节要少得多，在传输数据报文时是很高效的。</p></li></ul><h3 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h3><p>当一台计算机想要跟另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如：查看网页或电子邮件时，希望完整且顺序查看网页，下载文件时，希望获得完整的文件，而不仅仅是文件的一部分，这时就需要用到TCP。</p><p>TCP全称是<strong>传输控制协议</strong>，是一种面向<strong>连接的、可靠的、基于字节流</strong>的传输层通信协议，由IETF的RFC793定义，TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构。</p><h4 id="1、连接过程"><a href="#1、连接过程" class="headerlink" title="1、连接过程"></a>1、连接过程</h4><h5 id="第一次握手："><a href="#第一次握手：" class="headerlink" title="第一次握手："></a>第一次握手：</h5><p>客户端向服务端发送连接请求报文段，该报文段中包含自身的数据通讯初识序号。请求发送后，客户端便进入SYN-SENT状态。</p><h5 id="第二次握手："><a href="#第二次握手：" class="headerlink" title="第二次握手："></a>第二次握手：</h5><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入SYN—RECEIVED状态。</p><h5 id="第三次握手："><a href="#第三次握手：" class="headerlink" title="第三次握手："></a>第三次握手：</h5><p>当客户端收到连接同意后，还要向服务端发送一个确认报文。客户端发完这个报文段之后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接建立成功。</p><p>为什么TCP建立连接需要三次握手，而不是两次呢？这是因为为了防止出现时效的链接请求报文段被服务端接收的情况，从而产生错误。</p><h4 id="2、TCP断开连接"><a href="#2、TCP断开连接" class="headerlink" title="2、TCP断开连接"></a>2、TCP断开连接</h4><p>TCP是全双工的，在断开连接时两端都需要发送FIN和ACK。</p><h5 id="第一次挥手："><a href="#第一次挥手：" class="headerlink" title="第一次挥手："></a>第一次挥手：</h5><p>若客户端A认为数据发送完成，则它需要向服务端B发送连接释放请求。</p><h5 id="第二次挥手："><a href="#第二次挥手：" class="headerlink" title="第二次挥手："></a>第二次挥手：</h5><p>B收到连接释放请求后，会告诉应用层钥匙房TCP连接，然后会发送ACK包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。</p><h5 id="第三次挥手："><a href="#第三次挥手：" class="headerlink" title="第三次挥手："></a>第三次挥手：</h5><p>B如果此时有未发送完成的数据会继续发送，发送完毕后会向A发送连接释放请求，然后B便进入LAST-ACK状态。</p><h5 id="第四次挥手："><a href="#第四次挥手：" class="headerlink" title="第四次挥手："></a>第四次挥手：</h5><p>A收到释放请求后，向B发送确认应答，此时A进入TIME—WAIT状态。该状态会持续2MSL（最大段生存期，只报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段没有B的重发请求的话，就会进入CLOSED状态。当B收到确认应答后，也便进入CLOSED状态。</p><h4 id="3、TCP协议的特点"><a href="#3、TCP协议的特点" class="headerlink" title="3、TCP协议的特点"></a>3、TCP协议的特点</h4><ul><li><p><strong>面向连接</strong></p><p>  面向连接，是指发送数据之前必须在两端建立连接。建立连接的方式是三次握手，这样可以建立可靠的链接。建立连接是为数据的可靠传输做基础。</p></li><li><p><strong>仅支持单播传输</strong></p><p>  每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p></li><li><p><strong>面向字节流</strong></p><p>  TCP不像UDP一样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p></li><li><p><strong>可靠传输</strong></p><p>  对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已经成功收到的字节发回一个想要的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据(假设丢失了)将会被重传。</p></li><li><p><strong>提供拥塞控制</strong></p><p>  当网络出现拥塞时，TCP能够减少向网络注入数据的速率和数量，缓解拥塞。</p></li><li><p><strong>TCP提供全双工通信</strong></p><p>  TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP链接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）。</p></li></ul><h3 id="四、TCP和UDP对比"><a href="#四、TCP和UDP对比" class="headerlink" title="四、TCP和UDP对比"></a>四、TCP和UDP对比</h3><h4 id="1、对比"><a href="#1、对比" class="headerlink" title="1、对比"></a>1、对比</h4><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>只能一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小</td><td>首部最小20字节，最大60字节</td></tr><tr><td>适用场景</td><td>适用于实时应用(IP电话、视频会议、直播等)</td><td>适用于要求可靠传输的应用，比如文件传输等。</td></tr></tbody></table><h4 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h4><ul><li>TCP虽然向上层提供面向连接的可靠服务，UDP向上层提供无连接不可靠服务。</li><li>虽然UDP并没有TCP传输来的准确，但是也能在很多实时性要求高的地方有所作为。</li><li>对数据准去性要求高，速度可以相对慢的，可以选用TCP。</li></ul><p>��求高的地方有所作为。</p><ul><li>对数据准去性要求高，速度可以相对慢的，可以选用TCP。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;一、TCP-x2F-IP网络模型&quot;&gt;&lt;a href=&quot;#一、TCP-x2F-IP网络模型&quot; class=&quot;headerlink&quot; title=&quot;一、TCP&amp;#x2F;IP网络模型&quot;&gt;&lt;/a&gt;一、TCP&amp;#x2F;IP网络模型&lt;/h3&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/</id>
    <published>2023-04-28T10:40:04.944Z</published>
    <updated>2023-04-28T10:44:48.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归：在函数中自己调用自身，类似于压栈</p><p>递归三要素：</p><ol><li>递归边界：一定要有终止条件</li><li>逻辑处理</li><li>调用自身</li><li>状态清理</li></ol><p>例如：</p><p>斐波那契</p><p>某个数的阶乘</p><h2 id="分治：Divde-amp-Conquer"><a href="#分治：Divde-amp-Conquer" class="headerlink" title="分治：Divde &amp; Conquer"></a>分治：Divde &amp; Conquer</h2><p>分而治之：将一个大问题依次解决，类似于庖丁解牛。</p><p>经典算法：二分查找、快排</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>简单来说：问题能够分解成子问题来解决，子问题的最优解能递推到最终的最优解，这样子问题最优解称为最优子结构。</p><p>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p><h2 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h2><p>Breadth First Search</p><p>在树（图&#x2F;状态集）中查找特定节点</p><p>每层推进的过程中没有重复的，先扫描某个节点时，将该节点的所有子节点全部加入，以作为下次继续推进。</p><p>又称为地毯式搜索</p><h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>Depth First Search</p><p>每层推进的过程中没有重复的，先扫描某个节点时，将某个节点一直扫描到叶子节点之后，再扫描该节点的其他节点。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ol><li>单调递增或递减</li><li>存在上下界</li><li>能够通过索引访问</li></ol><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>什么是位运算：程序中所有数在计算机内存中都是以二进制的形式储存的。位运算说白了就是对证书在内存中的二进制位进行操作。比如：and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子：6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它的二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110 AND 1011 &gt;&gt; 0010(b)——&gt; 2(d)</span><br></pre></td></tr></table></figure><p>由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</p><table><thead><tr><th>符号</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr><td>|</td><td>或</td><td>两个位都为0时，结果才为0</td></tr><tr><td>^</td><td>异或</td><td>两个位相同时为0，相异为1</td></tr><tr><td>-</td><td>取反</td><td>0变1，1变0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>各二进制位全部左移若敢为，高位丢弃，低位补0</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>各二进制位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方式不一样，有的补符号位(算数右移)，有的补0（逻辑右移）</td></tr></tbody></table><h2 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划(Dynamic Programming)"></a>动态规划(Dynamic Programming)</h2><p>动态规划分为4个思路：</p><ol><li>递归+记忆化 ——&gt; 递推</li><li>状态的定义：opt[n]，dp[n]，fib[n]</li><li>状态转移方程：opt[n] &#x3D; best_of(opt[n-1],opt[n-2],…)</li><li>最优子结构</li></ol><p>先规划最基础的一步怎么执行，然后逐层反推，得到最优的方案</p><h2 id="DP-vs-回溯-vs-贪心"><a href="#DP-vs-回溯-vs-贪心" class="headerlink" title="DP vs 回溯 vs 贪心"></a>DP vs 回溯 vs 贪心</h2><ul><li>回溯（递归）—— 重复计算，尽可能考虑重复计算问题，减少重复计算</li><li>贪心 —— 永远局部最优</li><li>DP —— 记录局部最优子结构 &#x2F; 多种记录值</li></ul><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集(union &amp; find)是一种树形的数据结构，用于处理一些不交集(Disjoint Sets)的合并及查询问题</p><p>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一个子集</p><p>union：将两个子集合并为同一个集合。</p><p>示例，给定一串数组<code>1 2 3 4 5 6 7 8 </code></p><p>拆分为<code>1 2 5 6 8</code> <code>3 4</code> <code>7</code>子集形式</p><h5 id="生活中的例子"><a href="#生活中的例子" class="headerlink" title="生活中的例子"></a>生活中的例子</h5><ol><li>小弟——&gt; 老大</li><li>帮派识别</li><li>两种优化方式：并查集的深度成为rank<ol><li>将rank低的合并到rank高的并查集中</li><li>进行读路径优化：将<code>d c b a a</code>路径全部压缩为<code>d a</code>,<code>c a</code>,<code>b a</code>,<code>a a</code></li></ol></li></ol><h2 id="Cache-缓存"><a href="#Cache-缓存" class="headerlink" title="Cache 缓存"></a>Cache 缓存</h2><ol><li>记忆</li><li>钱包——储物柜</li><li>代码模块</li></ol><h2 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h2><ol><li>Least recently used（最近最少使用）</li><li>Double LinkedList</li><li>O(1)查询，查询最近的数据是O(1)</li><li>O(1)修改</li></ol><h2 id="LFU-Cache"><a href="#LFU-Cache" class="headerlink" title="LFU Cache"></a>LFU Cache</h2><ol><li>LFU ——least frequently used 最近最不常用页面置换算法</li><li>LRU——least recently used 最近最少使用页面置换算法</li></ol><h2 id="Bloom-Filter-布隆过滤器"><a href="#Bloom-Filter-布隆过滤器" class="headerlink" title="Bloom Filter 布隆过滤器"></a>Bloom Filter 布隆过滤器</h2><p>一个很长的二进制向量和一个映射函数</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中</p><p>他的优点是空间效率和查询效率远远超过一般算法，缺点是有一定的误识别率和删除困难</p><p>误识别率：数据存在时会出现误判，不存在时一定不存在</p><p>删除困难：哈希之后的结果不好删除，可能会误删其他元素的值</p><p>案例：</p><ol><li>比特币</li><li>分布式系统（Map-Reduce）</li></ol><h2 id="现实中的算法问题"><a href="#现实中的算法问题" class="headerlink" title="现实中的算法问题"></a>现实中的算法问题</h2><p>适用于找房子，找女朋友，吃饭等等选择问题。</p><p>假设1年找2个女朋友，</p><ol><li>如果能选择之前的，O(n)</li><li>如果不能后悔，则用37%原则</li></ol><p>其他：</p><ol><li>Priority Queue 一个任务的密度&#x3D;重要程度&#x2F;完成时间</li><li>Kelly Formula 凯利公式</li><li>Game Theory 博弈论</li></ol><h2 id="代码模版"><a href="#代码模版" class="headerlink" title="代码模版"></a>代码模版</h2><ol><li>递归</li><li>DFS：深度优先遍历</li><li>BFS：广度优先遍历</li><li>二分查找</li><li>DP方程</li></ol><h2 id="练习和切题"><a href="#练习和切题" class="headerlink" title="练习和切题"></a>练习和切题</h2><p><strong>持续练习+精深练习（刻意练习）</strong></p><ol><li>除了做熟悉的题和会做的题之外，去刻意练习自己不熟悉的算法和数据结构，不要为了切题而切题</li><li>做过的题目后续要返回再复习</li></ol><h2 id="面试答题四件套"><a href="#面试答题四件套" class="headerlink" title="面试答题四件套"></a>面试答题四件套</h2><ol><li>Clarification 询问题目细节、边界条件、可能的极端错误</li><li>Possible Solution 所有可能的解法都和面试官沟通一下<ol><li>时间复杂度 &amp; 空间复杂度</li><li>最优解</li></ol></li><li>Coding 写代码</li><li>Test Cases 测试用例</li></ol><p> <strong>沟通和交流很重要</strong></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>常学常新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h1&gt;&lt;p&gt;递归：在函数中自己调用自身，类似于压栈&lt;/p&gt;
&lt;p&gt;递归三要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归边界：一定要有终止条件&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>kafka详解</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka/1.kafka%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka/1.kafka%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-04-28T10:40:04.944Z</published>
    <updated>2023-04-28T10:44:49.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kafka入门须知"><a href="#kafka入门须知" class="headerlink" title="kafka入门须知"></a>kafka入门须知</h2><ol><li><h3 id="kafka概述"><a href="#kafka概述" class="headerlink" title="kafka概述"></a>kafka概述</h3><p>kafka是一款开源的消息引擎系统。常见的两种消息传输模型如下：</p><ul><li><strong>点对点模型</strong></li><li><strong>发布&#x2F;订阅模型</strong></li></ul><p>kafka同时支持这两种模型，是如何做到的？（通过消费者组实现）</p><p>消息引擎系统在什么场景下使用？—<code>削峰填谷</code>。所谓的<code>削峰填谷</code>就是指缓冲上下游瞬发的流量，使其更加平滑。对于发送能力很强的上游系统，如果没有消息引擎的保护，下游系统可能会直接被压垮导致全链路服务雪崩，消息引擎可一直在很大程度上避免流量的震荡。消息引擎系统的另一大好处是发送方和接收方的松耦合，减少系统间不必要的交互（生产者、消费者模式）。</p><ol><li><h4 id="kafka的体系架构"><a href="#kafka的体系架构" class="headerlink" title="kafka的体系架构"></a>kafka的体系架构</h4><p>一个典型的kafka体系架构包含若干Producer、若干Broker、若干Consumer，以及一个zookeeper集群。其中zookeeper负责集群元数据的管理、控制器选举等操作。Producer将消息发送到Broker，Broker负责将收到的消息存储到磁盘中，而Consumer负责从Broker订阅并消费消息。</p><p><img src="/1.kafka%E8%AF%A6%E8%A7%A3/images/1.kafka%E6%9E%B6%E6%9E%84.png" alt="image-20220624143703108"></p><p>整个kafka体系结构中引入了3个术语：</p><ol><li><strong>Producer</strong>：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到kafka中。</li><li><strong>Consumer</strong>：消费者，也就是接收消息的一方。消费者连接到kafka上并接收消息，从而进行相应的业务逻辑处理。</li><li><strong>Broker</strong>：服务节点代理。对于Kafka而言，Broker可以简单的看做一个独立的Kafka服务节点或Kafka实例。大多数情况下也可以将Broker看做一个Kafka服务器，前提是这台服务器上只部署了一个Kafka实例。一个或多个Broker组成一个Kafka集群。一般而言，习惯使用首字母小写的broker来表示服务代理节点。</li></ol><p>在kafka中，还有两个很重要的概念——主题(Topic)与分区（Partition）。kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到kafka集群的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。</p><p>主题是一个逻辑上的概念，还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区成为主题分区（Topic-Partition）。同一个主题下的不同分区包含的消息是不同的，分区在存储层面上可以看做一个可追加的日志(Log)文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。</p><p>offset是消息在分区中的唯一标识，是一个单调递增且不变的值。Kafka通过它来保证消息在分区内的顺序性，不过offset并不跨越分区，也就是说，Kafka保证的是分区有序而不是主题有序。</p><p><img src="/1.kafka%E8%AF%A6%E8%A7%A3/images/2.kafka%E5%88%86%E5%8C%BA%E6%9E%B6%E6%9E%84.png" alt="image-20220626162723880"></p><p>如图所示kafka某主题中，分为4个分区，消息被顺序追加到每个分区日志文件的尾部。Kafka中的分区可以分布在不同的服务器(Broker)中，也就是说，一个主题可以横跨多个Broker，以此来提供比单个Broker更强大的性能。</p><p>每一条消息在被发送到Broker之前，会根据分区规则选择存储到哪个具体的分区，如果分区规则设定的合理，所有的消息都可以均匀地分配到不同的分区中；如果一个主题只对应一个文件，那么这个文件所在的机器I&#x2F;O将会成为这个主题的性能瓶颈，而分区解决了这个问题。在创建主题的时候可以通过指定的参数来设置分区的个数，也可以在主题创建完成之后去修改分区的数量，通过增加分区的数量可以实现水平扩展。</p><p>不考虑多副本的情况，一个分区对应一个日志（Log）。为了防止Log过大，Kafka又引入了日志分段（LogSegment）的概念，将Log切分为多个LogSegment，相当于一个巨型文件被平均分配为多个相对较小的文件，这样也便于消息的维护和清理。事实上，Log和LogSegment也不是纯粹物理意义上的概念。Log在物理上只以文件夹的形式存储，而每个LogSegment对应于磁盘上的一个日志文件和两个索引文件，以及可能的其他文件（比如以”.txnindex”为后缀的事务索引文件）。如下图描绘了主题、分区、副本、Log以及LogSegment之间的关系。</p><p><img src="/1.kafka%E8%AF%A6%E8%A7%A3/images/3.kafka%E4%B8%BB%E9%A2%98%E6%97%A5%E5%BF%97%E6%9E%B6%E6%9E%84.png" alt="image-20220626165229254"></p></li><li><h4 id="多副本机制"><a href="#多副本机制" class="headerlink" title="多副本机制"></a>多副本机制</h4><p>Kafka为分区引入了多副本(Replica)机制，通过增加副本数量可以提升容灾能力。备份的思想就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在Kafka中被称为副本(Replica)。</p><p>同一个分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样），副本之间是”一主多从”的关系，其中Leader副本负责处理读写请求，follwoer副本只负责与Leader副本的消息同步。副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。Kafka通过多副本机制实现了故障的自动转移，当Kafka集群中的某个broker失效时仍能保证服务可用。</p><p>我们知道一些其他的系统中的follower副本可以对外提供服务，比如mysql中的从库可以对外提供读操作，但是Kafka中的follower副本不像mysql的副本可以单独对外提供服务。</p><h5 id="为什么Kafka不像MySQL和Redis那样对外提供服务？"><a href="#为什么Kafka不像MySQL和Redis那样对外提供服务？" class="headerlink" title="为什么Kafka不像MySQL和Redis那样对外提供服务？"></a>为什么Kafka不像MySQL和Redis那样对外提供服务？</h5><ul><li>首先，Redis和MySQL都支持主从读写分离，这与他们的使用场景有关。对于那种读操作很多而写操作相对不频繁的负载类型而言，采用读写分离是非常不错的方案——可以添加很多的follower横向扩展，提升读操作性能。反观Kafka，它的主要使用场景是消息引擎而不是以数据存储的方式对外提供服务，通常涉及频繁的生产消息和消费消息，这不属于典型的读多写少场景，因此读写分离方案不适合当前场景。</li><li>第二，Kafka副本使用的是异步拉取，因此存在leader和follower之间的不一致性。如果要采用读写分离，则要处理副本lag引入的一致性问题。</li><li>第三，主写从读模式是为了减轻leader节点的压力，将读请求的负载均衡到follower节点，如果kafka的分区相对均匀地分散到各个broker上，同样可以起到负载均衡的效果，没必要刻意实现主写从读增加代码实现的复杂程度。</li></ul><p><strong>如下是kafka分区和副本的架构图</strong>：</p><p><img src="/1.kafka%E8%AF%A6%E8%A7%A3/images/4.kafka%E5%88%86%E5%8C%BA%E5%92%8C%E5%89%AF%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="image-20220626184444048"></p><p>如上图所示，Kafka集群中有4个Broker，某个主题中有3个分区，且副本因子（即副本个数）也为3，如此每个分区便有1个leader副本和2个follower副本。生产者和消费者只与leader副本进行交互，而follower副本只负责消息的同步，很多时候follwoer副本中的消息相对leader副本而言会有一定的滞后。</p><p>Kafka消费端也具备一定的容灾能力。Consumer使用(pull)模式从服务器端拉取数据，并且保存消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息丢失。</p><p>分区中所有的副本统称为AR(Assigned Replicas)。所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR(In-Sync Replicas)，ISR集合是AR几何中的一个子集。消息会先发送到leader副本，然后follower副本才能从leader副本中拉取消息进行同步，同步期间follower副本相对于leader副本而言会有一定程度的滞后。</p><p>“一定程度的同步”是指可忍受的滞后范围，这个参数可以配置，与leader副本同步滞后过多的副本（不包括leader副本）组成OSR（Out-of-Sync Replicas），由此可见，AR&#x3D;ISR+OSR。在正常情况下，所有的follower副本都应该与leader副本保持一定程度的同步，即AR&#x3D;ISR，OSR集合为空。</p><p>leader副本负责维护和跟中ISR几何中所有follower副本的滞后状态，当follower副本“追上”leader副本时，leader副本就会将OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader，而在OSR几何中的副本则没有任何机会（也可以通过修改参数配置来改变）。</p><p>ISR与KW和LEO也有紧密的关系。HW是High Watermark的缩写，俗称高水位，他标识了一个特定的消息偏移量（offset），消费者只能拉取到这个offset之前的消息。</p><p>![image-20220628200511940](1.kafka详解&#x2F;images&#x2F;5.kafka offset详解.png)</p><p>如上图所示，代表一个日志文件，这个日志文件中有9条消息，第一条消息的offset（LogStartOffset）为0，最后一条的offset为8，offset为9 的消息代表下一条将要写入的消息。日志文件的HW为6，表示消费者只能拉取到offset在0-5之间的消息，而offset为6的消息对消费者而言是不可见的。</p><p>LEO是Log End Offset的缩写，它标识当前日志文件中下一条待写入消息的offset，上图中offset为9的位置即为当前日志文件的LEO，LEO的大小相当于当前日志分区中最后一条消息的offset值加1。分区ISR几何中的每个副本都会维护自身的LEO，而ISR集合中最小的LEO即为分区的HW，对消费者而言只能消费HW之前的消息。</p></li><li><h4 id="分区机制"><a href="#分区机制" class="headerlink" title="分区机制"></a>分区机制</h4><p>虽然有了副本机制可以保证数据的高可用，但没有解决伸缩性（Scalability）问题。什么是伸缩性呢？拿副本来说，虽然现在有了领导者副本和追随者副本，但倘若领导者副本积累了太多的数据，以至于单台Broker机器无法容纳，此时应该怎么办呢？一个很自然的想法就是能否把数据分割成多分保存在不同的Broker中？这种机制就是所谓的分区。</p></li></ol></li><li><h3 id="kafka的生产者"><a href="#kafka的生产者" class="headerlink" title="kafka的生产者"></a>kafka的生产者</h3><ol><li><h5 id="为什么要分区"><a href="#为什么要分区" class="headerlink" title="为什么要分区"></a>为什么要分区</h5></li><li><h5 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h5><ol><li><strong>轮询策略</strong></li><li><strong>随机策略</strong></li><li><strong>按消息键保存策略</strong></li></ol></li></ol></li><li><h3 id="kafka的消费者"><a href="#kafka的消费者" class="headerlink" title="kafka的消费者"></a>kafka的消费者</h3><ol><li><strong>消费模型</strong></li><li><strong>消费者组</strong></li><li><strong>重平衡</strong><ol><li><strong>消费者组重平衡流程</strong></li></ol></li><li>位移主题<ol><li><strong>位移提交</strong></li></ol></li></ol></li><li><h3 id="kafka的客户端"><a href="#kafka的客户端" class="headerlink" title="kafka的客户端"></a>kafka的客户端</h3><ol><li><strong>kafka副本机制</strong></li><li>副本角色</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;kafka入门须知&quot;&gt;&lt;a href=&quot;#kafka入门须知&quot; class=&quot;headerlink&quot; title=&quot;kafka入门须知&quot;&gt;&lt;/a&gt;kafka入门须知&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;kafka概述&quot;&gt;&lt;a href=&quot;#kafka概述&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构初识</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%9D%E8%AF%86/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%9D%E8%AF%86/</id>
    <published>2023-04-28T10:40:04.943Z</published>
    <updated>2023-04-28T10:44:48.972Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构分为逻辑结构和物理结构</p><p>逻辑结构：指数据对象中数据元素之间的相互关系，也是最需要关注和讨论的问题。</p><p>物理结构：指数据的逻辑结构在计算机中的存储形式。</p><h3 id="一、逻辑结构"><a href="#一、逻辑结构" class="headerlink" title="一、逻辑结构"></a>一、逻辑结构</h3><p>1、集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他不三不四的关系。</p><p>2、线性结构：元素之间一对一的关系</p><p>3、树形结构：数据元素之间存在一种一对多的层次关系，类似树。</p><p>4、图形结构：图形结构的元素是多对多的关系。</p><h3 id="二、物理结构"><a href="#二、物理结构" class="headerlink" title="二、物理结构"></a>二、物理结构</h3><p>1、存储器主要是针对计算机中的内存而言。</p><p>2、数据元素的存储形式有两种：顺序存储和链式存储，</p><p>顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p><p>链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。通过指针存放数据元素的地址，获取元素的顺序。</p><h3 id="三、什么是算法"><a href="#三、什么是算法" class="headerlink" title="三、什么是算法"></a>三、什么是算法</h3><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作。</p><p>算法特征：输入，输出，有穷性，确定性，可行性。</p><h3 id="四、线性表"><a href="#四、线性表" class="headerlink" title="四、线性表"></a>四、线性表</h3><p>线性表(List)：由零个或多个数据元素组成的有限序列。</p><p>首先它是一个序列，也就是元素之间有先来后到。</p><p>若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。</p><p>线性表强调是有限的，无论计算机发展到多强大，它处理的元素都是有限的。</p><p>数据结构包含：</p><p>数组、链表、栈、队列、树��列、树</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据结构分为逻辑结构和物理结构&lt;/p&gt;
&lt;p&gt;逻辑结构：指数据对象中数据元素之间的相互关系，也是最需要关注和讨论的问题。&lt;/p&gt;
&lt;p&gt;物理结构：指数据的逻辑结构在计算机中的存储形式。&lt;/p&gt;
&lt;h3 id=&quot;一、逻辑结构&quot;&gt;&lt;a href=&quot;#一、逻辑结构&quot; class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>trie</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.trie/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.trie/</id>
    <published>2023-04-28T10:40:04.943Z</published>
    <updated>2023-04-28T10:44:48.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="trie的数据结构"><a href="#trie的数据结构" class="headerlink" title="trie的数据结构"></a>trie的数据结构</h2><p>trie树，即字典树有称为单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用于统计和排序大量的字符串（但不限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p><p>它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><h2 id="trie的核心思想"><a href="#trie的核心思想" class="headerlink" title="trie的核心思想"></a>trie的核心思想</h2><p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><h2 id="trie的基本性质"><a href="#trie的基本性质" class="headerlink" title="trie的基本性质"></a>trie的基本性质</h2><ol><li>根节点不包含字符，除根节点外每个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符串连接起来，为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li></ol><p><strong>树&amp;二叉树&amp;二叉搜索树</strong></p><p>trie结构类似生活中倒立的树。</p><p>树最头上的节点叫做头结点，左边任何一个树叫做左子树，右边叫右子树。</p><p>其中节点称为父节点，同一个父节点的子节点称为兄弟节点。</p><p>子节点距离头节点的距离为层级，头节点所在的层级为level0.</p><h2 id="二叉搜索树-Binary-Search-Tree-："><a href="#二叉搜索树-Binary-Search-Tree-：" class="headerlink" title="二叉搜索树(Binary Search Tree)："></a>二叉搜索树(Binary Search Tree)：</h2><p>也称为二叉搜索树、有序二叉树(Ordered binary tree)、排序二叉树（Sorted binary tree），是指一颗空树或者具有下列性质的二叉树：</p><ol><li><code>左子树</code>上所有结点的值均小于它的根节点的值。</li><li><code>右子树</code>上所有结点的值均大于它的根结点的值。</li><li>Recursively，左、右子树也分别为二叉查找树。</li></ol><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ol><li>前序遍历：根左右</li><li>中序遍历：左根右</li><li>后序遍历：左右根</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Trie树&quot;&gt;&lt;a href=&quot;#Trie树&quot; class=&quot;headerlink&quot; title=&quot;Trie树&quot;&gt;&lt;/a&gt;Trie树&lt;/h1&gt;&lt;h2 id=&quot;trie的数据结构&quot;&gt;&lt;a href=&quot;#trie的数据结构&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis高阶</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/3.redis%E9%AB%98%E9%98%B6/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/3.redis%E9%AB%98%E9%98%B6/</id>
    <published>2023-04-28T10:40:04.938Z</published>
    <updated>2023-04-28T10:44:49.059Z</updated>
    
    <content type="html"><![CDATA[<img src="image/1589077011872.png"/>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;image/1589077011872.png&quot;/&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis常见面试题</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/1.redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/1.redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-04-28T10:40:04.937Z</published>
    <updated>2023-04-28T10:44:49.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Redis常见面试题"><a href="#一、Redis常见面试题" class="headerlink" title="一、Redis常见面试题"></a>一、Redis常见面试题</h3><ol><li><h5 id="redis基本数据类型"><a href="#redis基本数据类型" class="headerlink" title="redis基本数据类型"></a>redis基本数据类型</h5><p> 有String，Hash，List，Set，Sort，SortedSet五种基本的数据结构，除此以外，还有HyperLogLog，Geo，Pub&#x2F;Sub三种，还有Redis Module像BloomFilter，RedisSearch，Redis-ML。</p></li><li><h5 id="大量key过期时间设置同一个时间过期，一般需要注意什么？"><a href="#大量key过期时间设置同一个时间过期，一般需要注意什么？" class="headerlink" title="大量key过期时间设置同一个时间过期，一般需要注意什么？"></a>大量key过期时间设置同一个时间过期，一般需要注意什么？</h5><p> 如果大量的key过期时间设置的过于集中，到过期的时间点时，redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，一般需要在过期时间上加一个随机值，使得过期时间分散一些。<br> 加上首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好卡在失效的时间点大量用户涌入，就有可能造成缓存雪崩。</p></li><li><h5 id="使用过redis分布式锁吗？是怎么回事？"><a href="#使用过redis分布式锁吗？是怎么回事？" class="headerlink" title="使用过redis分布式锁吗？是怎么回事？"></a>使用过redis分布式锁吗？是怎么回事？</h5><p>  先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p></li><li><h5 id="如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？"><a href="#如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？" class="headerlink" title="如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？"></a>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</h5><p> 使用set指令可以把setnx和expire合成一条指令使用。</p></li><li><h5 id="假入redis中有1亿个key，其中有10W个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"><a href="#假入redis中有1亿个key，其中有10W个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？" class="headerlink" title="假入redis中有1亿个key，其中有10W个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"></a>假入redis中有1亿个key，其中有10W个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？</h5><p> 使用keys指令可以扫出指定模式的key列表。</p></li><li><h5 id="如果redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"><a href="#如果redis正在给线上的业务提供服务，那使用keys指令会有什么问题？" class="headerlink" title="如果redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"></a>如果redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</h5><p>  redis是单线程，keys指令会导致线程阻塞一段时间，线上服务会停顿，指导指令执行完毕，服务才能恢复。这个时候可以试用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。<br>  不过，增量式迭代命令也不是没有缺点的：试用SMEMBERS命令可以返回集合键当前包含的所有元素，但是对于scan这类增量式迭代命令来说，因为在对键进行增量式迭代的过程中，键可能会被修改，所以增量式迭代命令只能对被返回的元素提供有限的保证。</p></li><li><h5 id="使用过redis做异步队列吗？是怎么使用的？"><a href="#使用过redis做异步队列吗？是怎么使用的？" class="headerlink" title="使用过redis做异步队列吗？是怎么使用的？"></a>使用过redis做异步队列吗？是怎么使用的？</h5><p> 一般使用list结构做为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，要适当sleep一会再重试。</p></li><li><h5 id="如果不使用sleep呢？"><a href="#如果不使用sleep呢？" class="headerlink" title="如果不使用sleep呢？"></a>如果不使用sleep呢？</h5><p> list有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。</p></li><li><h5 id="能不能一次消费多次？"><a href="#能不能一次消费多次？" class="headerlink" title="能不能一次消费多次？"></a>能不能一次消费多次？</h5><p> 使用pub&#x2F;sub主题订阅者模式，可以实现1:N的消息队列。</p></li><li><h5 id="pub-x2F-sub有什么缺点？"><a href="#pub-x2F-sub有什么缺点？" class="headerlink" title="pub&#x2F;sub有什么缺点？"></a>pub&#x2F;sub有什么缺点？</h5><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等。</p></li><li><h5 id="Redis如何实现延时队列？"><a href="#Redis如何实现延时队列？" class="headerlink" title="Redis如何实现延时队列？"></a>Redis如何实现延时队列？</h5><p>  使用sorted set，用时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p></li><li><h5 id="Redis是怎么持久化的？服务主从数据怎么交互的？"><a href="#Redis是怎么持久化的？服务主从数据怎么交互的？" class="headerlink" title="Redis是怎么持久化的？服务主从数据怎么交互的？"></a>Redis是怎么持久化的？服务主从数据怎么交互的？</h5><p>  RDB做镜像全量持久化，AOF做增量持久化，因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p></li><li><h5 id="如果突然机器掉电会怎样？"><a href="#如果突然机器掉电会怎样？" class="headerlink" title="如果突然机器掉电会怎样？"></a>如果突然机器掉电会怎样？</h5><p> 取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p></li><li><h5 id="RDB的原理是什么？"><a href="#RDB的原理是什么？" class="headerlink" title="RDB的原理是什么？"></a>RDB的原理是什么？</h5><p>  fork和cow，fork指redis通过创建子进程来进行RDB操作，cow指copy onwrite，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p></li><li><h5 id="Pipeline有什么好处，为什么要用pipeline。"><a href="#Pipeline有什么好处，为什么要用pipeline。" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline。"></a>Pipeline有什么好处，为什么要用pipeline。</h5><p>可以将多次IO往返的时间缩短为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p></li><li><h5 id="Redis的同步机制有了解么？"><a href="#Redis的同步机制有了解么？" class="headerlink" title="Redis的同步机制有了解么？"></a>Redis的同步机制有了解么？</h5><p>  Redis可以使用主从同步、从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后。在通过主节点将期间修改的操作记录同步到负直节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可。有点类似数据库的binlog。</p></li><li><h5 id="是否使用过redis集群，集群的高可用怎么保证，集群的原理是什么？"><a href="#是否使用过redis集群，集群的高可用怎么保证，集群的原理是什么？" class="headerlink" title="是否使用过redis集群，集群的高可用怎么保证，集群的原理是什么？"></a>是否使用过redis集群，集群的高可用怎么保证，集群的原理是什么？</h5><p> Redis Sentinal 着眼于高可用，在master宕机时会自动将salve提升为master，继续提供服务。<br> Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。使用Cluster进行分片存储。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、Redis常见面试题&quot;&gt;&lt;a href=&quot;#一、Redis常见面试题&quot; class=&quot;headerlink&quot; title=&quot;一、Redis常见面试题&quot;&gt;&lt;/a&gt;一、Redis常见面试题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;h5 id=&quot;redis基本数据类型&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>1基本命令</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2.1%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2.1%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2023-04-28T10:40:04.937Z</published>
    <updated>2023-04-28T10:44:49.055Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、redis基础知识"><a href="#一、redis基础知识" class="headerlink" title="一、redis基础知识"></a>一、redis基础知识</h2><h4 id="客户端和服务器命令："><a href="#客户端和服务器命令：" class="headerlink" title="客户端和服务器命令："></a>客户端和服务器命令：</h4><p>​默认端口号6379</p><h5 id="服务器命令："><a href="#服务器命令：" class="headerlink" title="服务器命令："></a>服务器命令：</h5><p>​redis-server redis.windows.conf</p><h5 id="客户端命令："><a href="#客户端命令：" class="headerlink" title="客户端命令："></a>客户端命令：</h5><p>​redis-cli</p><p>一个redis.windows.conf配置文件，就是一个redis服务器。需要启动多个服务器时，只需修改配置文件的名称，再使用redis-server命令即可。</p><img src="image/1576045069390.png"><img src="image/1576045229007.png"><img src="image/1576045281626.png"><h4 id="redis和memcache相比的独特之处"><a href="#redis和memcache相比的独特之处" class="headerlink" title="redis和memcache相比的独特之处"></a>redis和memcache相比的独特之处</h4><ol><li>redis可以用来存储(storge)，有持久化的功能（是可以存储到硬盘中），而memcached用来做缓存（cache）。</li><li>redis存储的数据有结构；对于memcache来说，存储的数据只有一种数据类型——字符串，而redis则可以存储字符串，链表，哈希结构，集合，有序集合。，</li></ol><h4 id="redis目录下的重要文件的意义"><a href="#redis目录下的重要文件的意义" class="headerlink" title="redis目录下的重要文件的意义"></a>redis目录下的重要文件的意义</h4><ul><li><strong>redis-benchmark</strong>：性能测试工具</li><li><strong>redis-check-dump</strong>：日志文件检测工具（比如断电造成日志损坏，可以检测并修复。）</li><li><strong>redis-check-dump</strong>：快照文件检测工具，效果同上。</li><li><strong>redis-cli</strong>：客户端。</li><li><strong>redis-server</strong>：服务端</li><li><strong>redis.windows.conf</strong>：配置文件</li></ul><h2 id="二：基础命令"><a href="#二：基础命令" class="headerlink" title="二：基础命令"></a>二：基础命令</h2><ul><li>**keys ***：返回所有的key</li><li><strong>keys list</strong>：返回名以list开头的所有key</li><li><strong>exists list1</strong>：判断名为list1的key是否存在，存在返回1，不存在返回0</li><li><strong>del list1</strong>：删除一个键list1</li><li><strong>exprice list1 10</strong>：设置键名为list1的过期时间为10秒后</li><li><strong>ttl list1</strong>：查看键名为list1的过期时间，若为-1，表示以过期或永不过期</li><li><strong>move age 1</strong>：将键名为age的转移到1数据库中</li><li><strong>select 1</strong>：表示进入1数据库，默认在0中，一共有16个，从0到15</li><li><strong>persist age</strong>：移除age的过期时间。</li><li><strong>flushdb</strong>：删除所有的数据，清除当前所在库的所有数据。</li><li><strong>flushall</strong>：清空所有数据。</li></ul><h3 id="（一）-字符串类型"><a href="#（一）-字符串类型" class="headerlink" title="（一）.字符串类型"></a>（一）.字符串类型</h3><table><thead><tr><th align="center">存命令</th><th align="center">取命令</th></tr></thead><tbody><tr><td align="center">mset</td><td align="center">mget</td></tr><tr><td align="center">setnx</td><td align="center">msetnx</td></tr><tr><td align="center">incr</td><td align="center">decr</td></tr><tr><td align="center">incrby</td><td align="center">decrby</td></tr><tr><td align="center">setrange</td><td align="center">getrange</td></tr><tr><td align="center">set</td><td align="center">get</td></tr></tbody></table><ol><li><p><strong>set方法：设置key对应的值为string类型的value，如果该key已经存在，则覆盖，所以在redis中key唯一。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name lijie</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p><strong>get：根据key获取value的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;lijie&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>setnx：设置一个不存在的字符串，返回0表示设置失败，已存在。返回1表示设置新值成功，nx是not exit的意思。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx name zs</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setnx age 20</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p><strong>setex：设置字符串，同时设置有效期</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex lvjia 10 &#x27;jia&#x27;</span><br><span class="line">OK</span><br><span class="line">（立即查询）</span><br><span class="line">127.0.0.1:6379&gt; get lvjia</span><br><span class="line">&quot;jia&quot;</span><br><span class="line">（10秒后启动）</span><br><span class="line">127.0.0.1:6379&gt; get lvjia</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li><li><p><strong>setrange：替换字符串，参数为开始位置下标(从0开始)，替换成什么</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set email lvjia@sina.com</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get email</span><br><span class="line">&quot;lvjia@sina.com&quot;</span><br><span class="line">127.0.0.1:6379&gt; setrange email 6 163.com</span><br><span class="line">(integer) 14</span><br><span class="line">127.0.0.1:6379&gt; get email</span><br><span class="line">&quot;lvjia@163.comm&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>msetnx：一次设置多个不存在的key-value，返回1表示全部设置成功，返回0表示全部失败。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; msetnx name3 kk name4 mm name2 lvjia</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get name3</span><br><span class="line">&quot;kk&quot;</span><br><span class="line">127.0.0.1:6379&gt; get name2</span><br><span class="line">&quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379&gt; get name4</span><br><span class="line">&quot;mm&quot;</span><br><span class="line">127.0.0.1:6379&gt; msetnx name3 cc name4 dd</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li><p><strong>getset：获取原值，并设置新值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getset name4 UU</span><br><span class="line">&quot;mm&quot;</span><br><span class="line">127.0.0.1:6379&gt; get name4</span><br><span class="line">&quot;UU&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>getrange：获取key对应value的子字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange email 0 4</span><br><span class="line">&quot;lvjia&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>mget：一次获取多个key对应的value值，不存在返回nil</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget name1 name2 name3 name4 name5 name6</span><br><span class="line">1) (nil)</span><br><span class="line">2) &quot;lvjia&quot;</span><br><span class="line">3) &quot;kk&quot;</span><br><span class="line">4) &quot;UU&quot;</span><br><span class="line">5) (nil)</span><br><span class="line">6) (nil)</span><br></pre></td></tr></table></figure></li><li><p><strong>incr：对key对应的value做加1操作，并返回新值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">&quot;21&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr age</span><br><span class="line">(integer) 22</span><br></pre></td></tr></table></figure></li><li><p><strong>incrby：与incr类似，加指定值，key不存在的时候会设置key，并认为该key原来的value&#x3D;0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">&quot;22&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrby age 9</span><br><span class="line">(integer) 31</span><br><span class="line">127.0.0.1:6379&gt; get height</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; incrby height 10</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; get height</span><br><span class="line">&quot;10&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>decr：对key对应的value做减1操作。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get height</span><br><span class="line">&quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; decr height</span><br><span class="line">(integer) 9</span><br></pre></td></tr></table></figure></li><li><p><strong>decrby:对key对应的value减去指定的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get height</span><br><span class="line">&quot;9&quot;</span><br><span class="line">127.0.0.1:6379&gt; decrby height 3</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; decrby height -3</span><br><span class="line">(integer) 9</span><br></pre></td></tr></table></figure></li><li><p><strong>append:对key对应的value字符串追加，返回新字符串的长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;lijie&quot;</span><br><span class="line">127.0.0.1:6379&gt; append name ML</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;lijieML&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>strlen:获取key对应value的长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;lijie&quot;</span><br><span class="line">127.0.0.1:6379&gt; append name ML</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;lijieML&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>del：删除指定key，可一下指定多个，会返回删除成功的条数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;lijieML&quot;</span><br><span class="line">127.0.0.1:6379&gt; del age name</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; del name1</span><br><span class="line">(integer) </span><br></pre></td></tr></table></figure></li></ol><h3 id="（二）-hash类型"><a href="#（二）-hash类型" class="headerlink" title="（二）.hash类型"></a>（二）.hash类型</h3><p>Redis hash是一个string类型的filed和value的映射表。Hash特别适合存储对象。相比较于对象的每个字段存成单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便存取整个对象。</p><ol><li><p><strong>hset：设置hash field为指定值，如果key不存在，则先创建，key存在则替换，如果不存在时返回1，存在时返回0。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:001 name zs</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user:001 name lvjia</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li><p><strong>hget：获取指定field字段的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:001 name</span><br><span class="line">&quot;lvjia&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>hsetnx：设置hash field为指定值，如果key不存在，则先创建，如果存在则返回0，表示设置失败。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx user:001 name dachang</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hsetnx user:001 age 20</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p><strong>hmset：同时设置hash的多个field</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:002 name lvjia age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hget user:002 name</span><br><span class="line">&quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget user:002 age</span><br><span class="line">&quot;20&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>hmget：获取多个指定的hash field，必须指定获取的key的名称</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget user:002 name age</span><br><span class="line">1) &quot;lvjia&quot;</span><br><span class="line">2) &quot;20&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>hincrby：对hash field加上指定的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:002 age</span><br><span class="line">&quot;20&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrby user:002 age 5</span><br><span class="line">(integer) 25</span><br><span class="line">127.0.0.1:6379&gt; hincrby user:002 age -4</span><br><span class="line">(integer) 21</span><br></pre></td></tr></table></figure></li><li><p><strong>hexists：测试指定的field是否存在，返回1表示存在，返回0表示不存在。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists user:002 name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists user:002 age</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists user:002 height</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li><p><strong>hdel：返回指定hash的field的数量，返回1表示删除成功，0表示删除失败</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel user:001 age</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hdel user:001 address</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li><p><strong>hkeys：返回hash的所有field</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user:001</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; hkeys user:002</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>hvals:返回hash的所有value</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals user:001</span><br><span class="line">1) &quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals user:002</span><br><span class="line">1) &quot;lvjia&quot;</span><br><span class="line">2) &quot;21&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>hlen:返回hash的key的长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen user</span><br><span class="line">1) &quot;lvjia&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="（三）-list类型"><a href="#（三）-list类型" class="headerlink" title="（三）.list类型"></a>（三）.list类型</h3><p>list是一个链表结构，主要功能是push、pop，获取一个范围的所有值等等，操作中key理解为链表的名字。Redis的list类型其实就是一个每个子元素都是string类型的双向链表。我们可以通过push、pop这些操作链表的头部或者链表尾部添加元素，这样list既可以为栈，又可以作为队列。</p><ol><li><p><strong>lpush：在key对应list的头部添加字符串元素，返回list元素中的个数</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lpush list1 &quot;hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; lpush list1 &quot;word&quot;</span><br><span class="line">(integer 2</span><br></pre></td></tr></table></figure></li><li><p><strong>lrange：获取list中的元素，后边跟两个参数分别代表起始位置和结束位置。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lrange list1 0 -1</span><br><span class="line">1) &quot;word&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>rpush：在key对应的list尾部添加元素</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; rpush list2 10</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; rpush list2 11</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379[1]&gt; rpush list2 12</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;10&quot;</span><br><span class="line">2) &quot;11&quot;</span><br><span class="line">3) &quot;12&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>linsert：在key对应list的特定位置前或者后添加字符串</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; linsert list2 before 11 10.5</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;10&quot;</span><br><span class="line">2) &quot;10.5&quot;</span><br><span class="line">3) &quot;11&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; linsert list2 before 1 2</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;10&quot;</span><br><span class="line">2) &quot;10.5&quot;</span><br><span class="line">3) &quot;11&quot;</span><br><span class="line">4) &quot;12&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>lset：更改list中指定下标的元素，返回ok表示设置成功</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;10&quot;</span><br><span class="line">2) &quot;10.5&quot;</span><br><span class="line">3) &quot;11&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; lset list2 1 10.00</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;10&quot;</span><br><span class="line">2) &quot;10.00&quot;</span><br><span class="line">3) &quot;11&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; lset list2 10 10.00</span><br><span class="line">(error) ERR index out of range</span><br></pre></td></tr></table></figure></li><li><p><strong>lrem：从key对应list中删除n个和value相同的元素(n&lt;0从尾部删除，n&#x3D;0全部删除)</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;10.00&quot;</span><br><span class="line">2) &quot;11&quot;</span><br><span class="line">3) &quot;12&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; lrem list2 2 10.00</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;11&quot;</span><br><span class="line">2) &quot;12&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>ltrim：保留list中指定范围的数据全部删除</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;11&quot;</span><br><span class="line">2) &quot;12&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;30&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; ltrim list2 1 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;12&quot;</span><br><span class="line">2) &quot;10&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>lpop：从list的头部删除元素，并返回该元素</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;12&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; lpop list2</span><br><span class="line">&quot;12&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;10&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>rpop：从list尾部删除元素，并返回该元素</strong></p></li><li><p><strong>rpoplpush：从第一个list的尾部删除元素，并添加到第二个list的头部。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list1 0 -1</span><br><span class="line">1) &quot;word&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; rpoplpush list1 list2</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange list1 0 -1</span><br><span class="line">1) &quot;word&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>lindex：返回名称为key的list中的index位置的元素</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lrange list2 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; lindex list2 1</span><br><span class="line">&quot;10&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>llen：返回指定key对应list的长度</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lrange  list2 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; llen list2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li></ol><h3 id="（四）-set类型"><a href="#（四）-set类型" class="headerlink" title="（四）.set类型"></a>（四）.set类型</h3><p>Set是一个string类型的无序集合，不允许重复。Set是通过hash table实现的。添加、删除、查找复杂度都是0&#x2F;1。对集合我们可以取并集、交集、差集。</p><ol><li><p><strong>sadd：向key对应的set集合中添加元素，返回1表示添加成功，返回0表示失败。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; sadd myset1 lvjia</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[2]&gt; sadd myset1 lvjia</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[2]&gt; sadd myset1 dachang</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>smembers：查看集合中的元素</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;dachang&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>srem：删除key对应set集合中的元素，返回1表示删除成功，0表示失败。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;dachang&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; srem myset1 two</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[2]&gt; srem myset1 dachang</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p><strong>spop：随即删除set中的一个元素并返回该元素</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; spop myset1</span><br><span class="line">&quot;dachang&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; spop myset1</span><br><span class="line">&quot;haha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;wahaha&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>sdiff：返回给定set集合的差集（以前边的set集合为标准）</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset2</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">3) &quot;wahaha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;wahaha&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; sdiff myset2 myset1</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>sdiffstore：返回所有给定的set集合的差集，并将差集添加到另一个集合中。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;wahaha&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset2</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">3) &quot;wahaha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; sdiffstore myset3 myset1 myset2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset3</span><br><span class="line">1) &quot;lvjia&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>sinter：返回所有给定集合的交集。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;wahaha&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset2</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">3) &quot;wahaha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; sinter myset1 myset2</span><br><span class="line">1) &quot;wahaha&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>sinterstore：返回所有给定集合key的交集，并将结果存为另一个key</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;wahaha&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; smebers myset2</span><br><span class="line">(error) ERR unknown command &#x27;smebers&#x27;</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset2</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">3) &quot;wahaha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; sinterstore myset4 myset1 myset2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset4</span><br><span class="line">1) &quot;wahaha&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>sunion：返回所有给定集合的并集。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; sunion myset1 myset2</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;wahaha&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>sunionstore：返回所有给定集合的并集，并将结果存入另一个集合。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;wahaha&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset2</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">3) &quot;wahaha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; sunionstore myset5 myset1 myset2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset5</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;wahaha&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>smove：从第一个集合中移除元素并将该元素添加到另一个集合中。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;wahaha&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset2</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">3) &quot;wahaha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; smove myset2 myset1 wahaha</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;wahaha&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>scard：返回set集合中元素的个数。llen(list),strlen(str)，hlen(hash)</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset2</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; scard myset1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li><p><strong>sismember：测试member元素是否是名为key的set集合，返回1表示是，返回0表示不是。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; smembers myset1</span><br><span class="line">1) &quot;wahaha&quot;</span><br><span class="line">2) &quot;lvjia&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; sismember myset1 two</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[2]&gt; sismember myset1 wahaha</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p><strong>srandmember：随即返回set集合中的几个元素，但不删除这几个元素</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[2]&gt; srandmember myset1</span><br><span class="line">&quot;wahaha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; smembers myset2</span><br><span class="line">1) &quot;hhaha&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br><span class="line">127.0.0.1:6379[2]&gt; srandmember myset1 2</span><br><span class="line">1) &quot;lvjia&quot;</span><br><span class="line">2) &quot;wahaha&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="（五）-sorted-set类型"><a href="#（五）-sorted-set类型" class="headerlink" title="（五）.sorted set类型"></a>（五）.sorted set类型</h3><p>sorted set是set的一个升级版，它在set的基础上增加了一个顺序属性，这一属性在添加元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以理解为有两列的MySQL表，一列存value，一列存顺序。操作key理解为zset的名字。</p><ol><li><p><strong>zadd：向有序集合zset中添加元素并指定顺序，如果该元素已存在就更新元素顺序。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zadd myzset1 1 one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; zadd myzset1 2 two</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p><strong>zrange：从zset集合中取元素，（withscores）输出元素顺序号</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;2&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>zrem：删除zset集合中指定的元素</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrem myzset1 dachang</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;5&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>zincrby：若zset中已经存在元素member、则该元素的score增加increment否则向该集合中添加该元素，其score的值为increment。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; zincrby myzset1 2 one</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; zincrby myzset1 2 one</span><br><span class="line">&quot;5&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;lvjia&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;5&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>zrank：返回zset中元素member的排名(score从小到大排序)即下标</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;dachang&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;one&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; zrank myzset1 dachang</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[3]&gt; zrank myzset1 lvjia</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p><strong>zrevrank：返回zset集合中member元素的排名（按照score倒叙）即下标</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;dachang&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;one&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; zrevrank myzset1 dachang</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li><p><strong>zrevrange：从zset集合中倒叙（score倒叙）获取元素</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrevrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;dachang&quot;</span><br><span class="line">6) &quot;1&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>zrangebyscore：从zset集合中根据score顺序获取元素</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;dachang&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;one&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; zrangebyscore myzset1 4 5 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;5&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>zcount：返回zset集合中score在给定区间的所有元素个数</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;dachang&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;one&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; zcount myzset1 4 5</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p><strong>zcard：返回zset集合中所有元素个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;dachang&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;lvjia&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;one&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; zcard myzset1</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li><li><p><strong>zremrangebyrank：删除集合中排名（下标）在给定区间的元素。</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;lvjia&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;dachang&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;haha&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; zremrangebyrank myzset1 0 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores</span><br><span class="line">1) &quot;haha&quot;</span><br><span class="line">2) &quot;3&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>zremrangebyscore：删除集合中顺序（score值）在给定区间的元素</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">1</span> <span class="string">&quot;one&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">2</span> <span class="string">&quot;two&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">3</span> <span class="string">&quot;three&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">4</span> <span class="string">&quot;four&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">5</span> <span class="string">&quot;five&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; zrange myset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line">(empty list <span class="keyword">or</span> set)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;four&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;five&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZREMRANGEBYSCORE myzset <span class="number">2</span> <span class="number">4</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;five&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;five&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="（六）发布-x2F-订阅"><a href="#（六）发布-x2F-订阅" class="headerlink" title="（六）发布&#x2F;订阅"></a>（六）发布&#x2F;订阅</h3><h3 id="（七）布隆过滤器"><a href="#（七）布隆过滤器" class="headerlink" title="（七）布隆过滤器"></a>（七）布隆过滤器</h3><pre><code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">1</span> <span class="string">&quot;one&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">2</span> <span class="string">&quot;two&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">3</span> <span class="string">&quot;three&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">4</span> <span class="string">&quot;four&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZADD myzset <span class="number">5</span> <span class="string">&quot;five&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; zrange myset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line">(empty list <span class="keyword">or</span> set)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;four&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;five&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; ZREMRANGEBYSCORE myzset <span class="number">2</span> <span class="number">4</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;five&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>[<span class="number">9</span>]&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;five&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="（六）发布-x2F-订阅-1"><a href="#（六）发布-x2F-订阅-1" class="headerlink" title="（六）发布&#x2F;订阅"></a>（六）发布&#x2F;订阅</h3><h3 id="（七）布隆过滤器-1"><a href="#（七）布隆过滤器-1" class="headerlink" title="（七）布隆过滤器"></a>（七）布隆过滤器</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一、redis基础知识&quot;&gt;&lt;a href=&quot;#一、redis基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、redis基础知识&quot;&gt;&lt;/a&gt;一、redis基础知识&lt;/h2&gt;&lt;h4 id=&quot;客户端和服务器命令：&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>主从复制</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%AB%98%E9%98%B6%E5%BA%94%E7%94%A8/1.%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%AB%98%E9%98%B6%E5%BA%94%E7%94%A8/1.%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2023-04-28T10:40:04.930Z</published>
    <updated>2023-04-28T10:44:49.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h2><p>最常见的集群方案：</p><p>Replication：速度快，弱一致性，低价值，日志，新闻，帖子</p><p>PXC：速度慢，强一致性，高价值，订单，账户，财务。</p><p>一、MySQL Replication</p><p>主从复制（也称AB复制）允许将来自一个MySQL数据库服务器（主服务器）的数据复制到一个或多个MySQL数据库服务器（从服务器）。</p><p>复制是异步的，从站不需要永久连接以接收来自主站的更新。</p><p>根据配置，可以复制数据库中所有的数据库，所选数据库甚至是选定的表。</p><p>MySQL中赋值的优点包括：</p><ul><li>横向扩展解决方案，再多个从站之间分配负载以提高性能。在此环境中，所有写入和更新都必须在主服务器上进行。但是，读取可以在一个或多个从设备上进行。该模型可以提高写入性能（因为主设备专用于更新），同时显著提高了越来越多的从设备的读取速度。</li><li>数据安全性，因为数据被复制到从站，并且从站可以暂停复制过程，所以可以在从站上运行备份服务而不会破坏相应的主数据。</li><li>分析，可以在主服务器上创建实时数据，而信息分析可以在从服务器上进行，而不会影响主服务器的性能。</li><li>远程数据分发，可以使用复制为远程站点创建数据的本地副本，而无需永久访问主服务器。</li></ul><p>Replication的原理：</p><img src="image/1592892518184.png"><ol><li>主服务器上面的任何修改都会通过自己的I&#x2F;O thread(I&#x2F;O线程)保存在二进制日志<code>Binary log</code>里面</li><li>从服务器上面也启动 一个I&#x2F;O thread，通过配置好的用户名和密码，连接到主服务器上边请求读取二进制日志，然后把读取到的二进制日志写到本地的一个<code>Realy log</code>（中继日志）里面。</li><li>从服务器上面同时开启一个SQL thread定时检查<code>Realy log</code>（这个文件也是二进制的），如果发现有更新立即把更新的内容在本机数据库上执行一遍。</li></ol><p>每个从服务器都会收到主服务器二进制日志的全部内容的副本。</p><p>从服务器设备负责决定应该执行二进制日志中的哪些语句。</p><p>除非另行制定，否则主从二进制日志中的所有时间都在从站上执行。</p><p>如果需要，您将从服务器配置为仅处理一些特定数据库或表的事件。</p><p><strong>注意：无法将主服务器裴志伟仅记录特定时间</strong>。</p><p>每个从站（从服务器）都会记录二进制日志坐标：</p><ul><li>文件名</li><li>文件中它已经从主站读取和处理的位置。</li></ul><p>由于每个从服务器都分别记录了自己当前处理二进制日志中的位置，因此可以断开服务器的连接，重新连接然后恢复继续处理。</p><h4 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h4><p>如果一主多从的话，这时主库既要负责写又要负责为几个从库提供二进制日志。此时可以稍作调整，将二进制日志只给一从，这一从再开启二进制日志并将自己的二进制日志再发给其他从。或者干脆这个从不记录只负责将二进制日志转发给其他从，这样架构起来性能要好很多，而且数据之间的延时也会好一点。工作原理如下：</p><img src="image/1592892578841.png"><h4 id="关于二进制文件"><a href="#关于二进制文件" class="headerlink" title="关于二进制文件"></a>关于二进制文件</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html">mysqld</a>将数字扩展名附加到二进制日志基本名称以生成人禁止日志文件名。每次服务器创建新日志文件时，该数字都会增加，从而创建一系列有序的文件。每次启动或刷新日志时，服务器都会在系列中创建一个新文件。服务器还会在当前日志大小达到<code>max_binlog_size</code>参数设置的的大小后自动创建新的二进制日志文件。二进制日志文件可能会比<code>max_binlog_size</code>使用大型事务时更大，因为事务是以一个部分写入文件，而不是在文件之间分割。</p><p>为了跟踪已使用的二进制日志文件，mysqld还创建了一个二进制日志索引文件，其中包含所有使用的二进制日志文件的名称。</p><p>默认情况下，它具有与二进制日志文件相同的基本名称，并带有扩展名”<code>.index</code>“。在mysqld运行时，不要手动编辑此文件。</p><p>术语<code>二进制日志文件</code>通常表示包含数据库事件的单个编号文件。</p><p>术语<code>二进制日志</code>表示含编号的二进制日志文件集加上索引文件。</p><p><code>SUPER</code>权限的用户可以试用<code>SET sql_log_bin=0</code>语句禁用其当前环境下自己的语句的二进制日志记录。</p><h4 id="配置Replication"><a href="#配置Replication" class="headerlink" title="配置Replication"></a>配置Replication</h4><h5 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h5><ol><li><p>在主服务器上，必须启用二进制日志记录并配置唯一的服务器ID。需要重启服务器。</p><p> 编辑主服务器上的配置文件<code>my.cnf</code>，添加如下内容：</p><blockquote><p>[mysqld]</p><p>log-bin&#x3D;&#x2F;var&#x2F;log&#x2F;mysql&#x2F;mysql-bin</p><p>server-id&#x3D;1</p></blockquote><p> 创建日志目录并赋予权限：</p><blockquote><p>shell&gt; mkdir  &#x2F;var&#x2F;log&#x2F;mysql</p><p>shell&gt; chown mysql.mysql &#x2F;var&#x2F;log&#x2F;mysql</p></blockquote><p> 重启服务</p><blockquote><p>shell&gt; systemctl restart mysqld</p></blockquote><p> <strong>注意：</strong><br> 如果省略server-id（或将其显式设置为默认值0），则主服务器拒绝来自从服务器的任何连接。</p><p> 为了在使用带有事务的InnoDB进行赋值设置时尽可能提高持久性和一致性。</p><p> 可以在master my.cnf文件中使用以下配置项：</p><blockquote><p>innodb_flush_log_at_trx_commit &#x3D; 1</p><p>sync_binlog &#x3D; 1</p></blockquote><p> 确保在主服务器上<code>skip_networking</code>选项处于OFF关闭状态，这是默认值。如果是启用的，则从站无法与主站通信，并且复制失败。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%skip_networking%&#x27;;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| skip_networking | OFF   |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>应该创建一个专门用于复制数据的用户</p><p> 每个从服务器需要使用MySQL主服务器上的用户名和密码连接到主站。</p><p> 例如：计划使用用户<code>rep1</code>�务器上的用户名和密码连接到主站。</p><p> 例如：计划使用用户<code>rep1</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL主从复制&quot;&gt;&lt;a href=&quot;#MySQL主从复制&quot; class=&quot;headerlink&quot; title=&quot;MySQL主从复制&quot;&gt;&lt;/a&gt;MySQL主从复制&lt;/h2&gt;&lt;p&gt;最常见的集群方案：&lt;/p&gt;
&lt;p&gt;Replication：速度快，弱一致性，低价值，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>orm操作数据库</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/9.orm%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/9.orm%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2023-04-28T10:40:04.924Z</published>
    <updated>2023-04-28T10:44:49.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ORM操作数据库"><a href="#ORM操作数据库" class="headerlink" title="ORM操作数据库"></a>ORM操作数据库</h2><ol><li><h3 id="orm介绍"><a href="#orm介绍" class="headerlink" title="orm介绍"></a>orm介绍</h3><p> 对象关系映射</p><p> 全称：Object Relational Mapping，对象关系映射</p><p> 将python中的类映射为数据库中的表，一个类就是一张表，类的属性映射为表中的字段将python代码翻译为对应的数据库sql语句。</p></li><li><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p> 1、降低耦合</p><p> 2、开发人员只需要关注业务逻辑，降低开发人员的工作强度</p></li><li><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p> 1、降低查询效率。</p><p> 2、受orm方法的限制，复杂查询不容易编写。</p></li><li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p> python中的ORM,即sqlalchemy，仿照的是Django框架的ORM。flask中有ORM的插件即：flask-sqlalchemy</p><p> 安装：在命令行执行：pip install sqlalchemy</p></li><li><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p> 1、导包</p><p> 2、创建连接</p><p> 3、声明一个基类</p><p> 4、创建类-数据模型</p><p> 5、操作</p></li><li><h3 id="orm操作数据库"><a href="#orm操作数据库" class="headerlink" title="orm操作数据库"></a>orm操作数据库</h3></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlalchemy</span><br><span class="line"><span class="comment">#1、导包</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="comment">#类似pymysql中的游标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="comment">#2、创建连接</span></span><br><span class="line"><span class="comment">#数据库类型+数据库的操作包://用户名:密码@IP地址/数据库</span></span><br><span class="line"><span class="comment">#有mysqlclient包时，mysql+pymysql可改为mysql</span></span><br><span class="line"></span><br><span class="line">db = sqlalchemy.create_engine(<span class="string">&quot;mysql://root:root@localhost/sqlorm&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、创建基类</span></span><br><span class="line">base = declarative_base(db)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、创建表--数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">base</span>):</span><br><span class="line">    <span class="comment">#表名</span></span><br><span class="line">    __tablename__=<span class="string">&quot;user&quot;</span></span><br><span class="line">    <span class="comment">#字段</span></span><br><span class="line">    <span class="built_in">id</span> = sqlalchemy.Column(sqlalchemy.Integer,primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = sqlalchemy.Column(sqlalchemy.String(<span class="number">32</span>))</span><br><span class="line">    age = sqlalchemy.Column(sqlalchemy.Integer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserInfo</span>(<span class="title class_ inherited__">base</span>):</span><br><span class="line">    __tablename__=<span class="string">&quot;userinfo&quot;</span></span><br><span class="line">    <span class="built_in">id</span> = sqlalchemy.Column(sqlalchemy.Integer,primary_key=<span class="literal">True</span>)</span><br><span class="line">    phone = sqlalchemy.Column(sqlalchemy.String(<span class="number">20</span>))</span><br><span class="line">    user = sqlalchemy.Column(sqlalchemy.Integer,sqlalchemy.ForeignKey(<span class="string">&quot;user.id&quot;</span>),)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#执行数据库迁移（创建表）</span></span><br><span class="line">    base.metadata.create_all(db)</span><br><span class="line">    <span class="comment">#绑定一个session实例</span></span><br><span class="line">    s=sessionmaker(bind=db)</span><br><span class="line">    <span class="comment">#创建一个会话对象，类似于游标</span></span><br><span class="line">    session=s()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#数据库操作</span></span><br><span class="line">    <span class="comment">#添加</span></span><br><span class="line">    <span class="comment">#1.1 单条插入</span></span><br><span class="line">    <span class="comment"># user = User(name=&quot;hello&quot;,age=16)</span></span><br><span class="line">    <span class="comment"># session.add(user)</span></span><br><span class="line">    <span class="comment"># session.commit()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#1.2、多条插入</span></span><br><span class="line">    <span class="comment"># session.add_all([</span></span><br><span class="line">    <span class="comment">#     User(name=&quot;world&quot;,age=20),</span></span><br><span class="line">    <span class="comment">#     User(name=&quot;python&quot;,age=28),</span></span><br><span class="line">    <span class="comment">#     User(name=&quot;PHP&quot;,age=34)</span></span><br><span class="line">    <span class="comment"># ])</span></span><br><span class="line">    <span class="comment"># session.commit()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#2、查询</span></span><br><span class="line">    <span class="comment">#2.1、查询所有的数据，返回一个存放对象的列表</span></span><br><span class="line">    <span class="comment"># res = session.query(User).all()</span></span><br><span class="line">    <span class="comment"># for x in res:</span></span><br><span class="line">    <span class="comment">#     print(x.name,x.age)</span></span><br><span class="line">    <span class="comment">#2.2、通过主键值查询一条数据，返回一个对象</span></span><br><span class="line">    <span class="comment"># res = session.query(User).get(2)</span></span><br><span class="line">    <span class="comment"># print(res.name,res.age)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#条件查询，返回的 是一个存放对象的列表</span></span><br><span class="line">    <span class="comment"># res = session.query(User).filter_by(name=&quot;python&quot;).all()</span></span><br><span class="line">    <span class="comment"># for x in res:</span></span><br><span class="line">    <span class="comment">#     print(x.name,x.age)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#3、修改</span></span><br><span class="line">    res = session.query(User).get(<span class="number">1</span>)</span><br><span class="line">    res.name=<span class="string">&#x27;hh&#x27;</span></span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#4、删除</span></span><br><span class="line">    res =session.query(User).get(<span class="number">1</span>)</span><br><span class="line">    session.delete(res)</span><br><span class="line">    session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pymysql与orm的对比</span></span><br><span class="line"><span class="comment">#pymysql—sql—&gt;mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python—python—&gt;ORM—sql—&gt;mysql</span></span><br></pre></td></tr></table></figure><p>与orm的对比<br>#pymysql—sql—&gt;mysql</p><p>#python—python—&gt;ORM—sql—&gt;mysql</p><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ORM操作数据库&quot;&gt;&lt;a href=&quot;#ORM操作数据库&quot; class=&quot;headerlink&quot; title=&quot;ORM操作数据库&quot;&gt;&lt;/a&gt;ORM操作数据库&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;orm介绍&quot;&gt;&lt;a href=&quot;#orm介绍&quot; class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pymysql的使用</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/8.pymysql%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/8.pymysql%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-28T10:40:04.923Z</published>
    <updated>2023-04-28T10:44:49.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h2><ol><li><h4 id="pymysql简介"><a href="#pymysql简介" class="headerlink" title="pymysql简介"></a>pymysql简介</h4><p> PyMySQL：是一个使python连接到MySQL的库，是一个纯python的库。</p><p> <strong>环境要求：</strong></p><ol><li><p>python2.7</p></li><li><p>python version&gt;&#x3D;3.4</p></li><li><p>安装PyMYSQL</p><p> pip install PyMySQL</p></li></ol></li><li><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p> import pymysql</p></li><li><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p> 参数：host,user,password,database,port,</p><p> <strong>cursorclass&#x3D;pymysql.cursor.DictCursor</strong>不加该参数时表现形式为元组。</p><p> 加参数时输出为字典格式。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = pymysql.connect(host=<span class="string">&quot;10.10.101.243&quot;</span>,user=<span class="string">&quot;root&quot;</span>,password=<span class="string">&quot;root&quot;</span>,database=<span class="string">&quot;test&quot;</span>,port=<span class="number">3306</span>)</span><br></pre></td></tr></table></figure></li><li><h4 id="创建游标对象"><a href="#创建游标对象" class="headerlink" title="创建游标对象"></a>创建游标对象</h4><p> 游标：游标是处理数据的一种方法，为了查看或者处理结果集中的数据，在结果集中一次一行或者多行前进或向后浏览数据的能力。可以把游标当作一个指针，它可以指定结果中的任何位置，然后允许用户对指定位置的数据进行处理通俗来说，操作数据和获取数据库结果都要通过游标来操作。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor = db.cursor()</span><br></pre></td></tr></table></figure></li><li><h4 id="定义sql语句"><a href="#定义sql语句" class="headerlink" title="定义sql语句"></a>定义sql语句</h4> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&quot;SELECT database()&quot;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="执行sql语句，获取返回值"><a href="#执行sql语句，获取返回值" class="headerlink" title="执行sql语句，获取返回值"></a>执行sql语句，获取返回值</h4> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取返回值 fetchone()  获取一条数据</span></span><br><span class="line"><span class="built_in">print</span>(cursor.fetchone())</span><br><span class="line"><span class="comment">#获取返回值 fetchall()  获取所有数据</span></span><br><span class="line"><span class="built_in">print</span>(cursor.fetchall())</span><br><span class="line"><span class="comment">#获取返回值 fetchmany()  获取2条数据</span></span><br><span class="line"><span class="built_in">print</span>(cursor.fetchmany(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li><h4 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h4> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></li><li><h4 id="封装MySql类"><a href="#封装MySql类" class="headerlink" title="封装MySql类"></a>封装MySql类</h4> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySql</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, user, password, database</span>):</span><br><span class="line">        self.host = host</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line">        self.database = database</span><br><span class="line">        self.cursorclass = pymysql.cursors.DictCursor</span><br><span class="line">        <span class="comment"># self.port=3306</span></span><br><span class="line">        self.connect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        self.db = pymysql.connect(</span><br><span class="line">            self.host, self.user, self.password, self.database, cursorclass=self.cursorclass)</span><br><span class="line">        self.cursor = self.db.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self, sql</span>):</span><br><span class="line">        self.db_edit(sql)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drop</span>(<span class="params">self, sql</span>):</span><br><span class="line">        self.db_edit(sql)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">db_edit</span>(<span class="params">self,sql</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">        <span class="keyword">except</span> BaseException:</span><br><span class="line">            <span class="keyword">raise</span> traceback.format_stack()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_one</span>(<span class="params">self, sql</span>):</span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            res = self.cursor.fetchone()</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;get_one&quot;</span>, e)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_all</span>(<span class="params">self, sql</span>):</span><br><span class="line">        res = ()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            res = self.cursor.fetchall()</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;get_all:&quot;</span>, e)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, sql</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__edit(sql)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, sql</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__edit(sql)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, sql</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__edit(sql)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__edit</span>(<span class="params">self, sql</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            count = self.cursor.execute(sql)</span><br><span class="line">            self.db.commit()</span><br><span class="line">        <span class="keyword">except</span> BaseException:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;事务提交失败。&#x27;</span>)</span><br><span class="line">            self.db.rollback()</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.db.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p> def <strong>del</strong>(self):<br>            self.cursor.close()<br>            self.db.close()</p><pre><code>```</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PyMySQL&quot;&gt;&lt;a href=&quot;#PyMySQL&quot; class=&quot;headerlink&quot; title=&quot;PyMySQL&quot;&gt;&lt;/a&gt;PyMySQL&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;pymysql简介&quot;&gt;&lt;a href=&quot;#pymysql简介&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>视图</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/7.%E8%A7%86%E5%9B%BE/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/7.%E8%A7%86%E5%9B%BE/</id>
    <published>2023-04-28T10:40:04.923Z</published>
    <updated>2023-04-28T10:44:49.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ol><li><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p> 视图是一张虚拟的表，不占用物理内存。</p><p> 视图不存放数据，数据只存在基表中，但是他们发生变化都会互相影响。</p><p> 视图会给我们带来更多方便。</p></li><li><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>简单、方便，可以在查看数据的时候变得更清楚。</li><li>安全性：保护数据库中的重要数据，不让他展现在页面中</li><li>逻辑数据独立性：不占用物理空间，当去修改原表结构时，不会对视图造成影响（指添加字段）。</li></ol></li><li><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p> 性能差：查询效率偏低，每次查询时都要转换</p><p> 修改限制：对于复杂视图来说（多表查询）修改是非常麻烦的。</p></li><li><h4 id="视图的使用"><a href="#视图的使用" class="headerlink" title="视图的使用"></a>视图的使用</h4><p> 创建视图：create view 视图名 as select 语句;</p><p> 查询视图：</p><p> ​show create view 视图名;</p><p> 查看某个表有多少视图：</p><p> ​show table status where comment&#x3D;”view”;</p><p> 删除视图：</p><p> ​drop view 视图名;</p><p> 在视图中对数据的增、删、改、查与在原表中都一样</p><p> 查询视图的内容：</p><p> ​select * from 视图;lect * from 视图;</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视图&quot;&gt;&lt;a href=&quot;#视图&quot; class=&quot;headerlink&quot; title=&quot;视图&quot;&gt;&lt;/a&gt;视图&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;概</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/6.%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/6.%E7%B4%A2%E5%BC%95/</id>
    <published>2023-04-28T10:40:04.921Z</published>
    <updated>2023-04-28T10:44:49.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h4 id="一、索引介绍"><a href="#一、索引介绍" class="headerlink" title="一、索引介绍"></a>一、索引介绍</h4><p>  1、索引是为了提升查询速度，会降低添加数据、更新数据、删除数据的速度。<br>  2、经常用于where查询条件的字段添加索引  如：id。<br>  3、字段重复数据较大的数据不适合添加索引，如：性别，保证数据的唯一性，唯一性越高查询速度越快。<br>  4、数量较少的表，不适合添加索引。<br>    索引介绍<br>        用处：  几乎所有的索引都是添加到字段中的<br>        作用：  使用索引，是为了加快查询速度，提高查询效率，约束数据的有效性<br>        原理：  系统根据某种算法或者未来添加的数据，单独建立一个文件，实现快速匹配查找<br>    索引的优点<br>        通过唯一索引可以创建出每一行数据的唯一性<br>        可大大提高数据库的检索速度，这是最主要的原因<br>        加强表与表之间的联系，实现多表查询<br>        在分组和排序中，同样可以少耗费很多时间<br>        可以提高表的性能</p><p>   索引的缺点<br>        运行速度：  添加索引会延缓插入数据和修改数据的速度<br>        耗费空间：  索引本身产生的文件就有可能比数据的文件还要大<br>        消耗时间：  创建索引和维护索引要耗费时间，这种时间是根据数据量的增加而增加</p><p>​索引的分类<br>​1.主键索引<br>​作用：  确定数据表中一条特定数据记录的位置<br>​关键字：  primary  key<br>​创建：  一般创建在建表时候  id  int  not  null  auto_increment  primary  key<br>​注意：  主键不能为空，一个表中只能有一个主键索引<br>​2.外键索引<br>​概念：  外面的键，不是在自己的表中，如果一张表中的一个字段（非主键）指向另一张表中的主键，那么可以称该字段为外键<br>​作用：  用来在多表查询的时候方便联系两表数据<br>​关键字：  foreign  key<br>​使用：  foreign  key（外键名）  references  主表（主键）<br>​约束<br>​对子表：  在对子表进行增和改的时候，如果外键对应在父表中找不到，那么就会失败<br>​对父表：  在对父表进行删和改的时候，如果在主表中已有数据被引用，那么也将失败<br>​外键的形成条件<br>​要求表类型必须是innodb<br>​如果不是innodb，那么即使创表成功，也没有了约束的效果<br>​外键的数据类型必须与主键的数据类型一致<br>​在一张表中外键名不能重复<br>​如果数据存在，那么必须保证外键中的数据和附表中的主键数据一致<br>​3.唯一索引<br>​作用：  唯一索引是为了避免出现重复的值，他的存在不是为了提高访问速度，而是避免出现重复数据<br>​关键字：  unique<br>​使用：  一般在创建列的时候使用   name  char（30）  not  null  default  ‘DB’  unique<br>​注意：  只有确认某一列不能出现重复的值得时候才能使用<br>​4.普通索引<br>​概念：  普通索引依附在某一列上，提高查询速度<br>​关键字：  index<br>​使用：  create  index  索引名  on  表名（列名）<br>​索引的操作<br>​查看索引：  show  index   from  表名<br>​删除索引：  drop  index  索引名  on  表名</p><h3 id="二、索引的创建"><a href="#二、索引的创建" class="headerlink" title="二、索引的创建"></a>二、索引的创建</h3><ol><li><h4 id="使用alter-table-语句创建索引"><a href="#使用alter-table-语句创建索引" class="headerlink" title="使用alter table 语句创建索引"></a>使用alter table 语句创建索引</h4><p> 普通索引：</p><h5 id="alter-table-table-name-add-index-index-name-字段"><a href="#alter-table-table-name-add-index-index-name-字段" class="headerlink" title="alter table table_name add index index_name(字段);"></a>alter table table_name add index index_name(字段);</h5><p> 唯一索引：</p><h5 id="alter-table-table-name-add-unique-字段"><a href="#alter-table-table-name-add-unique-字段" class="headerlink" title="alter table table_name add unique(字段);"></a><strong>alter table table_name add unique(字段);</strong></h5><p> 主键索引：</p><p> <strong>alter table table_name add primary key(字段);</strong></p></li><li><h4 id="使用create-index-语句对表增加索引"><a href="#使用create-index-语句对表增加索引" class="headerlink" title="使用create index 语句对表增加索引"></a>使用create index 语句对表增加索引</h4><p> <strong>create index index_name on table_name(username(length));</strong></p><p> 如果是char或varchar类型，length可以小于字段实际长度；如果是text类型，必定要指定length</p><p> create 只能创建两种索引：普通索引和唯一索引</p><p> create index index_name on table_name(字段);</p><p> create unique index index_name on table_name(字段);</p></li></ol><h3 id="三、删除索引"><a href="#三、删除索引" class="headerlink" title="三、删除索引"></a>三、删除索引</h3><p>​删除索引可以使用alter table 或drop index 语句来实现，drop index 可以在alter table 内部作为一条语句来处理</p><p>​格式：drop index index_name on table_name;</p><p>​alter table table_name drop index index_name;</p><p>​alter table table_name drop primary key;</p><p>​一个表只有一个primary key索引，如果没有primary  key，有多个unique索引时，则MySQL将删除掉第一个unique索引。</p><p>��unique索引时，则MySQL将删除掉第一个unique索引。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;h4 id=&quot;一、索引介绍&quot;&gt;&lt;a href=&quot;#一、索引介绍&quot; class=&quot;headerlink&quot; title=&quot;一、索引介绍&quot;&gt;&lt;/a&gt;一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>权限管理</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/5.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/5.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</id>
    <published>2023-04-28T10:40:04.916Z</published>
    <updated>2023-04-28T10:44:49.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p><strong>用户</strong>：使用者</p><p><strong>权限</strong>：用户的操作范围</p><p><strong>组</strong>：权限集合</p><p>一个组里面有查询权限、删除权限等</p><h4 id="1、修改密码"><a href="#1、修改密码" class="headerlink" title="1、修改密码"></a>1、修改密码</h4><p>​首先进入数据库：<code>use mysql;</code></p><p>​修改密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update user set  authentication_string=password(&#x27;root&#x27;) where host=&#x27;localhost&#x27; and user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure><p>​忘记密码时，在配置文件中加：skip-grant-tables，即可跳过密码验证，登陆之后修改密码重启mysql服务。</p><p>​修改完密码之后退出数据库环境，然后重启数据库服务即可更新密码。在5.n数据库版本的密码加密函数为password。8.0版本数据库加密方式有所改变。</p><h4 id="2、创建用户"><a href="#2、创建用户" class="headerlink" title="2、创建用户"></a>2、创建用户</h4><p>​格式：create user ‘用户名‘@’来源地’ identified by ‘密码’;</p><h5 id="1、创建只有本地能登录的用户"><a href="#1、创建只有本地能登录的用户" class="headerlink" title="1、创建只有本地能登录的用户"></a>1、创建只有本地能登录的用户</h5><p>​create user ‘zhangsan‘@’localhost’ identified by ‘123456’;</p><h5 id="2、创建只能指定ip登录的用户"><a href="#2、创建只能指定ip登录的用户" class="headerlink" title="2、创建只能指定ip登录的用户"></a>2、创建只能指定ip登录的用户</h5><p>​create user ‘lisi‘@’10.10.11.12’ identified by ‘123456’;</p><h5 id="3、给用户授权允许远程连接"><a href="#3、给用户授权允许远程连接" class="headerlink" title="3、给用户授权允许远程连接"></a>3、给用户授权允许远程连接</h5><p>格式：grant 权限 on 库名.表名 to 用户名@’地址’;</p><p>权限分类：</p><p>select,insert,update,delete,create</p><p>示例：给wangwu用户添加查询权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select on test.major to wangwu@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p>创建不限ip访问的xiaoliu用户，添加所有权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;xiaoliu&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27; grant all on *.* to xiaoliu@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><h5 id="4、删除用户"><a href="#4、删除用户" class="headerlink" title="4、删除用户"></a>4、删除用户</h5><p>​drop user “用户名”@”来源地”;</p><p>er “用户名”@”来源地”;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;权限管理&quot;&gt;&lt;a href=&quot;#权限管理&quot; class=&quot;headerlink&quot; title=&quot;权限管理&quot;&gt;&lt;/a&gt;权限管理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;用户&lt;/strong&gt;：使用者&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;权限&lt;/strong&gt;：用户的操作范围&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关联查询</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/3.%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/3.%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/</id>
    <published>2023-04-28T10:40:04.915Z</published>
    <updated>2023-04-28T10:44:49.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><h4 id="一、外键："><a href="#一、外键：" class="headerlink" title="一、外键："></a>一、外键：</h4><p>外键主要用来描述表和表的一对多关系</p><p>全称：外键约束，添加完外键会给字段默认添加普通索引</p><p>作用：保证数据的完整性和准确性。</p><p>逻辑外键：逻辑上存在的关系，并没有真实的关系，在插入和删除数据时没有影响。</p><p>物理外键：在建表时设置约束关系，在插入和删除数据时会相互影响。</p><h4 id="二、建表语句："><a href="#二、建表语句：" class="headerlink" title="二、建表语句："></a>二、建表语句：</h4><ol><li>create table class(id int auto_increment primary key,name varchar(22) not null default ‘’,stuNum int not null);</li><li>create table students(id int auto_increment primary key,name varchar(22) not null default ‘’,gender bit default 1,pid int not null,foreign key(pid) references class(id));</li></ol><p>示例：select students.name,class.name,class.id from class inner join students on class.id&#x3D;student.pid;</p><p>分类：</p><h5 id="1、表A-inner-join-表B：内连接交集查询"><a href="#1、表A-inner-join-表B：内连接交集查询" class="headerlink" title="1、表A inner join 表B：内连接交集查询"></a>1、表A inner join 表B：内连接交集查询</h5><p>​表A与表B匹配的行会出现在结果集中</p><p>​select * from 表1inner join 表2  on表1.外键字段&#x3D;表2.</p><p>主键字段;</p><h5 id="2、表Aleftjoin表B，左连接"><a href="#2、表Aleftjoin表B，左连接" class="headerlink" title="2、表Aleftjoin表B，左连接"></a>2、表Aleftjoin表B，左连接</h5><p>​表A与表B匹配的行会出现在结果集中，外加表A独有的数据，未对应的数据使用null填充</p><h5 id="3、表Arightjoin表B："><a href="#3、表Arightjoin表B：" class="headerlink" title="3、表Arightjoin表B："></a>3、表Arightjoin表B：</h5><p>​表A与表B匹配的行会出现在结果集中，外加表B独有的数据，未对应的数据使用null填充</p><p>填充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关联查询&quot;&gt;&lt;a href=&quot;#关联查询&quot; class=&quot;headerlink&quot; title=&quot;关联查询&quot;&gt;&lt;/a&gt;关联查询&lt;/h2&gt;&lt;h4 id=&quot;一、外键：&quot;&gt;&lt;a href=&quot;#一、外键：&quot; class=&quot;headerlink&quot; title=&quot;一、外键：&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>查询</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/2.%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/2.%E6%9F%A5%E8%AF%A2/</id>
    <published>2023-04-28T10:40:04.915Z</published>
    <updated>2023-04-28T10:44:49.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h2><ol><li><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p> 格式：select * from 表名;</p><p> 说明：select 后跟要查询的内容(字段名)，*代表查询全部，from代表数据来源于哪张表</p><p> 示例：select name,id from student;</p></li><li><h4 id="消除重复行"><a href="#消除重复行" class="headerlink" title="消除重复行"></a>消除重复行</h4><p> 在select跟字段之间使用distinct可以消除重复的行。</p><p> 示例：select distinct name from student;</p></li><li><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p> a、语法：select * from 表名 where 条件;</p><p> b、比较运算符：+，-，*，、，&#x3D;，！&#x3D;，&lt;,&gt;,%</p><p> ​示例：select * from 表名 where id&lt;18；</p><p> c、逻辑运算符</p><p> ​and  并且select * from student where id&gt;7 and gender&#x3D;0;</p><p> ​or 或者select * from student where id&gt;7 or gender&#x3D;0;</p><p> ​ 说明：只要满足任意条件都会匹配出来</p><p> ​not       不是select * from student where id&gt;7 not gender;</p><p> d、模糊查询</p><p> ​示例：select * from student where name llike ‘%a%’;(只要包含a就会匹配出来)</p><p> ​说明：%代表包括空白在内的任意字符，_代表一个字符</p><p> e、范围查询</p><p> ​in  在select * from student where id in (1,3,4);</p><p> ​not in   不在select * from student where id not in (1,3,4);</p><p> ​between  and select * from student where id between 6 and 8;</p><p> f、空判断</p><p> ​insert into student(name,age) values(‘小明’,70);</p><p> ​说明：null 与’’不同</p><p> ​select * from student where address is null;(或者is not)</p><p> g、优先级</p><p> ​小括号,not比较运算符，逻辑运算符</p><p> ​and 比 or 优先级高，如果同时出现并希望先选or，需要结合()使用</p></li><li><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><p> a、count(*)表示计算总行数，括号中可以写**和字段</p><p> b、max(字段) 表示求此列的最大值</p><p> c、min(字段)   表示求此列的最小值</p><p> d、sum(字段)  表示求此列的和</p><p> e、avg(字段)表示求此列的和</p><p> select max(age) from student where gender&#x3D;’0’;</p></li><li><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p> 按照字段分组，表示此字段相同的数据会被放到一个集合中。</p><p> 分组后，只能查询相同的数据列，对于有差异的数据列无法显示在结果集中，可以对分组数据进行统计，做聚合运算。</p><p> 语法：select 列1,列2,聚合…… from 表  group by 列1,列2,……</p><p> 示例：查询男女生总数</p><p> select gender,count(*) from student group by gender;</p><p> 分组后的数据筛选：</p><p> select 列1,列2,聚合……  from 表 group by having 列1，列2，……,聚合…… having 条件</p><p> 示例：select gender,count(*) from student group by gender having gender&#x3D;0;</p><p> <strong>where和having的区别：</strong></p><p> where是对from后面指定的表进行筛选，属于对原始表的筛选</p><p> having是对group by的结果进行筛选</p><p> 示例：select id,name from teachers where name in (select name from teachers group by names having count(name)&gt;1);</p></li><li><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p> 语法：select * from 表名 order by 列1 asc| desc,列2 asc|desc;</p><p> 说明：将数据按照列1进行排序，如果某些列1的值相同，那么按照列2排序</p><p> ​默认按照升序排列，asc降序，desc降序</p></li><li><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p> 语法：select * from 表名 limit x,y;</p><p> 说明：从第x+1行开始，查询y行内容</p></li></ol><p>lect * from 表名 limit x,y;</p><pre><code>说明：从第x+1行开始，查询y行内容</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库查询&quot;&gt;&lt;a href=&quot;#数据库查询&quot; class=&quot;headerlink&quot; title=&quot;数据库查询&quot;&gt;&lt;/a&gt;数据库查询&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库备份</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/4.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/4.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD/</id>
    <published>2023-04-28T10:40:04.915Z</published>
    <updated>2023-04-28T10:44:49.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h2><p> 1、先退出mysql环境</p><h4 id="数据的导出："><a href="#数据的导出：" class="headerlink" title="数据的导出："></a>数据的导出：</h4><p>​备份表：默认导出在当前路径</p><p>​注意：使用mysql可以导表，但是导库时必须使用mysqldump</p><p>​示例：mysqldump -uroot -proot test major&gt;.&#x2F;Desktop&#x2F;major.sql</p><p>​备份库：</p><p>​格式：mysqldump-uroot -p 库名&gt;路径&#x2F;name.sql</p><p>​示例：mysqldump  -uroot  -p 库名&gt;备份文件名.sql</p><h4 id="数据的导入："><a href="#数据的导入：" class="headerlink" title="数据的导入："></a><strong>数据的导入：</strong></h4><p>​mysql  -uroot  -p 库名 &lt; 备份文件地址.sql </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库备份&quot;&gt;&lt;a href=&quot;#数据库备份&quot; class=&quot;headerlink&quot; title=&quot;数据库备份&quot;&gt;&lt;/a&gt;数据库备份&lt;/h2&gt;&lt;p&gt; 1、先退出mysql环境&lt;/p&gt;
&lt;h4 id=&quot;数据的导出：&quot;&gt;&lt;a href=&quot;#数据的导出：&quot; class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库基本操作</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2023-04-28T10:40:04.914Z</published>
    <updated>2023-04-28T10:44:49.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库基本语句"><a href="#数据库基本语句" class="headerlink" title="数据库基本语句"></a>数据库基本语句</h2><h3 id="一、基本命令"><a href="#一、基本命令" class="headerlink" title="一、基本命令"></a>一、基本命令</h3><ol><li><p>启动服务</p><p> 说明：以管理员身份运行cmd    </p><p> 格式：net start  服务名称    </p><p> 示例：net start  mysql</p></li><li><p>停止服务</p><p> 说明：以管理员身份运行cmd</p><p> 格式：net  stop   服务名称</p><p> 示例：net  stop   mysql</p></li><li><p>连接数据</p><p> 格式：mysql  -hlocalhost  -u用户名  -p  -P3306</p><p> 示例：mysql -u root -p</p><p> 输入密码</p></li><li><p>退出登录（断开连接）</p><p> 格式：quit  或  exit;</p></li><li><p>查看版本</p><p> 示例：select version();</p></li><li><p>显示当前时间（连接后可以执行）</p><p> 示例：select now();</p></li><li><p>远程连接</p><p> 格式：mysql -h ip地址 -u 用户名 -p -P3306</p><p> 输入密码</p></li><li><p>常见的字段约束</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unsigned       无符号  一般给数值型的字段添加，如果添加代表当前字段只能存正数</span><br><span class="line">Int(5)         5代表显示的宽度  如果是有符号默认是11 如果是无符号默认10</span><br><span class="line">Not null       不能为空 默认字段可以为空 如果添加了 那么此字段不能为空</span><br><span class="line">Default         默认值</span><br><span class="line">Primary key     主键约束(主键索引) 不能为空 且唯一 用于表示数据的唯一标识</span><br><span class="line">Unique          唯一约束(唯一索引) 可以为空 不能重复 具有唯一性Auto_increment  自动递增  一般配合主键去使用</span><br></pre></td></tr></table></figure></li><li><p>常见的字段类型</p><ol><li><p>整数类型</p><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 byte</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 bytes</td><td>(-32 768，32 767)</td><td>(0，65 535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 bytes</td><td>(-8 388 608，8 388 607)</td><td>(0，16 777 215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 bytes</td><td>(-2 147 483 648，2 147 483 647)</td><td>(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 bytes</td><td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td>(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 bytes</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度 浮点数值</td></tr><tr><td>DOUBLE</td><td>8 bytes</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度 浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>小数值</td></tr></tbody></table></li><li><p>日期和时间类型</p><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性。</p><table><thead><tr><th>类型</th><th>大小 ( bytes)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01&#x2F;9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’&#x2F;‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901&#x2F;2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00&#x2F;2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table></li><li><p>字符串类型</p><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。</p><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p><strong>注意</strong>：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p><p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p></li></ol></li></ol><h3 id="二、库操作（数据库操作必须以英文分号（；）结束）"><a href="#二、库操作（数据库操作必须以英文分号（；）结束）" class="headerlink" title="二、库操作（数据库操作必须以英文分号（；）结束）"></a>二、库操作（数据库操作必须以英文分号（；）结束）</h3><ol><li>查看有哪些数据库：show databases;</li><li>创建数据库：create database 库名;</li><li>进入数据库：use 库名;</li><li>查看当前使用的数据库：select database()</li><li>删除数据库：drop database 库名;</li></ol><h3 id="三、表操作"><a href="#三、表操作" class="headerlink" title="三、表操作"></a>三、表操作</h3><ol><li><p>查看库中所有的表：show tables；</p></li><li><p>创建表：</p><p> 格式：create table 表名（字段及类型）;</p><p> 注意：表名如果是关键字如show需要加反引号&#96;&#96;</p></li><li><p>删除表：drop table 表名;</p></li><li><p>查看表结构：desc 表名;</p></li><li><p>查看建表语句：show create table 表名;</p></li><li><p>重命名表名：</p><p> 1、rename table 表名1 to 表名2;</p><p> 2、alter table 表名1 rename as 表名2;</p></li><li><p>修改表</p><p> alter table 表名 add、drop、change、modify 字段名 类型;</p><p> 添加字段：alter table users add gender int after name;</p><p> ​(可以使用after，不能使用before，first代表插入在第一个)</p><p> 添加外键：alter table users add foreign key(c_id) references class(id);</p><p> 删除字段：alter table user drop gender;</p><p> 修改字段名称：alter table user change gender sex char(1);</p><p> 修改字段类型：alter table user modify sex int(1);</p></li><li><p>修改表的编码格式</p><p> alter table students CHARSET&#x3D;GBK;</p></li><li><p>修改自增值</p><p> 修改自增值为20</p><p> alter table students AUTO_INCREMENT&#x3D;20;</p></li></ol><h3 id="四、数据操作"><a href="#四、数据操作" class="headerlink" title="四、数据操作"></a>四、数据操作</h3><ol><li><p>增：</p><p> a、全列插入：insert into 表名 values();</p><p> b、缺省插入：insert into 表名(字段1,字段2) values (值1，值2);</p><p> c、同时插入多条数据：insert into 表名 values(……),(……),(……);</p><p> d、将一张表查询结果插入另一张表，此时不需要加values：</p><p> insert into shop(name,address) select name,address from sqlorm.shops;</p></li><li><p>删：</p><p> a、删除某条数据</p><p> delete from 表名 where 条件;(不写条件时会删掉所有数据，条件一般用主键)</p></li><li><p>改</p><p> a、修改数据</p><p> update 表名 set name&#x3D;’zhangsan’ where id &#x3D;1;</p><p> UPDATE 表名 SET text&#x3D;REPLACE(text, ‘oldvalue’, ‘newValue’);</p></li><li><p>查</p><p> a、查询表中全部数据：</p><p> select * from 表名</p></li></ol><p>​</p><p>d &#x3D;1;</p><pre><code>UPDATE 表名 SET text=REPLACE(text, &#39;oldvalue&#39;, &#39;newValue&#39;);</code></pre><ol start="4"><li><p>查</p><p> a、查询表中全部数据：</p><p> select * from 表名</p></li></ol><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库基本语句&quot;&gt;&lt;a href=&quot;#数据库基本语句&quot; class=&quot;headerlink&quot; title=&quot;数据库基本语句&quot;&gt;&lt;/a&gt;数据库基本语句&lt;/h2&gt;&lt;h3 id=&quot;一、基本命令&quot;&gt;&lt;a href=&quot;#一、基本命令&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL高阶</title>
    <link href="http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/10.MySQL%E9%AB%98%E9%98%B6/"/>
    <id>http://example.com/2023/04/28/TreasureBox/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/10.MySQL%E9%AB%98%E9%98%B6/</id>
    <published>2023-04-28T10:40:04.914Z</published>
    <updated>2023-04-28T10:44:49.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL高阶—事务、触发器、存储过程"><a href="#MySQL高阶—事务、触发器、存储过程" class="headerlink" title="MySQL高阶—事务、触发器、存储过程"></a>MySQL高阶—事务、触发器、存储过程</h2><h3 id="一、数据库事务"><a href="#一、数据库事务" class="headerlink" title="一、数据库事务"></a>一、数据库事务</h3><h4 id="（1）数据库中的事务有四大特性：ACID"><a href="#（1）数据库中的事务有四大特性：ACID" class="headerlink" title="（1）数据库中的事务有四大特性：ACID"></a>（1）<strong>数据库中的事务有四大特性：ACID</strong></h4><ul><li><strong>原子性</strong>：每个事务都是不可分割的执行，要么全部成功，要么全部失败。</li><li><strong>一致性</strong>：事务执行之前和执行之后的状态保持一致。比如A有1000元，B有1000元，A给B转账500元之后，A与B的钱数之和应该还是2000元。</li><li><strong>隔离性</strong>：多个事务同时操作，每个事务之间相互独立，互不影响。</li><li><strong>持久性</strong>：事务提交成功后对数据库的改变是永久的。</li></ul><h4 id="（2）数据库三范式"><a href="#（2）数据库三范式" class="headerlink" title="（2）数据库三范式"></a>（2）<strong>数据库三范式</strong></h4><p>​数据库的范式(规范的数据表示公式)：按照什么方式在数据库中表示（存储）是完全合理是做不到的，只能在数据库设计过程中尽量靠近三范式约束。</p><ul><li><p><strong>1NF</strong>：字段不可分割</p><p>  数据库中的每一列数据，是不能再拆分的。</p></li><li><p><strong>2NF</strong>：有主键，非主键字段依赖主键。</p><p>  数据库中的每一条数据都是唯一的，主键作为数据唯一的描述符。</p></li><li><p><strong>3NF</strong>：非关键字的任何字段属性，不能产生相互的依赖条件</p><p>  不是主键的任何其他字段，不能产生相互的依赖关系。</p></li></ul><h4 id="（3）事务的隔离级别"><a href="#（3）事务的隔离级别" class="headerlink" title="（3）事务的隔离级别"></a>（3）事务的隔离级别</h4><p>​事务的隔离级别，指多个事务同时操作数据库时，不同事务之间应该怎么定义他们的操作。</p><ul><li><p><strong>读未提交：read uncommitted</strong></p><p>  一个事务中，读取了另一个事务中没有提交的数据，两个事务之间造成了影响。</p></li><li><p><strong>读已提交：read committed</strong></p><p>  一个事务中，读取了另一个事务中提交的数据。</p></li><li><p><strong>可重复读：repeat read</strong></p><p>  在一次完整的事务中，每次读取的数据都是一致的，不会发生变化，所有提交的更新的数据都会在下一个事务中读取到。数据库默认的隔离级别</p></li><li><p><strong>串行化&#x2F;序列化：serializerable</strong></p><p>  所有的事务操作全部排队，依次执行</p></li></ul><h3 id="二、触发器"><a href="#二、触发器" class="headerlink" title="二、触发器"></a>二、触发器</h3><p>数据库中提供了特殊的处理方法：自动化操作，本质上是当数据库中发生了一些行为之后，导致一些其他的行为自动触发，类似python开发中的事件驱动开发。</p><p>数据库中提供了一种数据库高级对象：触发器；描述的是数据表上一个条件被触发执行的后续行为操作。</p><h4 id="①-触发器语法："><a href="#①-触发器语法：" class="headerlink" title="① 触发器语法："></a>① 触发器语法：</h4><p>create trigger trigger_name trigger_time trigger_event on table_name for each row trigger_stmt end;</p><p>描述：在某张表上，发生了一个触发事件，在触发事件发生之前|之后(触发时机)，执行触发器中定义的要执行的程序。</p><p><strong>trigger_time：触发时机，before|after</strong></p><p><strong>trigger_event：触发事件,insert|update|delete</strong></p><h4 id="②触发器案例：自动下单功能"><a href="#②触发器案例：自动下单功能" class="headerlink" title="②触发器案例：自动下单功能"></a><strong>②触发器案例</strong>：自动下单功能</h4><ul><li><p>创建测试数据表</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods(</span><br><span class="line">  gid <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;商品主键&#x27;</span>,</span><br><span class="line">  gname <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">  gprice <span class="keyword">double</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;商品单价&#x27;</span>,</span><br><span class="line">  gstock <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;商品库存&#x27;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods_order(</span><br><span class="line">goid <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">    goname <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;购买商品名称&#x27;</span>,</span><br><span class="line">    goprice <span class="keyword">double</span> comment <span class="string">&#x27;成交单价&#x27;</span>,</span><br><span class="line">    gocount <span class="type">int</span> comment <span class="string">&#x27;购买数量&#x27;</span>,</span><br><span class="line">    subtotal <span class="keyword">double</span> comment <span class="string">&#x27;小计金额&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建触发器</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="comment">-- 创建一个触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> goods_sale_auto</span><br><span class="line"><span class="comment">-- 在goods表格修改之后执行触发器</span></span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> goods <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="comment">-- 要执行的程序开始操作</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="comment">-- 声明两个变量</span></span><br><span class="line"><span class="keyword">declare</span> buycount <span class="type">int</span>;</span><br><span class="line"><span class="keyword">declare</span> subtotal <span class="keyword">double</span>;</span><br><span class="line"><span class="comment">-- 判断库存是否更新：更新前old，更新后new</span></span><br><span class="line">if new.gstock<span class="operator">&lt;</span>old.gstock</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"><span class="comment">--获取购买的数量</span></span><br><span class="line"><span class="keyword">set</span> buycount <span class="operator">=</span> old.gstock <span class="operator">-</span> new.gstock;</span><br><span class="line"><span class="keyword">set</span> subtotal <span class="operator">=</span> buycount <span class="operator">*</span> <span class="keyword">old</span>,gprice;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods_order(gname,goprice,gcount,subtotal) <span class="keyword">values</span>(old.gname,<span class="keyword">old</span>,gprice,buycount,subtotal);</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="comment">-- 要执行的程序完结操作</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$$</span><br><span class="line">delimiter;  <span class="comment">--触发器创建完成后，修改结束符为默认的分号</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="三、存储过程"><a href="#三、存储过程" class="headerlink" title="三、存储过程"></a>三、存储过程</h3><p>​触发器是数据库中根据发生的条件(某张表上发生了INSERT&#x2F;UPDATE&#x2F;DELETE操作)自动执行的<strong>数据库程序</strong>，当我们需要自定义程序，并且手工调用时要怎么去做？</p><p>​数据库提供了另外一种高级对象：存储程序，一般称为存储过程，就是一个用户按照规范语法编写的程序代码，可以将项目中的业务逻辑封装在程序中，通过固定的语法方式直接调用执行，类似python中的函数。</p><h4 id="（1）基本语法结构"><a href="#（1）基本语法结构" class="headerlink" title="（1）基本语法结构"></a>（1）基本语法结构</h4><p>​创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc_name ([proc_parameters]) routing_body</span><br></pre></td></tr></table></figure><p>create procedure 固定语法：创建存储过程</p><p>proc_name：自定义存储过程名称</p><p>proc_parameters：存储过程执行需要的参数</p><p>routing_body：存储程序要执行的程序代码</p><h4 id="（2）案例"><a href="#（2）案例" class="headerlink" title="（2）案例"></a>（2）案例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> employee_avg()</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="comment">-- 模拟一行或多行代码</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(salary) <span class="keyword">from</span> ex01.employee</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$$</span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">call</span> employee_avg();</span><br></pre></td></tr></table></figure><h4 id="（3）带有返回值的存储过程"><a href="#（3）带有返回值的存储过程" class="headerlink" title="（3）带有返回值的存储过程"></a>（3）带有返回值的存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> my_employee2(<span class="keyword">out</span> res <span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="comment">-- 查询数据，并将数据保存到变量中</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>(salary) <span class="keyword">into</span> res <span class="keyword">from</span> ex01.employee</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$$</span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">call</span> my_employee2(<span class="variable">@res</span>);</span><br><span class="line"><span class="comment">--查看返回值的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@res</span>;</span><br></pre></td></tr></table></figure><p>返回值声明在存储过程名称后面的括号：</p><p><strong>out：</strong>返回数据</p><p><strong>in：</strong>输入数据</p><p><strong>input：</strong>既是输入数据，同时也能返回数据</p><p>调用时，需要使用变量接受数据，为了跟其他变量区分，添加@符号：call mey_employee(@res);�，同时也能返回数据</p><p>调用时，需要使用变量接受数据，为了跟其他变量区分，添加@符号：call mey_employee(@res);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL高阶—事务、触发器、存储过程&quot;&gt;&lt;a href=&quot;#MySQL高阶—事务、触发器、存储过程&quot; class=&quot;headerlink&quot; title=&quot;MySQL高阶—事务、触发器、存储过程&quot;&gt;&lt;/a&gt;MySQL高阶—事务、触发器、存储过程&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    
  </entry>
  
</feed>

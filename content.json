{"meta":{"title":"devin's blog","subtitle":"vinya","description":"分享技术知识","author":"devin","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-04-22T10:23:38.000Z","updated":"2023-04-21T09:15:34.989Z","comments":true,"path":"index.html","permalink":"http://example.com/index.html","excerpt":"","text":"这里是Devin’s blog"},{"title":"categories","date":"2023-04-22T10:23:38.000Z","updated":"2023-04-21T09:15:35.001Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2023-04-22T10:23:38.000Z","updated":"2023-04-21T09:15:34.996Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-04-22T10:23:38.000Z","updated":"2023-04-21T09:15:34.981Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"index","slug":"TreasureBox/Elasticsearch/学习笔记/index","date":"2023-04-20T02:33:25.636Z","updated":"2023-04-28T09:25:47.268Z","comments":true,"path":"2023/04/20/treasurebox/elasticsearch/xue-xi-bi-ji/index/","link":"","permalink":"http://example.com/2023/04/20/treasurebox/elasticsearch/xue-xi-bi-ji/index/","excerpt":"","text":"title: 学习笔记","categories":[],"tags":[]},{"title":"index","slug":"TreasureBox/Elasticsearch/index","date":"2023-04-20T02:25:18.254Z","updated":"2023-04-28T09:25:47.261Z","comments":true,"path":"2023/04/20/treasurebox/elasticsearch/index/","link":"","permalink":"http://example.com/2023/04/20/treasurebox/elasticsearch/index/","excerpt":"","text":"title: ElasticSearchElasticSearch知识整理 学习笔记","categories":[],"tags":[]},{"title":"python分析模块","slug":"TreasureBox/python/python程序CPU使用率分析/python分析模块","date":"2023-03-24T08:25:41.271Z","updated":"2023-04-28T09:25:47.124Z","comments":true,"path":"2023/03/24/treasurebox/python/python-cheng-xu-cpu-shi-yong-lu-fen-xi/python-fen-xi-mo-kuai/","link":"","permalink":"http://example.com/2023/03/24/treasurebox/python/python-cheng-xu-cpu-shi-yong-lu-fen-xi/python-fen-xi-mo-kuai/","excerpt":"","text":"title: python分析模块sampling profilers VS tracing profilers tracingprofilers记录程序所调用的每个函数，然后在最后打印出报告。 samplingprofilers采用更加统计化的方法 - 他们每隔几毫秒记录程序的堆栈情况，然后报告结果。 使用sampling profilers而不是tracing profilers的主要原因是sampling profilers的开销较低。 如果每秒只抽取20或200个样本，那不会花费多少时间。 而且它们非常有效率 - 如果遇到严重的性能问题（比如80％的时间花费在1个慢速函数上），那么每秒200个样本通常就足以确定那个函数的问题所在了。 cProfile: Python内置的分析工具，c语言编写。 兼容性：python2/python3 文档：https://docs.python.org/zh-cn/3/library/profile.html 使用方式：通过cprofile启动python程序 1python -m cProfile -s cumtime sample.py 优势：python内置分析器； 劣势：并不适合对多线程的长时间运行程序进行分析，默认只会对主线程进行分析，且分析方法是对正在运行的程序进行代码注入，会影响性能； memory_profiler：一个监控进程内存消耗的模块，也可以逐行分析 Python 程序的内存消耗。具体实现依赖 psutil 模块的纯 Python 模块。 兼容性：python2/python3 文档：https://github.com/pythonprofilers/memory_profiler/blob/master/README.rst 实践例子：https://programming.insutanto.net/2020-03/python-memory-profile/python_memory_profiler 使用方式：使用memory_profile启动python程序或在程序中import装饰器，需要改动代码； 优势：可以针对代码级别进行内存消耗的分析； 劣势：对代码具有侵入性； PyFlame: Uber开源的性能分析工具，使用C++实现，利用ptrace系统调用来收集分析信息； 兼容性：python2/python3 文档：https://github.com/uber/pyflame 实践例子：https://meteorix.github.io/2019/05/24/pyflame/ 使用方式： 123456789 # attach to process PID 1024 for duration of 60 seconds and sample every 0.05 seconds$ pyflame -s 60 -r 0.05 -p 1024.... $ pyflame --rate=0.005 -o profile.txt -t python sample.pyExecution time : 1.97 sec # convert profile.txt to a flame graphflamegraph.pl &amp;lt; profile.txt &gt; profile.svg 优势：通过attach的方式来分析进程，对代码无侵入性，采样流程由单独的进程负责，不会影响现有进程运行，支持多线程/进程； 劣势：不支持OSX/Windows平台，而且项目已经不再维护了，使用起来可能会有坑； Py-spy: 使用Rust编写的python性能分析工具，实现逻辑是通过系统调用读取python程序的内存，通过解析PyFrameObject结构来获取堆栈信息。 兼容性：python2/python3 文档：https://github.com/benfred/py-spy 使用方式：使用attach的方式进行，支持record(记录)，top(列出耗时的函数)，dump(导出程序的堆栈信息) 12345678910py-spy record -o profile.svg --pid 12345# ORpy-spy record -o profile.svg -- python myprogram.pypy-spy top --pid 12345# ORpy-spy top -- python myprogram.pypy-spy dump --pid 12345 优势：通过attach的方式来分析进程，对代码无侵入性，采样流程由单独的进程负责，不会影响现有进程运行，支持多线程/进程，支持功能较多，且项目一直在持续维护； 劣势：需要使用sudo权限进行attach或者修改全局的系统设置； 其他： pyroscope：一个golang编写的持续性能分析平台，整合了各种分析工具和前端显示； github: https://github.com/pyroscope-io/pyroscope 中文介绍：https://github.com/pyroscope-io/pyroscope/blob/main/translations/README.ch.md","categories":[],"tags":[]},{"title":"suggester","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/9.suggester","date":"2023-03-22T13:06:21.415Z","updated":"2023-04-28T09:25:47.279Z","comments":true,"path":"2023/03/22/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/9.suggester/","link":"","permalink":"http://example.com/2023/03/22/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/9.suggester/","excerpt":"","text":"搜索建议Suggester 概述 搜索一般都会要求具有“搜索推荐”或者叫“搜索补全”的功能，即在用户输入搜索的过程中，进行自动补全或者纠错。以此来提高搜索文档的匹配精准度，进而提升用户的搜索体验，这就是Suggest。 四种Suggester term suggester：term suggester正如其名，只基于tokenizer之后的单个term去匹配建议词，并不会考虑多个term之间的关系 123456789101112POST &lt;index&gt;/_search{ \"suggest\": { \"&lt;suggest_name&gt;\": { \"text\": \"&lt;search_content&gt;\", \"term\": { \"suggest_mode\": \"&lt;suggest_mode&gt;\", \"field\": \"&lt;field_name&gt;\" } } }} Options： text：用户搜索的文本 field：要从哪个字段选取推荐数据 analyzer：使用哪种分词器 size：每个建议返回的最大结果数 sort：如何按照提示词项排序，参数值只可以是以下两个枚举： score：分数&gt;词频&gt;词项本身 frequency：词频&gt;分数&gt;词项本身 suggest_mode：搜索推荐的推荐模式，参数值亦是枚举： missing：默认值，仅为不在索引中的词项生成建议词 popular：仅返回与搜索词文档词频或文档词频更高的建议词 always：根据 建议文本中的词项 推荐 任何匹配的建议词 max_edits：可以具有最大偏移距离候选建议以便被认为是建议。只能是1到2之间的值。任何其他值都将导致引发错误的请求错误。默认为2 prefix_length：前缀匹配的时候，必须满足的最少字符 min_word_length：最少包含的单词数量 min_doc_freq：最少的文档频率 max_term_freq：最大的词频 phrase suggester phrase suggester和term suggester相比，对建议的文本会参考上下文，也就是一个句子的其他token，不只是单纯的token距离匹配，它可以基于共生和频率选出更好的建议。 注意：purase需要先创建Mapping Options： real_word_error_likelihood： 此选项的默认值为 0.95。此选项告诉 Elasticsearch 索引中 5% 的术语拼写错误。这意味着随着这个参数的值越来越低，Elasticsearch 会将越来越多存在于索引中的术语视为拼写错误，即使它们是正确的 max_errors：为了形成更正，最多被认为是拼写错误的术语的最大百分比。默认值为 1 confidence：默认值为 1.0，最大值也是。该值充当与建议分数相关的阈值。只有得分超过此值的建议才会显示。例如，置信度为 1.0 只会返回得分高于输入短语的建议 collate：告诉 Elasticsearch 根据指定的查询检查每个建议，以修剪索引中不存在匹配文档的建议。在这种情况下，它是一个匹配查询。由于此查询是模板查询，因此搜索查询是当前建议，位于查询中的参数下。可以在查询下的“params”对象中添加更多字段。同样，当参数“prune”设置为true时，我们将在响应中增加一个字段“collate_match”，指示建议结果中是否存在所有更正关键字的匹配 direct_generator：phrase suggester使用候选生成器生成给定文本中每个项可能的项的列表。单个候选生成器类似于为文本中的每个单独的调用term suggester。生成器的输出随后与建议候选项中的候选项结合打分。目前只支持一种候选生成器，即direct_generator。建议API接受密钥直接生成器下的生成器列表；列表中的每个生成器都按原始文本中的每个项调用。 completion suggester 自动补全，自动完成，支持三种查询【前缀查询（prefix）模糊查询（fuzzy）正则表达式查询（regex)】 ，主要针对的应用场景就是”Auto Completion”。 此场景下用户每输入一个字符的时候，就需要即时发送一次查询请求到后端查找匹配项，在用户输入速度较高的情况下对后端响应速度要求比较苛刻。因此实现上它和前面两个Suggester采用了不同的数据结构，索引并非通过倒排来完成，而是将analyze过的数据编码成FST和索引一起存放。对于一个open状态的索引，FST会被ES整个装载到内存里的，进行前缀查找速度极快。但是FST只能用于前缀查找，这也是Completion Suggester的局限所在。 completion：es的一种特有类型，专门为suggest提供，基于内存，性能很高。 prefix query：基于前缀查询的搜索提示，是最常用的一种搜索推荐查询。 prefix：客户端搜索词 field：建议词字段 size：需要返回的建议词数量（默认5） skip_duplicates：是否过滤掉重复建议，默认false fuzzy query fuzziness：允许的偏移量，默认auto transpositions：如果设置为true，则换位计为一次更改而不是两次更改，默认为true。 min_length：返回模糊建议之前的最小输入长度，默认 3 prefix_length：输入的最小长度（不检查模糊替代项）默认为 1 unicode_aware：如果为true，则所有度量（如模糊编辑距离，换位和长度）均以Unicode代码点而不是以字节为单位。这比原始字节略慢，因此默认情况下将其设置为false。 regex query：可以用正则表示前缀，不建议使用 context suggester 完成建议者会考虑索引中的所有文档，但是通常来说，我们在进行智能推荐的时候最好通过某些条件过滤，并且有可能会针对某些特性提升权重。 contexts：上下文对象，可以定义多个 name：context的名字，用于区分同一个索引中不同的context对象。需要在查询的时候指定当前name type：context对象的类型，目前支持两种：category和geo，分别用于对suggest item分类和指定地理位置。 boost：权重值，用于提升排名 path：如果没有path，相当于在PUT数据的时候需要指定context.name字段，如果在Mapping中指定了path，在PUT数据的时候就不需要了，因为 Mapping是一次性的，而PUT数据是频繁操作，这样就简化了代码。这段解释有木有很牛逼，网上搜到的都是官方文档的翻译，觉悟雷同。","categories":[],"tags":[]},{"title":"分析python程序CPU使用率案例","slug":"TreasureBox/python/python程序CPU使用率分析/分析python程序CPU使用率案例","date":"2023-03-22T09:26:02.499Z","updated":"2023-04-28T09:25:47.122Z","comments":true,"path":"2023/03/22/treasurebox/python/python-cheng-xu-cpu-shi-yong-lu-fen-xi/fen-xi-python-cheng-xu-cpu-shi-yong-lu-an-li/","link":"","permalink":"http://example.com/2023/03/22/treasurebox/python/python-cheng-xu-cpu-shi-yong-lu-fen-xi/fen-xi-python-cheng-xu-cpu-shi-yong-lu-an-li/","excerpt":"","text":"分析python程序CPU使用率案例 用到工具 cProfile line_profiler pprofile vprof 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041import timedef primes(n): if n == 2: return [2] elif n &lt; 2: return [] s = [] for i in range(3, n + 1): if i % 2 != 0: s.append(i) mront = n ** 0.5 half = (n + 1) / 2 - 1 i = 0 m = 3 while m &lt;= mront: if s[i]: j = (m * m - 3) / 2 s[j] = 0 while j &lt; half: s[j] = 0 j += m i = i + 1 m = 2 * i + 3 l = [2] for x in s: if x: l.append(x) return ldef bechmark(): start = time.time() count = 0 for _ in xrange(40): count = len(primes(1000000)) end = time.time() print \"BechMark duration %r seconds, count:%r\" %(end- start, count)if __name__ == '__main__': bechmark() cProfile 安装：python自带 使用：python -m cProfile demo.py 运行结果分析 结果参数说明： ncalls：执行次数 tottime：执行耗时 percall：平均每次执行耗时 cumtime：在此函数以及子函数执行期间的耗时 percall：cumtime/ncalls filename:lineno：文件名和函数名 运行结果示例 1234567891011121314BechMark duration 19.009029865264893 seconds, count:78498 23139965 function calls in 19.010 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 40 14.327 0.358 18.846 0.471 demo.py:10(primes) 1 0.163 0.163 19.009 19.009 demo.py:39(bechmark) 1 0.001 0.001 19.010 19.010 demo.py:7(&lt;module&gt;) 40 0.000 0.000 0.000 0.000 {len} 23139840 1.418 0.000 1.418 0.000 {method 'append' of 'list' objects} 1 0.000 0.000 0.000 0.000 {method 'disable' of '_lsprof.Profiler' objects} 40 3.101 0.078 3.101 0.078 {range} 2 0.000 0.000 0.000 0.000 {time.time} 将运行结果可视化展示： 需要安装graphviz，mac安装： 12345678# 更新brewbrew update # 安装依赖brew install harfbuzz # 安装graphvizbrew install graphviz# 安装gprof2dotpip install gprof2dot 使用： 1234# 将执行结果导出到文件python -m cProfile -o output.pstats demo.py# 根据根据文件生成图片gprof2dot -f pstats output.pstats | dot -Tpng -o output.png 分析结果 ​ 其他示例： 123import cProfileimport recProfile.run('re.compile(\"foo|bar\")', 'restats') 调用参数说明 -o：将执行结果写入到文件中，而不是显示在控制台 -s：指定排序值方式以对输出进行排序。 python -m cProfile [-o output_file] [-s sort_order] myscript.py","categories":[],"tags":[]},{"title":"前缀-正则-模糊查询","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/8.前缀-正则-模糊查询","date":"2023-03-20T15:10:41.758Z","updated":"2023-04-28T09:25:47.270Z","comments":true,"path":"2023/03/20/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/8.qian-zhui-zheng-ze-mo-hu-cha-xun/","link":"","permalink":"http://example.com/2023/03/20/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/8.qian-zhui-zheng-ze-mo-hu-cha-xun/","excerpt":"","text":"其他查询 前缀搜索prefix 概念以xx开头，不计算相关度评分 原理 前缀匹配的是term，而不是field 前缀搜索的性能很差 前缀搜索没有缓存 前缀搜索时尽可能把前缀长度设置的更长 语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 创建索引PUT test{ \"mappings\": { \"_doc\": { \"_all\": { \"enabled\": false }, \"properties\": { \"text\": { \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"fields\": { \"keyword\": { \"type\": \"keyword\", \"ignore_above\": 256 } }, \"index_prefixes\": { \"min_chars\": 2, \"max_chars\": 3 } } } } }}# 先写入数据POST _bulk{\"index\":{\"_index\":\"test\",\"_type\":\"_doc\",\"_id\":\"1\"}}{\"text\":\"城管打电话喊商贩去摆地摊\"}{\"index\":{\"_index\":\"test\",\"_type\":\"_doc\",\"_id\":\"2\"}}{\"text\":\"笑果文化回应商贩老农去摆地摊\"}{\"index\":{\"_index\":\"test\",\"_type\":\"_doc\",\"_id\":\"3\"}}{\"text\":\"老农耗时17年种出椅子树\"}{\"index\":{\"_index\":\"test\",\"_type\":\"_doc\",\"_id\":\"4\"}}{\"text\":\"夫妻结婚30多年AA制，被城管抓\"}{\"index\":{\"_index\":\"test\",\"_type\":\"_doc\",\"_id\":\"5\"}}{\"text\":\"黑人见义勇为组织抢劫反被铐住\"}GET test/_search{ \"query\": { \"prefix\": { \"text\": { \"value\": \"城管\" } } }} 支持的参数： min_chars：建立前缀索引时开始字符的最小长度，比如设置为2，表示从2个字符开始 max_chars：建立前缀索引时开始字符的最大长度，比如设置为5，表示最大5个字符 通配符 概念 通配符运算符是匹配一个或多个字符的占位符。例如，*通配符运算符匹配零个或多个字符。您可以将通配符运算符与其他字符结合使用以创建通配符模式。 用法 使用通配符查询，关键词：wildcard 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364PUT product_en{ \"mappings\": { \"_doc\": { \"_all\": { \"enabled\": false }, \"properties\": { \"desc\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\", \"ignore_above\": 256 } } }, \"title\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\", \"ignore_above\": 256 } } }, \"tags\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\", \"ignore_above\": 256 } } } } } }}POST /product_en/_bulk{ \"index\": { \"_id\": \"1\"} }{ \"title\": \"my english\",\"desc\" : \"shouji zhong de zhandouji\",\"price\" : 3999, \"tags\": [ \"xingjiabi\", \"fashao\", \"buka\", \"1\"]}{ \"index\": { \"_id\": \"2\"} }{ \"title\": \"xiaomi nfc phone\",\"desc\" : \"zhichi quangongneng nfc,shouji zhong de jianjiji\",\"price\" : 4999, \"tags\": [ \"xingjiabi\", \"fashao\", \"gongjiaoka\" , \"asd2fgas\"]}{ \"index\": { \"_id\": \"3\"} }{ \"title\": \"nfc phone\",\"desc\" : \"shouji zhong de hongzhaji\",\"price\" : 2999, \"tags\": [ \"xingjiabi\", \"fashao\", \"menjinka\" , \"as345\"]}{ \"title\": { \"_id\": \"4\"} }{ \"text\": \"xiaomi erji\",\"desc\" : \"erji zhong de huangmenji\",\"price\" : 999, \"tags\": [ \"low\", \"bufangshui\", \"yinzhicha\", \"4dsg\" ]}{ \"index\": { \"_id\": \"5\"} }{ \"title\": \"hongmi erji\",\"desc\" : \"erji zhong de kendeji\",\"price\" : 399, \"tags\": [ \"lowbee\", \"xuhangduan\", \"zhiliangx\" , \"sdg5\"]}GET product_en/_search{ \"query\": { \"wildcard\": { \"title\": { \"value\": \"eng*ish\" } } }} 正则表达式 关键词：regex 示例：1234567891011GET product_en/_search{ \"query\": { \"regexp\": { \"desc.keyword\": { \"value\": \"zh~o\", \"flags\": \"COMPLEMENT\" } } }} flags参数说明： ALL 启用所有可选操作符。 COMPLEMENT 启用操作符。可以使用对下面最短的模式进行否定。例如 a~bc # matches ‘adc’ and ‘aec’ but not ‘abc’ INTERVAL 启用&lt;&gt;操作符。可以使用&lt;&gt;匹配数值范围。例如 foo&lt;1-100&gt; # matches ‘foo1’, ‘foo2’ … ‘foo99’, ‘foo100’ foo&lt;01-100&gt; # matches ‘foo01’, ‘foo02’ … ‘foo99’, ‘foo100’ INTERSECTION 启用&amp;操作符，它充当AND操作符。如果左边和右边的模式都匹配，则匹配成功。例如: aaa.+&amp;.+bbb # matches ‘aaabbb’ ANYSTRING 启用@操作符。您可以使用@来匹配任何整个字符串。您可以将@操作符与&amp;和~操作符组合起来，创建一个“everything except”逻辑。例如: @&amp;~(abc.+) # matches everything except terms beginning with ‘abc’ 模糊查询 -fuzzy 混淆字符 (box → fox) 缺少字符 (black → lack) 多出字符 (sic → sick) 颠倒次序 (act → cat) 示例12345678910111213141516171819202122232425GET &lt;index&gt;/_search{ \"query\": { \"fuzzy\": { \"&lt;field&gt;\": { \"value\": \"&lt;keyword&gt;\" } } }}# 模糊匹配GET product_en/_search{ \"query\": { \"fuzzy\": { \"desc\": { \"value\": \"zhon\" } } }} 参数说明 value：必须，搜索的字段 fuzziness：编辑距离：(0,1,2)并非越大越好，召回率高但结果不准确，例如zho到zhong的编辑距离为2 最小编辑距离：一个单词经过（插入、删除、修改、调换）转换为另一个单词时需要的次数 transpositions：表示编辑距离修改时是否包含反转。默认为true，包含反转，false时不包含反转。如设置为false，fuzziness设置为1时，hzong不能匹配到zhong。因为hzong转换为zhong在不反转时需要两次操作。 在match中使用fuzziness 1234567891011GET product_en/_search{ \"query\": { \"match\": { \"desc\": { \"query\": \"quangengneng\", \"fuzziness\": 1 } } }} 智能推荐 match_phrase_prefix match_phrase match_phrase_prefix会分词 被检索字段必须包含match_phrase中的所有词频并且顺序必须是相同的 被检索字段包含的match_phrase中的词项之间不能有其他词项 概念：​ match_phrase_prefix与match_phrase相同，但是它多了一个特性,就是它允许在文本的最后一个词项(term)上的前缀匹配,如果是一个单词，比如a，它会匹配文档字段所有以a开头的文档，如果是一个短语，比如 “this is ma” ，他会先在倒排索引中做以ma做前缀搜索，然后在匹配到的doc中做match_phrase查询，(网上有的说是先match_phrase，然后再进行前缀搜索,，是不对的)。 参数 analyzer：指定何种分析器来对该短语进行分词处理 max_expansions：在分片级别限制匹配的最大词项，如果多个分片还是会返回多个结果 boost：用于设置该查询的权重 slop：允许短语间的词项(term)间隔：slop 参数告诉 match_phrase 查询词条相隔多远时仍然能将文档视为匹配。 相隔多远： 意思是说为了让查询和文档匹配你需要移动词条多少次。 例如：slop为1时，使用shouji de 可以匹配到shouji zhong de 用法12345678910111213141516171819202122232425GET product_en/_search{ \"query\": { \"match_phrase_prefix\": { \"desc\": { \"query\": \"shouji zhong de\", \"max_expansions\": 1 } } }}# 添加上slop参数GET product_en/_search{ \"query\": { \"match_phrase_prefix\": { \"desc\": { \"query\": \"shouji de\", \"max_expansions\": 1, \"slop\":1 } } }} N-gram和edge ngram tokenizer12345GET _analyze{ \"tokenizer\": \"ngram\", \"text\": \"reba always loves me\"} token filter123456GET _analyze{ \"tokenizer\": \"ik_max_word\", \"filter\": [ \"ngram\" ], \"text\": \"reba always loves me\"} min_gram：创建索引所拆分字符的最小阈值 max_gram：创建索引所拆分字符的最大阈值 ngram：从每一个字符开始,按照步长,进行分词,适合前缀中缀检索edge_ngram：从第一个字符开始,按照步长,进行分词,适合前缀匹配场景","categories":[],"tags":[]},{"title":"索引的批量操作","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/7.索引的批量操作","date":"2023-03-20T14:44:25.414Z","updated":"2023-04-28T09:25:47.274Z","comments":true,"path":"2023/03/20/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/7.suo-yin-de-pi-liang-cao-zuo/","link":"","permalink":"http://example.com/2023/03/20/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/7.suo-yin-de-pi-liang-cao-zuo/","excerpt":"","text":"索引的批量操作 基于_mget的批量操作 说明Multi get API 基于索引、类型、（可选）和 id（可能还有路由）返回多个文档。响应包括一个docs数组，其中包含所有获取的文档，顺序与原始多获取请求相对应（如果特定获取失败，则包含此错误的对象将包含在响应中）。获取的数据结构类似于查询时返回的数据结构。 查询结构体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 基于mget的批量查询GET /_mget{ \"docs\": [ { \"_index\": \"product\", \"_type\": \"_doc\", \"_id\": 3 }, { \"_index\": \"product\", \"_type\": \"_doc\", \"_id\": 1 } ]}# 查询单个索引时，将索引提前GET product/_mget{ \"docs\": [ { \"_id\": 1 }, { \"_id\": 3 } ]}# 查询单个索引时，可以将索引提前GET product/_mget{ \"docs\": [ { \"_id\": 1 }, { \"_id\": 3 } ]}GET product/_mget{ \"docs\": [ { \"_id\": 1, \"_source\":[ \"name\", \"price\" ] }, { \"_id\": 3, \"_source\":{ \"include\":[ \"name\", \"price\" ], \"exclude\":[ \"name\", \"tags\" ] } } ]} 返回的结果123456789101112131415161718192021222324252627282930{ \"docs\" : [ { \"_index\" : \"product\", \"_type\" : \"_doc\", \"_id\" : \"1\", \"_version\" : 4, \"_seq_no\" : 13, \"_primary_term\" : 1, \"found\" : true, \"_source\" : { \"price\" : 1899, \"name\" : \"小米手机10\" } }, { \"_index\" : \"product\", \"_type\" : \"_doc\", \"_id\" : \"3\", \"_version\" : 1, \"_seq_no\" : 0, \"_primary_term\" : 1, \"found\" : true, \"_source\" : { \"price\" : 2999 } } ]} 文档的操作类型 create：不存在则创建，存在则报错 1234567# 创建POST test_index/_doc{ \"field1\":\"test1\", \"field2\":\"test2\"} delete：删除文档，删除时并没有真正删除，而是更新了版本 1DELETE test_index/_doc/qTzpA4cBcYeZSWHOL6lh update：全量替换或部分更新 1234567# 创建POST test_index/_doc/43L0A4cB88BkTKJBzyYc/_update{ \"doc\": { \"field1\":\"update_test1\" }} index：索引（动词） 12345# 创建，存在时覆盖，不存在就创建POST test_index/_doc/2?op_type=index{ \"field\": 1} 索引的批量操作_bulk 语法格式1234# _bulk批量操作# POST /index/_bulk# {\"action\": \"metadata\"}# {\"data\"} 写入1234567POST _bulk{ \"index\":{\"_index\":\"test\", \"_type\":\"_doc\", \"_id\" :\"1\"}}{ \"field1\" : \"value1\" }POST _bulk{\"index\":{ \"_index\":\"test_index\",\"_type\":\"_doc\",\"_id\":4}}{\"field1\":\"test_bulk\"} 删除12POST _bulk{\"delete\":{\"_index\":\"test_index\", \"_type\":\"_doc\",\"_id\":\"10\"}} 修改123POST _bulk{\"update\":{\"_index\":\"test_index\",\"_type\":\"_doc\",\"_id\":\"10\"}}{\"doc\":{\"field1\":\"bulk update\"}} filter_path参数说明 使用filter_path 可以筛选将处理报错的数据返回 12345678910111213# 使用filter_path 可以筛选将处理报错的数据返回POST _bulk?filter_path=items.*.error{\"update\":{\"_index\":\"test_index\",\"_type\":\"_doc\",\"_id\":\"10\"}}{\"doc\":{\"field1\":\"bulk update 222\"}}{\"create\":{ \"_index\":\"test_index\",\"_type\":\"_doc\",\"_id\":11}}{\"field1\":\"test_bulk\"}{ \"index\":{\"_index\":\"test\", \"_type\":\"_doc\", \"_id\" :\"1\"}}{ \"field1\" : \"value2222\" }{ \"delete\":{\"_index\":\"test\", \"_type\":\"_doc\", \"_id\" :\"1\"}}POST _bulk?filter_path=items.*.error{\"create\":{ \"_index\":\"test_index\",\"_type\":\"_doc\",\"_id\":11}}{\"field1\":\"test_bulk\"}","categories":[],"tags":[]},{"title":"脚本查询Scripting","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/6.脚本查询Scripting","date":"2023-03-19T13:32:24.268Z","updated":"2023-04-28T09:25:47.281Z","comments":true,"path":"2023/03/19/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/6.jiao-ben-cha-xun-scripting/","link":"","permalink":"http://example.com/2023/03/19/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/6.jiao-ben-cha-xun-scripting/","excerpt":"","text":"脚本查询Scripting 概念Scripting是Elasticsearch支持的一种专门用于复杂场景下支持自定义编程的强大的脚本功能，ES支持多种脚本语言，如painless，其语法类似于Java,也有注释、关键字、类型、变量、函数等，其就要相对于其他脚本高出几倍的性能，并且安全可靠，可以用于内联和存储脚本。 es在执行脚本时需要先进行编译，编译的结果存储在缓冲区中。 支持的语言 groovy：ES 1.4.x-5.0的默认脚本语言 painless：JavaEE使用java语言开发，.Net使用C#/F#语言开发，Flutter使用Dart语言开发，同样，ES 5.0+版本后的Scripting使用的语言默认就是painless，painless是一种专门用于Elasticsearch的简单,用于内联和存储脚本，是ES 5.0+的默认脚本语言，类似于Java,也有注释、关键字、类型、变量、函数等，是一种安全的脚本语言。并且是Elasticsearch的默认脚本语言。 其他： expression：每个文档的开销较低：表达式的作用更多，可以非常快速地执行，甚至比编写native脚本还要快，支持javascript语法的子集：单个表达式。缺点：只能访问数字，布尔值，日期和geo_point字段，存储的字段不可用 mustache：提供模板参数化查询 特点 语法简单，学习成本低 灵活度高，可编程能力强 性能相较于其他脚本语言很高 安全性好 独立语言，虽然易学但仍需单独学习 相较于DSL性能低 不适用于复杂的业务场景 应用场景 自定义评分 自定义相关度 自定义过滤器 自定义聚合分析 自定义reindex 其他自定义操作 语法 lang:编写脚本的语言，默认为painless source:脚本本身可以指定为source内联脚本或id存储脚本 params:可以传递到脚本中的任何参数名，推荐使用这种方式传参，可以减少编译的过程 12345678#语法:ctx._source.field_name\"script\": { \"lang\": \"...\", #1 \"source\" | \"id\": \"...\", #2 \"params\": { ... } #3} 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#语法:ctx._source.field_name#可以进行查找、更新等操作# 1.修改price字段POST product/_doc/1/_update{ \"script\": { \"source\": \"ctx._source.price+=params.level\", \"params\": { \"level\":100 } }}# 2.给tags字段加入一个属性，tags字段为数组POST product/_doc/1/_update{ \"script\": { \"source\": \"ctx._source.tags.add('无线充电')\" }}# 3.删除id为1的数据POST product/_doc/1/_update{ \"script\": { \"source\": \"ctx.op='delete'\" }}# 4.查询或者插入POST product/_doc/1/_update{ \"script\": { \"source\": \"ctx._source.price+=100\" }, \"upsert\": { \"name\": \"小米手机10\", \"desc\": \"充电贼快掉电更快，超级无敌望远镜，高刷电竞屏\", \"price\": 1999 }}# 5.GET 查询打9折之后的价格# GET 查询打9折之后的价格GET product/_search{ \"script_fields\": { \"price\": { \"script\": { \"lang\": \"painless\", \"source\": \"doc['price'].value*params.level\", \"params\": { \"level\":0.9 } } } }} 存储脚本1234567891011121314151617181920212223242526# 生成script脚本模板POST _scripts/calculate_discount{ \"script\":{ \"lang\": \"painless\", \"source\":\"doc.price.value*params.discount\" }}# 查询脚本GET _scripts/calculate_discount# 调用脚本GET product/_search{ \"script_fields\": { \"discount_fields\": { \"script\": { \"id\": \"calculate_discount\", \"params\": { \"discount\": 0.8 } } } }} 使用复杂脚本123456789101112131415# 使用复杂脚本# 脚本内容使用三个\"\"\"\"\"\"括起来POST product/_doc/1/_update{ \"script\": { \"lang\": \"painless\", \"source\": \"\"\" ctx._source.tags=[params.tag_name]; ctx._source.price-=100; \"\"\" , \"params\": { \"tag_name\":\"无线秒充1\" } }} 正则早先某些版本正则表达式默认情况下处于禁用模式，因为它绕过了painless的针对长时间运行和占用内存脚本的保护机制。而且有深度堆栈行为。如果需要开启正则，需要配置：script.painless.regex.enabled: true 注意：通常正则的使用范围比较小，应用范围基本限制在数据量比较小和并发量比较小的应用场景下。 doc[‘field’].value和params[‘_source’][‘field’]：理解之间的区别是很重要的，doc[‘field’].value和params[‘_source’][‘field’]。首先，使用doc关键字，将导致该字段的条件被加载到内存（缓存），这将导致更快的执行，但更多的内存消耗。此外，doc[…]符号只允许简单类型（不能返回一个复杂类型(JSON对象或者nested类型)），只有在非分析或单个词条的基础上有意义。但是，doc如果可能，使用仍然是从文档访问值的推荐方式，因为_source每次使用时都必须加载并解析。使用_source非常缓慢","categories":[],"tags":[]},{"title":"es集群重要配置","slug":"TreasureBox/Elasticsearch/操作手册/es集群重要配置","date":"2023-03-15T11:37:12.867Z","updated":"2023-04-28T09:25:47.267Z","comments":true,"path":"2023/03/15/treasurebox/elasticsearch/cao-zuo-shou-ce/es-ji-qun-chong-yao-pei-zhi/","link":"","permalink":"http://example.com/2023/03/15/treasurebox/elasticsearch/cao-zuo-shou-ce/es-ji-qun-chong-yao-pei-zhi/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307{ # 永久生效配置 \"persistent\" : { \"action\" : { \"destructive_requires_name\" : \"false\" }, \"cluster\" : { \"routing\" : { \"allocation\" : { \"node_concurrent_incoming_recoveries\" : \"2\", \"node_concurrent_recoveries\" : \"2\", \"node_initial_primaries_recoveries\" : \"4\", \"node_concurrent_outgoing_recoveries\" : \"2\" } }, \"metadata\" : { \"async_write\" : { \"enable\" : \"false\" }, \"master_async_write\" : { \"enable\" : \"false\" } } }, \"indices\" : { \"recovery\" : { \"max_bytes_per_sec\" : \"40mb\" # 集群恢复时每秒最大处理量 } }, \"logger\" : { \"org\" : \"info\" } }, \"transient\" : { \"action\" : { \"destructive_requires_name\" : \"false\" }, \"cluster\" : { \"routing\" : { \"allocation\" : { \"node_concurrent_incoming_recoveries\" : \"2\", \"node_concurrent_recoveries\" : \"2\", \"node_initial_primaries_recoveries\" : \"4\", \"node_concurrent_outgoing_recoveries\" : \"2\" } }, \"metadata\" : { \"async_write\" : { \"enable\" : \"false\" }, \"master_async_write\" : { \"enable\" : \"false\" } } }, \"indices\" : { \"recovery\" : { \"max_bytes_per_sec\" : \"40mb\" } }, \"logger\" : { \"org\" : \"info\" } }, \"defaults\" : { \"cluster\" : { \"routing\" : { \"use_adaptive_replica_selection\" : \"false\", \"rebalance\" : { \"enable\" : \"all\" }, \"allocation\" : { \"multi_path_relocation_balance\" : { \"enable\" : \"true\" }, \"same_shard\" : { \"host\" : \"false\" }, \"total_shards_per_node\" : \"-1\", \"multi_path_relocation\" : { \"max_factor\" : \"2\" }, \"delay_allocate\" : { \"enable\" : \"true\" }, \"shard_state\" : { \"started\" : { \"priority\" : \"URGENT\" }, \"failed\" : { \"priority\" : \"URGENT\" } }, \"type\" : \"balanced\", \"random_path_allocate\" : { \"enable\" : \"true\" }, \"disk\" : { \"threshold_enabled\" : \"true\", \"watermark\" : { \"low\" : \"85%\", \"flood_stage\" : \"95%\", \"high\" : \"90%\" }, \"include_relocations\" : \"true\", \"reroute_interval\" : \"60s\" }, \"awareness\" : { \"attributes\" : [ \"ip\" ] }, \"balance\" : { \"index\" : \"0.55\", \"threshold\" : \"1.0\", \"shard\" : \"0.45\" }, \"random_allocate\" : { \"enable\" : \"true\" }, \"enable\" : \"all\", \"same_ip_relocate\" : { \"enable\" : \"false\" }, \"allow_rebalance\" : \"indices_all_active\", \"cluster_concurrent_rebalance\" : \"2\" } }, \"indices\" : { \"tombstones\" : { \"size\" : \"500\" }, \"close\" : { \"enable\" : \"true\" } }, \"nodes\" : { \"reconnect_interval\" : \"10s\" }, \"persistent_tasks\" : { \"allocation\" : { \"enable\" : \"all\", \"recheck_interval\" : \"30s\" } }, \"auth\" : { \"extra\" : { \"permission\" : \"\" } }, \"blocks\" : { \"read_only_allow_delete\" : \"false\", \"read_only\" : \"false\" }, \"service\" : { \"slow_task_logging_threshold\" : \"30s\" }, \"name\" : \"es-1a35xrhw\", \"max_shards_per_node\" : \"1000\", \"remote\" : { \"node\" : { \"attr\" : \"\" }, \"initial_connect_timeout\" : \"30s\", \"connect\" : \"true\", \"connections_per_cluster\" : \"3\" }, \"info\" : { \"update\" : { \"interval\" : \"30s\", \"timeout\" : \"15s\" } } }, \"chunk_size\" : \"1gb\", \"auth\" : \"\", \"end_point\" : \"\", \"logger\" : { \"level\" : \"INFO\" }, \"cluster_type\" : \"clog\", \"processors\" : \"16\", \"ingest\" : { \"geoip\" : { \"cache_size\" : \"1000\" }, \"grok\" : { \"watchdog\" : { \"max_execution_time\" : \"1s\", \"interval\" : \"1s\" } } }, \"pidfile\" : \"\", \"path\" : { \"data\" : [ \"/data1/containers/1656662142001104232/es/data\" ], \"logs\" : \"/data1/containers/1656662142001104232/es/logs\", \"shared_data\" : \"\", \"home\" : \"/data1/containers/1656662142001104232/es\", \"repo\" : [ ] }, \"ccr\" : { \"wait_for_metadata_timeout\" : \"60s\", \"indices\" : { \"recovery\" : { \"recovery_activity_timeout\" : \"60s\", \"chunk_size\" : \"1mb\", \"internal_action_timeout\" : \"60s\", \"max_bytes_per_sec\" : \"40mb\", \"max_concurrent_file_chunks\" : \"5\" } }, \"auto_follow\" : { \"wait_for_metadata_timeout\" : \"60s\" } }, \"scheduler_period_min\" : \"30\", \"repositories\" : { \"fs\" : { \"compress\" : \"false\", \"chunk_size\" : \"9223372036854775807b\", \"location\" : \"\" }, \"url\" : { \"supported_protocols\" : [ \"http\", \"https\", \"ftp\", \"file\", \"jar\" ], \"allowed_urls\" : [ ], \"url\" : \"http:\" } }, \"action\" : { \"auto_create_index\" : \"true\", \"search\" : { \"shard_count\" : { \"limit\" : \"9223372036854775807\" } }, \"master\" : { \"force_local\" : \"false\" } }, \"app_id\" : \"\", \"cache\" : { \"recycler\" : { \"page\" : { \"limit\" : { \"heap\" : \"10%\" }, \"type\" : \"CONCURRENT\", \"weight\" : { \"longs\" : \"1.0\", \"ints\" : \"1.0\", \"bytes\" : \"1.0\", \"objects\" : \"0.1\" } } } }, \"reindex\" : { \"remote\" : { \"whitelist\" : [ ] } }, \"compress\" : \"false\", \"resource\" : { \"reload\" : { \"enabled\" : \"true\", \"interval\" : { \"low\" : \"60s\", \"high\" : \"5s\", \"medium\" : \"30s\" } } }, \"thread_pool\" : { \"force_merge\" : { \"queue_size\" : \"-1\", \"size\" : \"1\" }, \"fetch_shard_started\" : { \"core\" : \"1\", \"max\" : \"32\", \"keep_alive\" : \"5m\" }, \"listener\" : { \"queue_size\" : \"-1\", \"size\" : \"8\" }, \"index\" : { \"queue_size\" : \"200\", \"size\" : \"16\" }, \"refresh\" : { \"core\" : \"1\", \"max\" : \"8\", \"keep_alive\" : \"5m\" }, \"generic\" : { \"core\" : \"4\", \"max\" : \"128\", \"keep_alive\" : \"30s\" }, \"warmer\" : { \"core\" : \"1\", \"max\" : \"5\", \"keep_alive\" : \"5m\" }, \"search\" : { \"max_queue_size\" : \"1000\", \"queue_size\" : \"1000\", \"size\" : \"25\", \"auto_queue_frame_size\" : \"2000\", \"target_response_time\" : \"1s\", \"min_queue_size\" : \"1000\" }, \"fetch_shard_store\" : { \"core\" : \"1\", \"max\" : \"32\", \"keep_alive\" : \"5m\" }, \"flush\" : { \"core\" : \"1\", \"max\" : \"5\", \"keep_alive\" : \"5m\" }, \"management\" : { \"core\" : \"1\", \"max\" : \"5\", \"keep_alive\" : \"5m\" }, \"analyze\" : { \"queue_size\" : \"16\", \"size\" : \"1\" }, \"get\" : { \"queue_size\" : \"1000\", \"size\" : \"16\" }, \"bulk\" : { \"queue_size\" : \"200\", \"size\" : \"16\" }, \"estimated_time_interval\" : \"200ms\", \"write\" : { \"queue_size\" : \"1024\", \"size\" : \"16\" }, \"snapshot\" : { \"core\" : \"1\", \"max\" : \"5\", \"keep_alive\" : \"5m\" }, \"search_throttled\" : { \"max_queue_size\" : \"100\", \"queue_size\" : \"100\", \"size\" : \"1\", \"auto_queue_frame_size\" : \"200\", \"target_response_time\" : \"1s\", \"min_queue_size\" : \"100\" } }, \"index\" : { \"codec\" : \"default\", \"store\" : { \"hybrid\" : { \"extension\" : [ \"nvd\", \"dvd\", \"tim\", \"cfs\" ] }, \"type\" : \"\", \"fs\" : { \"fs_lock\" : \"native\" }, \"preload\" : [ ] } }, \"indices_expire\" : { \"disable\" : \"false\" }, \"script\" : { \"allowed_contexts\" : [ ], \"max_compilations_rate\" : \"75/5m\", \"cache\" : { \"max_size\" : \"100\", \"expire\" : \"0ms\" }, \"painless\" : { \"regex\" : { \"enabled\" : \"false\" } }, \"max_size_in_bytes\" : \"65535\", \"allowed_types\" : [ ] }, \"auth_version\" : \"0\", \"bucket\" : \"\", \"node\" : { \"data\" : \"true\", \"enable_lucene_segment_infos_trace\" : \"false\", \"local_storage\" : \"true\", \"max_local_storage_nodes\" : \"1\", \"name\" : \"1656662142001104232\", \"id\" : { \"seed\" : \"0\" }, \"store\" : { \"allow_mmap\" : \"true\", \"allow_mmapfs\" : \"true\" }, \"attr\" : { \"rack\" : \"cvm_4_200005\", \"set\" : \"200005\", \"ip\" : \"9.20.83.249\", \"temperature\" : \"hot\", \"region\" : \"4\", \"xpack\" : { \"installed\" : \"true\" }, \"ml\" : { \"machine_memory\" : \"67211829248\", \"max_open_jobs\" : \"20\", \"enabled\" : \"true\" } }, \"portsfile\" : \"false\", \"ingest\" : \"true\", \"master\" : \"true\", \"ml\" : \"true\" }, \"max_running_jobs\" : \"20\", \"tribe\" : { \"name\" : \"\", \"on_conflict\" : \"any\", \"blocks\" : { \"metadata\" : \"false\", \"read\" : { \"indices\" : [ ] }, \"write.indices\" : [ ], \"write\" : \"false\", \"metadata.indices\" : [ ] } }, \"http\" : { \"cors\" : { \"max-age\" : \"1728000\", \"allow-origin\" : \"\", \"allow-headers\" : \"X-Requested-With,Content-Type,Content-Length\", \"allow-credentials\" : \"false\", \"allow-methods\" : \"OPTIONS,HEAD,GET,POST,PUT,DELETE\", \"enabled\" : \"false\" }, \"max_chunk_size\" : \"8kb\", \"compression_level\" : \"3\", \"max_initial_line_length\" : \"4kb\", \"type\" : \"security4\", \"pipelining\" : \"true\", \"enabled\" : \"true\", \"type.default\" : \"netty4\", \"content_type\" : { \"required\" : \"true\" }, \"host\" : [ ], \"publish_port\" : \"-1\", \"read_timeout\" : \"0ms\", \"max_content_length\" : \"100mb\", \"netty\" : { \"receive_predictor_size\" : \"64kb\", \"max_composite_buffer_components\" : \"69905\", \"receive_predictor_max\" : \"64kb\", \"worker_count\" : \"32\", \"receive_predictor_min\" : \"64kb\" }, \"tcp\" : { \"reuse_address\" : \"true\", \"keep_alive\" : \"true\", \"receive_buffer_size\" : \"-1b\", \"no_delay\" : \"true\", \"send_buffer_size\" : \"-1b\" }, \"bind_host\" : [ ], \"reset_cookies\" : \"false\", \"max_warning_header_count\" : \"-1\", \"max_warning_header_size\" : \"-1b\", \"detailed_errors\" : { \"enabled\" : \"true\" }, \"port\" : \"9200\", \"max_header_size\" : \"8kb\", \"pipelining.max_events\" : \"10000\", \"tcp_no_delay\" : \"true\", \"compression\" : \"true\", \"publish_host\" : [ ] }, \"region\" : \"\", \"access_key_id\" : \"\", \"no\" : { \"model\" : { \"state\" : { \"persist\" : \"false\" } } }, \"bootstrap\" : { \"memory_lock\" : \"false\", \"system_call_filter\" : \"false\", \"ctrlhandler\" : \"true\" }, \"network\" : { \"host\" : [ \"0.0.0.0\" ], \"tcp\" : { \"reuse_address\" : \"true\", \"keep_alive\" : \"true\", \"connect_timeout\" : \"30s\", \"receive_buffer_size\" : \"-1b\", \"no_delay\" : \"true\", \"send_buffer_size\" : \"-1b\" }, \"bind_host\" : [ \"0.0.0.0\" ], \"server\" : \"true\", \"breaker\" : { \"inflight_requests\" : { \"limit\" : \"100%\", \"overhead\" : \"1.0\" } }, \"publish_host\" : [ \"9.20.83.249\" ] }, \"pre-create_index\" : { \"reserved_hours\" : \"2\", \"enable\" : \"true\", \"inherit_metric\" : { \"enable\" : \"false\" } }, \"search\" : { \"default_search_timeout\" : \"30000ms\", \"check_buckets_step_size\" : \"1024\", \"max_open_scroll_context\" : \"2147483647\", \"max_buckets\" : \"-1\", \"composite_aggregation\" : { \"early_terminal_enabled\" : \"true\", \"seek_after_enabled\" : \"true\" }, \"simplify_search_results\" : \"false\", \"keep_alive_interval\" : \"1m\", \"remote\" : { \"node\" : { \"attr\" : \"\" }, \"initial_connect_timeout\" : \"30s\", \"connect\" : \"true\", \"connections_per_cluster\" : \"3\" }, \"max_keep_alive\" : \"24h\", \"composite_aggregations\" : { \"use_global_ordinal\" : \"true\" }, \"highlight\" : { \"term_vector_multi_value\" : \"true\" }, \"default_allow_partial_results\" : \"true\", \"low_level_cancellation\" : \"false\", \"simplify_aggregation_results\" : \"false\", \"default_search_rpc_timeout\" : \"30000ms\", \"bucket_expansion_ratio\" : \"10\", \"allow_parent_breaker_partial_results\" : \"false\", \"default_keep_alive\" : \"5m\" }, \"security\" : { \"manager\" : { \"filter_bad_defaults\" : \"true\" } }, \"root\" : { \"routing\" : { \"rebalance\" : { \"enable\" : \"ALL\" } } }, \"client\" : { \"type\" : \"node\", \"transport\" : { \"ignore_cluster_name\" : \"false\", \"nodes_sampler_interval\" : \"5s\", \"sniff\" : \"false\", \"ping_timeout\" : \"5s\" } }, \"table_version\" : \"0\", \"table\" : \"\", \"xpack\" : { \"watcher\" : { \"execution\" : { \"scroll\" : { \"size\" : \"0\", \"timeout\" : \"\" }, \"default_throttle_period\" : \"5s\" }, \"internal\" : { \"ops\" : { \"bulk\" : { \"default_timeout\" : \"\" }, \"index\" : { \"default_timeout\" : \"\" }, \"search\" : { \"default_timeout\" : \"\" } } }, \"thread_pool\" : { \"queue_size\" : \"1000\", \"size\" : \"50\" }, \"index\" : { \"rest\" : { \"direct_access\" : \"\" } }, \"history\" : { \"cleaner_service\" : { \"enabled\" : \"true\" } }, \"trigger\" : { \"schedule\" : { \"ticker\" : { \"tick_interval\" : \"500ms\" } } }, \"enabled\" : \"true\", \"input\" : { \"search\" : { \"default_timeout\" : \"\" } }, \"encrypt_sensitive_data\" : \"false\", \"transform\" : { \"search\" : { \"default_timeout\" : \"\" } }, \"stop\" : { \"timeout\" : \"30s\" }, \"watch\" : { \"scroll\" : { \"size\" : \"0\" } }, \"require_manual_start\" : \"false\", \"bulk\" : { \"concurrent_requests\" : \"0\", \"flush_interval\" : \"1s\", \"size\" : \"1mb\", \"actions\" : \"1\" }, \"actions\" : { \"bulk\" : { \"default_timeout\" : \"\" }, \"index\" : { \"default_timeout\" : \"\" } } }, \"ilm\" : { \"enabled\" : \"true\" }, \"monitoring\" : { \"collection\" : { \"cluster\" : { \"stats\" : { \"timeout\" : \"10s\" } }, \"node\" : { \"stats\" : { \"timeout\" : \"10s\" } }, \"indices\" : [ ], \"ccr\" : { \"stats\" : { \"timeout\" : \"10s\" } }, \"index\" : { \"stats\" : { \"timeout\" : \"10s\" }, \"recovery\" : { \"active_only\" : \"false\", \"timeout\" : \"10s\" } }, \"interval\" : \"60s\", \"enabled\" : \"true\", \"ml\" : { \"job\" : { \"stats\" : { \"timeout\" : \"10s\" } } } }, \"history\" : { \"duration\" : \"168h\" }, \"elasticsearch\" : { \"collection\" : { \"enabled\" : \"true\" } }, \"enabled\" : \"true\" }, \"graph\" : { \"enabled\" : \"true\" }, \"rollup\" : { \"enabled\" : \"true\", \"task_thread_pool\" : { \"queue_size\" : \"4\", \"size\" : \"4\" } }, \"sql\" : { \"enabled\" : \"true\" }, \"license\" : { \"self_generated\" : { \"type\" : \"basic\" } }, \"logstash\" : { \"enabled\" : \"true\" }, \"notification\" : { \"hipchat\" : { \"host\" : \"\", \"port\" : \"443\", \"default_account\" : \"\" }, \"pagerduty\" : { \"default_account\" : \"\" }, \"email\" : { \"default_account\" : \"\", \"html\" : { \"sanitization\" : { \"allow\" : [ \"body\", \"head\", \"_tables\", \"_links\", \"_blocks\", \"_formatting\", \"img:embedded\" ], \"disallow\" : [ ], \"enabled\" : \"true\" } } }, \"reporting\" : { \"retries\" : \"40\", \"interval\" : \"15s\" }, \"jira\" : { \"default_account\" : \"\" }, \"slack\" : { \"default_account\" : \"\" } }, \"security\" : { \"dls_fls\" : { \"enabled\" : \"true\" }, \"transport\" : { \"filter\" : { \"allow\" : [ ], \"deny\" : [ ], \"enabled\" : \"true\" }, \"ssl\" : { \"enabled\" : \"true\" } }, \"enabled\" : \"true\", \"filter\" : { \"always_allow_bound_address\" : \"true\" }, \"encryption\" : { \"algorithm\" : \"AES/CTR/NoPadding\" }, \"audit\" : { \"outputs\" : [ \"logfile\" ], \"index\" : { \"bulk_size\" : \"1000\", \"rollover\" : \"DAILY\", \"flush_interval\" : \"1s\", \"events\" : { \"emit_request_body\" : \"false\", \"include\" : [ \"ACCESS_DENIED\", \"ACCESS_GRANTED\", \"ANONYMOUS_ACCESS_DENIED\", \"AUTHENTICATION_FAILED\", \"REALM_AUTHENTICATION_FAILED\", \"CONNECTION_DENIED\", \"CONNECTION_GRANTED\", \"TAMPERED_REQUEST\", \"RUN_AS_DENIED\", \"RUN_AS_GRANTED\", \"AUTHENTICATION_SUCCESS\" ], \"exclude\" : [ ] }, \"queue_max_size\" : \"10000\" }, \"enabled\" : \"false\", \"logfile\" : { \"emit_node_id\" : \"true\", \"emit_node_host_name\" : \"false\", \"emit_node_name\" : \"true\", \"events\" : { \"emit_request_body\" : \"false\", \"include\" : [ \"ACCESS_DENIED\", \"ACCESS_GRANTED\", \"ANONYMOUS_ACCESS_DENIED\", \"AUTHENTICATION_FAILED\", \"CONNECTION_DENIED\", \"TAMPERED_REQUEST\", \"RUN_AS_DENIED\", \"RUN_AS_GRANTED\" ], \"exclude\" : [ ] }, \"prefix\" : { \"emit_node_host_name\" : \"false\", \"emit_node_name\" : \"true\", \"emit_node_host_address\" : \"false\" }, \"emit_node_host_address\" : \"false\" } }, \"authc\" : { \"password_hashing\" : { \"algorithm\" : \"bcrypt\" }, \"success_cache\" : { \"size\" : \"10000\", \"enabled\" : \"false\", \"expire_after_access\" : \"1h\" }, \"api_key\" : { \"cache\" : { \"hash_algo\" : \"ssha256\", \"max_keys\" : \"10000\", \"ttl\" : \"24h\" }, \"delete\" : { \"interval\" : \"24h\", \"timeout\" : \"-1\" }, \"enabled\" : \"false\", \"hashing\" : { \"algorithm\" : \"pbkdf2\" } }, \"anonymous\" : { \"authz_exception\" : \"true\", \"roles\" : [ ], \"username\" : \"_anonymous\" }, \"run_as\" : { \"enabled\" : \"true\" }, \"reserved_realm\" : { \"enabled\" : \"false\" }, \"token\" : { \"compat\" : { \"enabled\" : \"false\" }, \"delete\" : { \"interval\" : \"30m\", \"timeout\" : \"-1\" }, \"enabled\" : \"false\", \"thread_pool\" : { \"queue_size\" : \"1000\", \"size\" : \"1\" }, \"timeout\" : \"20m\" } }, \"fips_mode\" : { \"enabled\" : \"false\" }, \"encryption_key\" : { \"length\" : \"128\", \"algorithm\" : \"AES\" }, \"http\" : { \"filter\" : { \"allow\" : [ ], \"deny\" : [ ], \"enabled\" : \"true\" }, \"ssl\" : { \"enabled\" : \"false\" } }, \"automata\" : { \"max_determinized_states\" : \"100000\", \"cache\" : { \"size\" : \"10000\", \"ttl\" : \"48h\", \"enabled\" : \"true\" } }, \"user\" : null, \"authz\" : { \"store\" : { \"roles\" : { \"index\" : { \"cache\" : { \"ttl\" : \"20m\", \"max_size\" : \"10000\" } }, \"auth_indices_cache\" : { \"enable\" : \"true\" }, \"cache\" : { \"max_size\" : \"10000\" }, \"negative_lookup_cache\" : { \"max_size\" : \"10000\" }, \"max_auth_indices_cache_count\" : \"10000\", \"field_permissions\" : { \"cache\" : { \"max_size_in_bytes\" : \"104857600\" } } } } } }, \"ccr\" : { \"enabled\" : \"true\", \"ccr_thread_pool\" : { \"queue_size\" : \"100\", \"size\" : \"32\" } }, \"http\" : { \"default_connection_timeout\" : \"10s\", \"proxy\" : { \"host\" : \"\", \"scheme\" : \"\", \"port\" : \"0\" }, \"default_read_timeout\" : \"10s\", \"max_response_size\" : \"10mb\" }, \"ml\" : { \"utility_thread_pool\" : { \"queue_size\" : \"500\", \"size\" : \"80\" }, \"max_anomaly_records\" : \"500\", \"enable_config_migration\" : \"true\", \"max_open_jobs\" : \"20\", \"min_disk_space_off_heap\" : \"5gb\", \"node_concurrent_job_allocations\" : \"2\", \"max_model_memory_limit\" : \"0b\", \"enabled\" : \"true\", \"max_lazy_ml_nodes\" : \"0\", \"max_machine_memory_percent\" : \"30\", \"autodetect_process\" : \"true\", \"datafeed_thread_pool\" : { \"queue_size\" : \"200\", \"size\" : \"20\" }, \"process_connect_timeout\" : \"10s\", \"autodetect_thread_pool\" : { \"queue_size\" : \"80\", \"size\" : \"80\" } } }, \"auth.disable\" : \"true\", \"netty\" : { \"breaker\" : { \"limit\" : \"95%\", \"type\" : \"memory\", \"enabled\" : \"true\", \"timeout\" : \"30000ms\" } }, \"rest\" : { \"action\" : { \"multi\" : { \"allow_explicit_index\" : \"true\" } } }, \"max\" : { \"anomaly\" : { \"records\" : \"500\" } }, \"base_path\" : \"\", \"monitor\" : { \"jvm\" : { \"gc\" : { \"enabled\" : \"true\", \"overhead\" : { \"warn\" : \"50\", \"debug\" : \"10\", \"info\" : \"25\" }, \"refresh_interval\" : \"1s\" }, \"refresh_interval\" : \"1s\" }, \"process\" : { \"refresh_interval\" : \"1s\" }, \"os\" : { \"refresh_interval\" : \"1s\" }, \"fs\" : { \"refresh_interval\" : \"1s\" } }, \"transport\" : { \"tcp\" : { \"reuse_address\" : \"true\", \"connect_timeout\" : \"30s\", \"compress\" : \"false\", \"port\" : \"9300\", \"no_delay\" : \"true\", \"keep_alive\" : \"true\", \"receive_buffer_size\" : \"-1b\", \"send_buffer_size\" : \"-1b\" }, \"bind_host\" : [ ], \"connect_timeout\" : \"30s\", \"compress\" : \"false\", \"ping_schedule\" : \"-1\", \"connections_per_node\" : { \"recovery\" : \"2\", \"state\" : \"1\", \"bulk\" : \"3\", \"reg\" : \"6\", \"ping\" : \"1\" }, \"tracer\" : { \"include\" : [ ], \"exclude\" : [ \"internal:discovery/zen/fd*\", \"cluster:monitor/nodes/liveness\" ] }, \"type\" : \"security4\", \"type.default\" : \"netty4\", \"features\" : { \"x-pack\" : \"true\" }, \"port\" : \"9300\", \"host\" : [ ], \"publish_port\" : \"-1\", \"connection\" : { \"max_corrupted_msg_bytes\" : \"512\" }, \"tcp_no_delay\" : \"true\", \"publish_host\" : [ ], \"netty\" : { \"receive_predictor_size\" : \"64kb\", \"receive_predictor_max\" : \"64kb\", \"worker_count\" : \"32\", \"receive_predictor_min\" : \"64kb\", \"boss_count\" : \"1\" } }, \"preferred_master_name\" : \"\", \"indices\" : { \"cache\" : { \"cleanup_interval\" : \"1m\" }, \"mapping\" : { \"dynamic_timeout\" : \"30s\", \"put\" : { \"priority\" : \"URGENT\" }, \"max_in_flight_updates\" : \"10\" }, \"memory\" : { \"interval\" : \"5s\", \"max_index_buffer_size\" : \"-1\", \"shard_inactive_time\" : \"5m\", \"index_buffer_size\" : \"15%\", \"min_index_buffer_size\" : \"48mb\" }, \"breaker\" : { \"request\" : { \"limit\" : \"60%\", \"type\" : \"memory\", \"overhead\" : \"1.0\" }, \"search\" : { \"throttle\" : \"90%\" }, \"total\" : { \"limit\" : \"90%\", \"use_real_memory\" : \"true\" }, \"fielddata\" : { \"limit\" : \"20%\", \"type\" : \"memory\", \"overhead\" : \"1.03\" }, \"single_request\" : { \"limit\" : \"20%\", \"type\" : \"memory\", \"overhead\" : \"1.0\" }, \"accounting\" : { \"limit\" : \"100%\", \"overhead\" : \"1.0\" }, \"bulk\" : { \"throttle\" : \"90%\" }, \"type\" : \"hierarchy\" }, \"segment_memory\" : { \"off_heap\" : { \"segment_count\" : \"1\", \"min_size\" : \"500mb\", \"size\" : \"500mb\", \"enable\" : \"false\", \"max_size\" : \"32gb\", \"min_value_size\" : \"512\" } }, \"query\" : { \"bool\" : { \"max_clause_count\" : \"1024\" }, \"query_string\" : { \"analyze_wildcard\" : \"false\", \"allowLeadingWildcard\" : \"true\" } }, \"admin\" : { \"filtered_fields\" : \"true\" }, \"allow_multi_types\" : \"false\", \"recovery\" : { \"recovery_activity_timeout\" : \"1800000ms\", \"retry_delay_network\" : \"5s\", \"internal_action_timeout\" : \"15m\", \"retry_delay_state_sync\" : \"500ms\", \"internal_action_long_timeout\" : \"1800000ms\", \"max_concurrent_file_chunks\" : \"1\" }, \"requests\" : { \"cache\" : { \"size\" : \"1%\", \"expire\" : \"0ms\" } }, \"store\" : { \"delete\" : { \"shard\" : { \"timeout\" : \"30s\" } } }, \"analysis\" : { \"hunspell\" : { \"dictionary\" : { \"ignore_case\" : \"false\", \"lazy\" : \"false\" } } }, \"queries\" : { \"cache\" : { \"count\" : \"300\", \"max_times_of_leading_cost\" : \"250\", \"size\" : \"5%\", \"all_segments\" : \"false\", \"max_doc_count\" : \"5000000\" } }, \"lifecycle\" : { \"poll_interval\" : \"10m\" }, \"fielddata\" : { \"cache\" : { \"size\" : \"15%\" } }, \"bulk\" : { \"reject_illegal_time_data\" : { \"enable\" : \"true\" } } }, \"plugin\" : { \"mandatory\" : [ ] }, \"metric\" : { \"create_deduplicate_optimize\" : { \"enable\" : \"true\" } }, \"discovery\" : { \"type\" : \"zen\", \"zen\" : { \"commit_timeout\" : \"30s\", \"no_master_block\" : \"write\", \"join_retry_delay\" : \"100ms\", \"join_retry_attempts\" : \"3\", \"ping\" : { \"unicast\" : { \"concurrent_connects\" : \"10\", \"hosts\" : [ \"9.20.83.249:9300\", \"9.20.85.27:9300\", \"9.20.91.71:9300\", \"9.20.86.14:9300\" ], \"hosts.resolve_timeout\" : \"5s\" } }, \"master_election\" : { \"ignore_non_master_pings\" : \"false\", \"wait_for_joins_timeout\" : \"30000ms\" }, \"send_leave_request\" : \"true\", \"ping_timeout\" : \"3s\", \"join_timeout\" : \"60000ms\", \"publish_diff\" : { \"enable\" : \"true\" }, \"publish\" : { \"max_pending_cluster_states\" : \"25\" }, \"minimum_master_nodes\" : \"3\", \"hosts_provider\" : [ ], \"publish_timeout\" : \"30s\", \"fd\" : { \"connect_on_network_disconnect\" : \"false\", \"ping_interval\" : \"1s\", \"ping_retries\" : \"3\", \"register_connection_listener\" : \"true\", \"ping_timeout\" : \"30s\" }, \"max_pings_from_another_master\" : \"3\" }, \"initial_state_timeout\" : \"30s\" }, \"access_key_secret\" : \"\", \"gateway\" : { \"recover_after_master_nodes\" : \"0\", \"expected_nodes\" : \"-1\", \"recover_after_data_nodes\" : \"-1\", \"expected_data_nodes\" : \"-1\", \"recover_after_time\" : \"0ms\", \"expected_master_nodes\" : \"-1\", \"recover_after_nodes\" : \"-1\" } }} 1","categories":[],"tags":[]},{"title":"桶分析","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/5.桶分析","date":"2023-03-14T12:55:28.644Z","updated":"2023-04-28T09:25:47.280Z","comments":true,"path":"2023/03/14/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/5.tong-fen-xi/","link":"","permalink":"http://example.com/2023/03/14/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/5.tong-fen-xi/","excerpt":"","text":"桶分析聚合查询通用结构 123456789101112# aggs聚合查询# NAME 聚合的名称# AGG_TYPE聚合的类型GET product/_search{ \"size\":0, \"aggs\": { \"NAME\": { \"AGG_TYPE\": {} } }} 使用post_filter时查询时不会影响聚合结果1234567891011121314151617# 想让聚合和查询互不影响时，使用post_filterGET product/_search{ \"aggs\": { \"tags_bucket\": { \"terms\": { \"field\": \"tags.keyword\", \"size\": 10 } } }, \"post_filter\": { \"term\": { \"tags.keyword\": \"性价比\" } }} 分桶聚合类似mysql数据库中的group by之后计算，按照某种维度进行分桶，计算数量信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 求最大值、最小值、均值、数量、求和GET product/_search{ \"size\": 0, \"aggs\": { \"max_price\": { \"max\": { \"field\": \"price\" } }, \"avg_price\": { \"avg\": { \"field\": \"price\" } }, \"min_price\": { \"min\": { \"field\": \"price\" } }, \"count_price\": { \"value_count\": { \"field\": \"price\" } }, \"sum_price\": { \"sum\": { \"field\": \"price\" } } }}# stats求五个值GET product/_search{ \"size\": 0, \"aggs\": { \"price_stats\": { \"stats\": { \"field\": \"price\" } } }} cardinality：根据某个字段去重之后计算数量 指标聚合根据某种metric做指标分析： Avg：平均值 Max：最大值 Min：最小值 Sum：求和 Cardinality：基数（去重） Value Count计数 Stats统计聚合 Top Hits聚合 1234567891011121314151617181920# 计算平均分类的平均价格# 1.先根据类别分组。2.再计算平均价格GET product/_search{ \"size\": 0, \"aggs\": { \"type_bucket\": { \"terms\": { \"field\": \"type.keyword\" }, \"aggs\": { \"price\": { \"avg\": { \"field\": \"price\" } } } } }} 管道聚合对聚合的结果做二次聚合，比如统计平均价格最低的商品分类：先根据商品类别进行分类求平均值，再计算平均值最小的类别。 语法：buckets_path ​ buckets_path：统计的对象必须为Object，意味着只能在当前计算值的上层，嵌套两层进行计算。支持七种 min_bucket：最小值 max_bucket：最大值 avg_bucket：平均值 percentiles_bucket：分位值 sum_bucket：求和 extended_stats_bucket：最小最大、均值等信息 stats_bucket：最小最大均值等 使用 123456789101112131415161718192021222324252627282930313233# 管道聚合# 先根据类型分桶，求出价格的均值# 再将计算出的桶结果作为管道进行二次运算# 将哪个bucket作为管道就跟哪一层平级GET product/_search{ \"size\": 0, \"aggs\": { \"type_bucket\": { \"terms\": { \"field\": \"type.keyword\" }, \"aggs\": { \"price_bucket\": { \"avg\": { \"field\": \"price\" } } } }, \"minbucket\": { \"min_bucket\": { \"buckets_path\": \"type_bucket&gt;price_bucket\" } }, \"percentile_ranks_minbucket\": { \"percentiles_bucket\": { \"buckets_path\": \"type_bucket&gt;price_bucket\", \"percents\": [10,95,99] } } }} 123456789101112131415161718192021222324252627# 先根据类型分组，再根据lv分级，最后计算最大值、最小值、平均值GET product/_search{ \"size\": 0, \"aggs\": { \"group_by_type\": { \"terms\": { \"field\": \"type.keyword\", \"size\": 30 }, \"aggs\": { \"group_by_lv\": { \"terms\": { \"field\": \"lv.keyword\" }, \"aggs\": { \"price_stats\": { \"stats\": { \"field\": \"price\" } } } } } } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960GET product/_search{ \"size\": 0, \"aggs\": { \"group_by_type\": { \"terms\": { \"field\": \"type.keyword\", \"size\": 30 }, \"aggs\": { \"group_by_lv\": { \"terms\": { \"field\": \"lv.keyword\" }, \"aggs\": { \"avg_price\": { \"avg\": { \"field\": \"price\" } } } }, \"min_bucket\":{ \"min_bucket\": { \"buckets_path\": \"group_by_lv&gt;avg_price\" } }, \"max_bucket\":{ \"max_bucket\": { \"buckets_path\": \"group_by_lv&gt;avg_price\" } }, \"avg_bucket\":{ \"avg_bucket\": { \"buckets_path\": \"group_by_lv&gt;avg_price\" } }, \"percentiles_buckets\":{ \"percentiles_bucket\": { \"buckets_path\": \"group_by_lv&gt;avg_price\" } }, \"sum_buckets\":{ \"sum_bucket\": { \"buckets_path\": \"group_by_lv&gt;avg_price\" } }, \"extended_stats_bucket\":{ \"extended_stats_bucket\": { \"buckets_path\": \"group_by_lv&gt;avg_price\" } },\"stats_buckets\":{ \"stats_bucket\": { \"buckets_path\": \"group_by_lv&gt;avg_price\" } } } } }} 在聚合查询中嵌套global 1234567891011121314151617181920212223242526272829# 使用global时可以不受外围查询条件影响，直接聚合所有数据,例如筛选出&gt;4000数据的最大值，再查所有数据的平均值GET product/_search{ \"size\": 0, \"query\": { \"range\": { \"price\": { \"gte\": 4000 } } }, \"aggs\": { \"max_price\": { \"max\": { \"field\": \"price\" } }, \"all_avg_price\": { \"global\": {}, \"aggs\": { \"avg_price\": { \"avg\": { \"field\": \"price\" } } } } }} 在分桶查询中嵌套filter1234567891011121314151617181920212223242526272829303132333435# 在聚合语句中嵌套filter，可以在聚合之前再单独增加筛选条件GET product/_search{ \"size\": 0, \"query\": { \"range\": { \"price\": { \"gte\": 4000 } } }, \"aggs\": { \"max_price\": { \"max\": { \"field\": \"price\" } }, \"muti_avg_price\": { \"filter\": { \"range\": { \"price\": { \"lte\": 3000 } } }, \"aggs\": { \"avg_price\": { \"avg\": { \"field\": \"price\" } } } } }} 对分桶结果进行排序12345678910111213141516171819# 对分桶结果排序# _count:按照分桶的数量排序# _可以:按照字典序排列GET product/_search{ \"size\": 0, \"aggs\": { \"tags_aggs\":{ \"terms\": { \"field\": \"tags.keyword\", \"size\": 30, \"order\": { \"_count\": \"asc\", \"_key\": \"asc\" } } } }} 嵌套分桶排序方式12345678910111213141516171819202122232425262728# 对分桶结果排序# _count:按照分桶的数量排序GET product/_search?search_type=dfs_query_then_fetch{ \"size\": 0, \"aggs\": { \"tags_aggs\":{ \"terms\": { \"field\": \"type.keyword\", \"size\": 30, \"order\": { \"_count\": \"asc\" } }, \"aggs\": { \"group_by_lv\": { \"terms\": { \"field\": \"lv.keyword\", \"order\": { \"_count\": \"desc\" } } } } } }} 父桶根据子桶的聚合结果排序123456789101112131415161718192021222324252627282930313233# 父桶根据子桶的聚合结果排序GET product/_search{ \"size\": 0, \"aggs\": { \"tags_aggs\": { \"terms\": { \"field\": \"type.keyword\", \"order\": { \"agg_stats&gt;stats_bucket.min\": \"desc\" } }, \"aggs\": { \"agg_stats\": { \"filter\": { \"range\": { \"price\": { \"gte\": 1000 } } }, \"aggs\": { \"stats_bucket\": { \"stats\": { \"field\": \"price\" } } } } } } }} date_histogram：根据日期分桶","categories":[],"tags":[]},{"title":"分词器","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/4.分词器","date":"2023-03-13T13:09:08.041Z","updated":"2023-04-28T09:25:47.278Z","comments":true,"path":"2023/03/13/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/4.fen-ci-qi/","link":"","permalink":"http://example.com/2023/03/13/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/4.fen-ci-qi/","excerpt":"","text":"分词器规范化normalization提高文档的查询成功率，对词进行切分、同义词归并、大写转小些、负数转单数等；主要分为4步： 切词(word segmentation) 规范化：normalization 去重 字典序 字符过滤器character filter HTML Strip：处理html标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748创建分词器# analysis表示分析器# char_filter表示字符串过滤器，过滤器类型是html_strip# my_analyzer表示分词# escaped_tags表示希望保留的标签PUT my_index{ \"settings\": { \"analysis\": { \"char_filter\": { \"my_char_filter\":{ \"type\":\"html_strip\" } }, \"analyzer\": { \"my_analyzer\":{ \"tokenizer\":\"keyword\", \"char_filter\": \"my_char_filter\" } } } }}# 使用分词器GET my_index/_analyze{ \"analyzer\": \"my_analyzer\", \"text\":\"&lt;p&gt;I'm so &lt;a&gt;happy&lt;/a&gt;&lt;/p&gt;\"}# 返回的结果{ \"tokens\" : [ { \"token\" : \"\"\"I'm so &lt;a&gt;happy&lt;/a&gt;\"\"\", \"start_offset\" : 0, \"end_offset\" : 26, \"type\" : \"word\", \"position\" : 0 } ]} Mapping Character Filter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 使用分词器GET my_index/_analyze{ \"analyzer\": \"my_analyzer\", \"text\":\"&lt;p&gt;I'm so &lt;a&gt;happy&lt;/a&gt;&lt;/p&gt;\"}PUT my_index{ \"settings\": { \"analysis\": { \"char_filter\": { \"my_char_filter\":{ \"type\":\"mapping\", \"mappings\":[ \"滚 =&gt; *\", \"垃圾 =&gt; **\" ] } }, \"analyzer\": { \"my_analyzer\":{ \"tokenizer\":\"keyword\", \"char_filter\": \"my_char_filter\" } } } }}# 使用分词器GET my_index/_analyze{ \"analyzer\": \"my_analyzer\", \"text\":\"垃圾应该滚去垃-级堆\"}# 返回的结果{ \"tokens\" : [ { \"token\" : \"**应该*去垃-级堆\", \"start_offset\" : 0, \"end_offset\" : 10, \"type\" : \"word\", \"position\" : 0 } ]} Pattern Replace123456789101112131415161718192021222324252627# 正则替换PUT my_index{ \"settings\": { \"analysis\": { \"char_filter\": { \"my_char_filter\":{ \"type\":\"pattern_replace\", \"pattern\":\"(\\\\d{3})\\\\d{4}(\\\\d{4})\", \"replacement\":\"$1****$2\" } }, \"analyzer\": { \"my_analyzer\":{ \"tokenizer\":\"keyword\", \"char_filter\": \"my_char_filter\" } } } }}# 使用分词器GET my_index/_analyze{ \"analyzer\": \"my_analyzer\", \"text\":\"手机号是18764077883\"} 分词器 tokenizer令牌过滤器 token filter常用分词器中文分词器ik分词器简单示例 12345GET _analyze{ \"text\":\"你好，吃早饭了吗\", \"analyzer\": \"ik_smart\"} 自定义分词器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 自定义分词器PUT custom_analysis{ \"settings\": { \"analysis\": { \"char_filter\": { \"my_char_filter\": { \"type\": \"mapping\", \"mappings\": [ \"滚 =&gt; *\", \"垃圾 =&gt; **\" ] } }, \"filter\": { \"my_stopword\": { \"type\": \"stop\", \"stopwords\": [ \"is\", \"in\", \"the\", \"a\", \"at\", \"for\" ] } }, \"tokenizer\":{ \"my_tokenizer\":{ \"type\":\"pattern\", \"pattern\":\"[,.!?]\" } }, \"analyzer\": { \"my_analyzer\":{ \"type\":\"custom\", \"char_filter\":[\"my_char_filter\"], \"tokenizer\":\"my_tokenizer\", \"filter\":[\"my_stopword\"] } } } }}# 测试分词器GET custom_analysis/_analyze{ \"analyzer\": \"my_analyzer\", \"text\":[\"what is asdf,.? ss in &amp; | is the good boy滚hh\"]} 热更新","categories":[],"tags":[]},{"title":"ES入门指南","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/ES入门指南","date":"2023-03-12T03:17:52.069Z","updated":"2023-04-28T09:25:47.285Z","comments":true,"path":"2023/03/12/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/es-ru-men-zhi-nan/","link":"","permalink":"http://example.com/2023/03/12/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/es-ru-men-zhi-nan/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"核心知识点","slug":"TreasureBox/Elasticsearch/学习笔记/核心知识点","date":"2023-03-05T09:37:45.394Z","updated":"2023-04-28T09:25:47.269Z","comments":true,"path":"2023/03/05/treasurebox/elasticsearch/xue-xi-bi-ji/he-xin-zhi-shi-dian/","link":"","permalink":"http://example.com/2023/03/05/treasurebox/elasticsearch/xue-xi-bi-ji/he-xin-zhi-shi-dian/","excerpt":"","text":"ES基本介绍倒排索引从一条数据入门倒排索引 id title info 1 念奴娇·昆仑 横空出世，莽昆仑，阅尽人间春色…. 2 公无渡河 黄河西来决昆仑，咆哮万里触龙门… 在mysql中查询: select * from table where info like “%昆仑%“;这种查询时索引失效 倒排索引数据的存储格式通过为每一个field分词后建立倒排索引加速查找效率，以field value为key，数据id为值组建结构 term posting list 横空出世 1 莽 1 昆仑 1,2 黄河 2 Elastic Stack(ELKB)家族Elastic Search是一个分布式的开放搜索和分析引擎，适用于所有类型的数据格式，包括文本、数字、地理空间、结构化和非结构化数据，基于Lucene基础开发。是一个近实时的搜索平台(1秒)左右。 LogStash开放性的服务器端数据处理管道，能够从多个来源采集数据、转换数据，对数据进行聚合和处理，然后将数据发送到存储库中。 Kibana搜索、查看并可视化es中存储的数据，并通过创建柱状图、饼状图、表格、直方图、地图等对数据进行分析。 Beats轻量级数据采集器，可以从各种环境中收集日志、指标安全数据或网格数据，通过logstash或kafka等传输到es中进行存储。 核心概念集群(cluster)集群由一个或多个节点组成，通过集群名称进行表示。通常集群名称在ES配置文件(config/elasticsearch.tml)中设置 节点(node)单个ES实例成为节点，依据功能可以分为下面几种，在(config/elasticsearch.tml)配置： master：候选节点（创建、更新、删除索引，添加、删除node，分配shard） data：数据节点 data_content：数据内容没电 data_hot：热节点，可读可更新 data_warm：warm节点：只读不更新 data_code：冷节点，存放历史数据（不常访问） ingest：预处理节点，类似LogStash中的Filter ml(machine learning)：机器学习节点 voting node：仅投票节点（选主） coordination node：协调节点，接受外部请求并转发到相应节点（不特指某个节点，所有节点都有可能成为协调节点） 如何避免脑裂： 脑裂：正常es集群中只有一个主节点，主节点负责管理整个集群，集群的所有节点都会选择同一个节点作为主节点，所以无论访问那个节点都可以查看集群的状态信息。 而脑裂问题的出现就是因为从节点在选择主节点上出现分歧导致一个集群出现多个主节点从而使集群分裂，使得集群处于异常状态。 原因： 网络问题：主节点未及时响应，集群以为主节点下线，选举一个新的主节点，原主节点恢复后集群就会形成两个主节点，导致集群分裂 节点负载：主节点同时承担数据节点角色时，可能会出现负载比较大，引发较大规模的内存回收(GC)，造成ES进程失去响应。 内存回收：数据节点上的ES进程占用的内存较大，较大规模的内存回收操作也能造成ES进程失去响应 解决办法： master node与data node分别设置，即node.master与node.data不要同时为True，主节点配置为：node.master: true ，node.data: false。数据节点配置为：node.master: false，node.data: true。 调整节点响应超时时间：discovery.zen.ping_timeout默认为(3s)，如果master节点超过3s未响应时就认为master节点挂了，增加等待响应时间能减少误判。 调整discovery.zen.minimum_master_nodes(默认值是1)参数，该参数表示， 一个节点需要看到的具有master节点资格的最小数量， 然后才能在集群中做操作，即重新选举主节点。官方的推荐值是(N/2)+1，其中 N 是具有 master资格的节点的数量，即只有超过(N/2)+1个主节点同意，才能重新选举主节点。 从脑裂中恢复： 给所有数据重新索引：POST _reindex{ “source”: { “index”: “index_name” }, “dest”: { “index”: “new_index_name”, “op_type”: “create” } } 逐个关闭节点并备份数据，分析比对数据是否是最新的。如果是保存的数据是最新的，启动它并且让它被选为主节点，之后启动集群中其他节点。 索引(index)​ 类似数据库的概念，以分片为单位，可以设置副本及分片个数 类型(type)每一个index中分为不同的type，使用type可以在同一个index里存储多种类型的数据，可以减少index的数量，好处是搜索同一个index 的多个type时不会产生额外的开销，因为遍历的分片数是一样的。 示例：index为qemu_disk_iostat，type为qemu_disk_iostat_20230312、qemu_disk_iostat_20230313 缺点：不同type名称相同的field要完全保持一致（字段类型、是否能索引等）；在某个type有的字段，其他没有该字段的type也会消耗资源(posting list,doc value)。搜索评分是在index级别计算，多个type会相互影响，比较鸡肋。如果只是相对数据进行分割，使用多个index比使用type要好。 在7.x版本中弱化，统一使用_doc使用，在8.x中彻底删除。 分片(shard)一个索引中包含一个或者多个分片，在7.0之前默认创建5个分片，每个主分片一个副本；7.x之后默认创建1个主分片，每个节点默认只允许1000个分片。副本可以在索引创建之后修改数量，但是主分片的数量一旦确定之后不能修改，只能删除之后重新创建。 主分片挂掉之后副分片升级为主分片。原分片加入之后从当前主分片中同步数据。主分片和副分片不会在同一个节点中。 每个分片都是一个Lucene实例，有完整的创建索引和处理请求能力，搜索时所有的分片都会被扫描，最终被ES合并所有的搜索结果。 ES会在nodes上做分片均衡：所有的分片尽量均匀的分布在所有的节点上rebalance(分片平衡策略)。一个doc不会存在于多个主分片中，但是当每个主分片的副本数量不唯一时，可以同时存在于多个副本中 分片设计原则：受JVM大小影响，64G内存机器按照每个分片30-50G分配，32G机器按照最大不超过30G分配。分片数尽量保证data node的整数倍。例如3个data node 64G内存节点，索引大小为500GB，则分应设置12个分片，每个42GB左右，3个节点每个可以分4个分片。 副本(replace)副本分片，主分片和副分片不能在同一个节点上，如果设置副本&gt;0时，最少要有两个data node，否则分配一直处于无法分配状态。 文档(doc)es中的数据都是以json文档的形式存储，是数据存储的基本单元，每个doc都会有_id字段，可以在存储时指定_id，或者es会自动生成，推荐自动生成，es默认根据_id做routing，分配该数据要存储的分片。 routing计算规则： shard = hash(routing) % number_of_primary_shards routing可以自定义，这样方便将某一类数据分配在同一个分片中，但是如果设置的routing不合适，可能导致数据写入不均。 mappingmaping类似于RDB中的“表结构”概念，在MySQL中，表结构里包含了字段名称，字段的类型还有索引信息等。在Mapping里也包含了一些属性，比如字段名称、类型、字段使用的分词器、是否评分、是否创建索引等属性，并且在ES中一个字段可以有对个类型。分词器、评分等概念。 常见类型数字类型： long 个带符号的 64 位整数，最小值为，最大值为。 -263 263-1 integer 一个带符号的 32 位整数，最小值为，最大值为。 -231 231-1 short 一个带符号的 16 位整数，最小值为-32768，最大值为32767。 byte 一个带符号的 8 位整数，最小值为-128，最大值为127。 double 双精度 64 位 IEEE 754 浮点数，仅限于有限值。最小2的-1074次方 float 单精度 32 位 IEEE 754 浮点数，仅限于有限值。最小2的-149次方 half_float 半精度 16 位 IEEE 754 浮点数，仅限于有限值。最小2的-24次方 scaled_float 由 支持的有限浮点数long，按固定double比例因子缩放 keyword ：适用于索引结构化的字段，可以用于过滤、排序、聚合。keyword类型的字段只能通过精确值（exact value）搜索到。 Date类型：包括date和 date_nanos text：全文索引会被用于分词 对象关系类型： object：用于单个JSON对象 nested：用于JSON对象数组 结构化类型： geo-point：纬度/经度积分 geo-shape：用于多边形等复杂形状 point：笛卡尔坐标点 shape：笛卡尔任意几何图形 特殊类型： ip：用于IPv4和IPv6地址 … array（数组） 数组不需要专用的字段数据类型。默认情况下，任何字段都可以包含零个或多个值，但是数组中的所有值都必须具有相同的数据类型 动态字段映射(Dynamic field mapping)建议使用ES时显示指定字段类型，毕竟相对于ES，写入者更了解自己的数据。如果不指定字段类型时ES的默认映射方式： 整数 =&gt; long 浮点数 =&gt; float true || false =&gt; boolean 日期 =&gt; date 数组 =&gt; 取决于数组中的第一个有效值 对象 =&gt; object 字符串 =&gt; 如果不是数字和日期类型，会被映射为text和keyword两个类型 基本数据类型 占用的内存（byte） 范围 byte 1 -2^7 ~ 2^7-1 short 2 -2^15 ~ 2^15-1 int 4 -2^31 ~ 2^31-1 long 8 -2^63 ~ 2^63-1 float 4 -3.4e+38 ~ 3.4e+38 double 8 -1.7e+308 ~ 1.7e+308 boolean 1 true/false char 2 0~65535 问题：0应该选择哪种数据结构存储？推荐阅读 [ {“id”:1,”disk_uuid”:”test-diskuuid”,”util”:0, “svctm”: 6,”time”:”2023-03-12 14:50:00”,”set”:”test-set”}, {“id”:2,”disk_uuid”:”test-diskuuid”,”util”:94.6, “time”:”2023-03-12 14:50:10”,”set”:”test-set”} ] 数据存储结构ES数据存储结构ES底层使用 Lucene 存储数据，Lucene 的索引包含以下部分： inverted index：倒排索引。bkd tree: Block k-d tree，用于在高维空间内做索引，如地理坐标的索引。column store：doc values，列式存储，批量读取连续的数据以提高排序和聚合的效率。document store：Store Fileds，行式存储文档，用于控制 doc 原始数据的存储，其中占比最大的是 source 字段。term vectors：用于存储各个词在文档中出现的位置等信息。 常见配置项说明两组示例数据: [ {“id”:1,”title”:”念奴娇·昆仑”,”info”:”横空出世，莽昆仑，阅尽人间春色….”}, {“id”:2,”title”:”公无渡河”,”info”:”黄河西来决昆仑，咆哮万里触龙门…”} ] [ {“id”:1,”disk_uuid”:”test”,”util”:0, “svctm”: 6,”time”:”2023-03-12 14:50:00”,”set”:”test-set”}}, {“id”:2,”disk_uuid”:”test”,”util”:94.6, “time”:”2023-03-12 14:50:10”,”set”:”test-set”}} ] 配置项 作用 注意事项 默认值 数据格式 _all 提供跨字段全文检索 （1）会占用额外空间，把 mapping 中的所有字段通过空格拼接起来做索引，在跨字段全文检索才需要打开；（2）在 v6.0+已被弃用，v7.0会正式移除，可以使用 [copy_to] 来自定义组合字段 关闭 以title和info字段设置all为例，存储结构为：”念奴娇·昆仑 横空出世，莽昆仑，阅尽人间春色….”es同样会对all字段做分词 _source 存储 post 提交到ES的原始 json 内容 （1）会占用很多存储空间。数据压缩存储，读取会有额外解压开销。（2）不需要读取原始字段内容可以考虑关闭，但关闭后无法 reindex 开启 {“id”:1,”title”:”念奴娇·昆仑”,”info”:”横空出世，莽昆仑，阅尽人间春色….”}{“id”:2,”title”:”公无渡河”,”info”:”黄河西来决昆仑，咆哮万里触龙门…”} store 是否单独存储该字段 （1）会占用额外存储空间，与_source 独立，同时开启 store 和 source 则会将该字段原始内容保存两份，不同字段单独存储，不同字段的数据在磁盘上不连续，若读取多个字段则需要查询多次，如需读取多个字段，需权衡比较 source 与 store 效率 关闭 通过黄河搜索info信息时，先找到了posting list为2，接着查询具体的info信息info: 黄河西来决昆仑，咆哮万里触龙门…title: 公无渡河，使用时：stored_fields doc_values 支持排序、聚合 支持排序、聚合会占用额外存储空间，与 source 独立，同时开启 doc_values 和 _source 则会将该字段原始内容保存两份。doc_values 数据在磁盘上采用列式存储，关闭后无法使用排序和聚合 开启 util [0, 94.6]以disk_uuid字段倒排索引为例：test:[1, 2] ,查询disk_uuid为test的sum util值数据，查询到了1, 2，接着进行聚合 index 是否加入倒排索引 关闭后无法对其进行搜索，但字段仍会存储到 _source 和 doc_values，字段可以被排序和聚合 开启 test: [1,2] enabled 是否对该字段进行处理 关闭后，只在 _source中存储，类似 index 与 doc_values 的总开关 开启 _allall 字段的作用是提供跨字段查询的支持，把 mapping 中的所有字段通过空格拼接起来做索引。ES在正常查询的过程中，需要指定在哪一个field里面查询，但是在某种场景下比如搜索一首包含“昆仑”的诗，可能在title字段，或者info字段，查询时需要查title或者info中，查询两次。 如果开启al，会将title 字段和info 字段拼接组成一个虚拟的字段all，值为各个field拼接起来的很长的字符串如（念奴娇·昆仑 横空出世….），实现跨字段检索，用户不需要关心查询的数据具体在哪个字段中。 该字段的内容来源于 source 字段，因此默认情况下，该字段的内容并不会被保存，可以通过设置 store 属性来强制保存 all 字段。开启 all 字段，会带来额外的CPU开销和存储，如果没有使用到，可以关闭 all 字段。 _sourcesource 字段用于存储 post 到 ES 的原始 json 文档。为什么要存储原始文档呢？因为 ES 采用倒排索引对文本进行搜索，而倒排索引无法存储原始输入文本。一段文本交给ES后，首先会被分析器(analyzer)打散成单词，为了保证搜索的准确性，在打散的过程中，会去除文本中的标点符号，统一文本的大小写，甚至对于英文等主流语言，会把发生形式变化的单词恢复成原型或词根，然后再根据统一规整之后的单词建立倒排索引，经过如此一番处理，原文已经面目全非。因此需要有一个地方来存储原始的信息，以便在搜到这个文档时能够把原文返回给查询者。 是否一定需要存储原始文档？不一定！如果没有取出整个原始 json 结构体的需求，可以在 mapping 中关闭 source 字段或者只在 source 中存储部分字段（使用store）。 关闭source的负面影响： （1）不能获取到原文，不能使用update、update_by_query api（2）无法reindex：如果存储了 source，当 index 发生损坏，或需要改变 mapping 结构时，由于存在原始数据，ES可以通过原始数据自动重建index，如果不存 source 则无法实现（3）无法在查询中使用script：因为 script 需要访问 source 中的字段 storestore 决定一个字段是否要被单独存储。source 里面中已经存储了原始的文档，为什么还需要一个额外的 store 属性呢？原因如下： （1）如果禁用了 source 保存，可以通过指定 store 属性来单独保存某个或某几个字段，而不是将整个输入文档保存到 source 中。 （2）如果 source 中有长度很长的文本（如一篇文章）和较短的文本（如文章标题），当只需要取出标题时，如果使用 source 字段，ES需要读取整个 source 字段，然后返回其中的 title，由此会引来额外的IO开销，降低效率。此时可以选择将 title 的 store 设置为true，在 source 字段外单独存储一份。读取时不必在读取整 source 字段了。但是需要注意，应该避免使用 store 查询多个字段，因为 store 的存储在磁盘上不连续，ES在读取不同的 store 字段时，每个字段的读取均需要在磁盘上进行查询操作，而使用 source 字段可以一次性连续读取多个字段。 doc_values倒排索引可以提供全文检索能力，但是无法提供对排序和数据聚合的支持。doc_values 本质上是一个序列化的列式存储结构，适用于聚合（aggregations）、排序（Sorting）、脚本（scripts access to field）等操作。 默认情况下，ES几乎会为所有类型的字段存储doc_value，但是 text 或 text_annotated 等可分词字段不支持 doc values 。如果不需要对某个字段进行排序或者聚合，则可以关闭该字段的doc_value存储。 index控制倒排索引，用于标识指定字段是否需要被索引。默认情况下是开启的，如果关闭了 index，则该字段的内容不会被 analyze 分词，也不会存入倒排索引，即意味着该字段无法被搜索。 enabled一个 index 和 doc_value 的总开关，如果 enabled 设置为false，则这个字段将会仅存在于 source 中，其对应的 index 和 doc_value 都不会被创建。这意味着，该字段将不可以被搜索、排序或者聚合，但可以通过 source 获取其原始值。 term_vector在对文本进行 analyze 的过程中，可以保留有关分词结果的相关信息，包括单词列表、单词之间的先后顺序、单词在原文中的位置等信息。查询结果返回的高亮信息就可以利用其中的数据来返回。默认情况下，term_vector是关闭的，如有需要（如加速highlight结果）可以开启该字段的存储。 doc_values详细说明1.doc_values 的作用： 基于 lucene 的 solr 和 es 都是使用倒排索引实现快速检索的，也就是通过建立 “搜索关键词 ==&gt;文档ID列表” 的关系映射实现快速检索，但是倒排索引也是有缺陷的，比如我们需要字段值做一些排序、分组、聚合操作，lucene 内部会遍历提取所有出现在文档集合的排序字段，然后再次构建一个最终的排好序的文档集合list，这个步骤的过程全部维持在内存中操作，而且如果排序数据量巨大的话，非常容易就造成solr内存溢出和性能缓慢。 doc values 就是在构建倒排索引时，会对开启 doc values 的字段额外构建一个有序的 “document文档 ==&gt; field value“ 的列式存储映射，从而实现对指定字段进行排序和聚合时对内存的依赖，提升该过程的性能。默认情况下每个字段的 doc values 都是开启的，当然 doc values 也会耗费一定的磁盘空间。 另外 doc values 保存在操作系统的磁盘中，当 doc values 大于节点的可用内存，ES 可以从操作系统页缓存中加载或弹出，从而避免发生 JVM 内存溢出的异常，docValues 远小于节点的可用内存，操作系统自然将所有Doc Values存于内存中（堆外内存），有助于快速访问。 2.doc_values 与 source 的区别？使用 docvalue_fields 检索指定的字段？ post 提交到 ES 的原始 Json 文档都存储在 source 字段中，默认情况下，每次搜索的命中结果都包含文档 source，即使仅请求少量字段，也必须加载并解析整个 source 对象，而 source 每次使用时都必须加载和解析，所以使用 source 非常慢。为避免该问题，当我们只需要返回相当少的支持 doc_values 的字段时，可以使用 docvalue_fields 参数获取选定字段的值。 doc values 存储与 _source 相同的值，但在磁盘上基于列的结构中进行了优化，以进行排序和汇总。由于每个字段都是单独存储的，因此 Elasticsearch 仅读取请求的字段值，并且可以避免加载整个文档 _source。通过 docvalue_fields 可以从建好的列式存储结果中直接返回字段值，毕竟 source 是从一大片物理磁盘去，理论上从 doc values 处拿这个字段值会比 source 要快一点，页面抖动少一点。 3.doc values 通过牺牲一定的磁盘空间带来的好处主要有两个： 节省内存提升排序，分组等聚合操作的性能 4.如何在 ES 中使用 doc values？ （1）我们首先关注如何激活 doc values，只要开启 doc values 后，排序，分组，聚合的时候会自动使用 doc values 提速。在 ES 中，doc values 默认是开启的，比较简单暴力，可以酌情关闭一些不需要使用 doc values 的字段，以节省磁盘空间，只需要设置 doc_values 为 false 就可以了。 示例如下：”session_id”:{“type”:”string”,”index”:”not_analyzed”,”doc_values”:false} （2）使用 docvalue_fields 的检索指定的字段： 123456789GET test/_search{ \"query\": { \"match\": { \"disk_uuid\": \"test\" } }, \"docvalue_fields\": [\"util\", \"svctm\"]} 使用方式 123456GET product/_search{ \"stored_fields\": [\"name\",\"tags\",\"price\"], \"docvalue_fields\": [], \"_source\": []} 总结：什么场景可以去掉_source?什么场景可以去掉doc_values?去掉_source原数据过大、指标类数据 去掉doc values不需要用户聚合、排序 数据写入过程关键词Document（文档）: 文档是存储在elasticsearch中的一个JSON文件，相当于关系数据库中表的一行数据。 Shard（分片）：索引数据可以拆分为较小的分片，每个分片放到不同的服务器上，提高并发能力。Lucene 中的 Lucene index 相当于 ES 的一个 shard。 Segments（段）: 分片由多个segments组成，每个segments都是一个独立的倒排索引，且具有不变性，segment 提供了搜索功能。 Transaction Log（translog，事务日志）：ES使用translog来记录index,delete,update,bulk请求，保障数据不丢失，如果Elasticsearch需要恢复数据可以从translog中读取。每个分片对应一个translog文件。 Commit point（提交点）：记录着所有已知的segment。 Lucene index ：由一堆 Segment 的集合加上一个Commit point组成。 写入模型ES 的任意节点可作为写入请求的协调节点，接收用户请求，协调节点先将写入请求 hash 至分片粒度并先转发对应主分片写入，主分片写入成功再转发至从分片，主从分片均写入完毕经协调节点返回客户端成功。写操作一般会经历三种节点：协调节点、主分片所在节点、从分片所在节点。 如图NODE1可视为协调节点，协调节点接收到请求后，确定写入的文档属于分片0，于是将请求转发到分片0的主分片所在的节点NODE3， NODE3完成写入后，再将请求转发给分片0所属的从分片所在的节点NODE1和NODE2 待所有从分片写入成功后，NODE3则认为整个写入成功并将结果反馈给协调节点，协调节点再将结果返回客户端。 写⼊时设置副本，有副本的索引创建操作，然后写⼊；如果是写⼊后，再设置副本，则此时采⽤的是复制操作ES为了减少磁盘IO保证读写性能，⼀般是每隔⼀段时间（⽐如5分钟）才会把Lucene的segment写⼊磁盘持久化在每个shard中，写⼊流程分为两部分，先写⼊Lucene，后写⼊Translog 写入流程优化translog flush间隔调整这是影响ES写⼊的最⼤因素。translog flush操作是将内存中的数据写⼊磁盘，典型的IO操作。ES默认为了写⼊的可靠性，采⽤的配置 为:index.translog.durability: request 每个写⼊请求都flflush到磁盘，确保写操作是可靠的 如果系统接受⼀定概率的数据丢失，可设置为根据固定周期和固定⼤⼩的flush操作，⽐如 index.translog.durability: async index.translog.sync_interval: 120s or index.translog.flflush_threshold_size: 1024mb 设置translog的flush频率可以控制可靠性，要么是按请求，每次请求都flush；要么是按时间，每隔⼀段时间flush⼀次，⼀般为了性能考虑，会设置为每隔5秒或者1分钟flush⼀次；flush间隔时间越⻓，可靠性就会越低。 索引刷新间隔refresh_interval每次索引的refresh会产⽣⼀个新的Lucene段，增⼤refresh周期，可减少段的创建以及后续的Force Merge操作 段合并优化segment merge操作对系统I/O和内存占⽤都⽐较⾼，需要调整参数，改变⾏为。（这点⽤的少） indexing bufferindexing buffer在为doc建⽴索引时使⽤，当缓冲满时会刷⼊磁盘，⽣成⼀个新的segment，这是除了refresh_interval刷新索引之外，另⼀个⽣成新segment的机会。 indices.memory.index_buffer_size indices.memory.min_index_buffer_size indices.memory.max_index_buffer_size 当执⾏⼤量的索引操作时，indices.memory.index_buffer_size的默认设置可能不够，这和可⽤堆内存、单节点上的 shard数量相关，可以考虑适当增⼤该值 使⽤bulk请求批量写效率更⾼，每个请求最好避免超过⼏⼗兆，避免给集群带来压⼒ bulk线程池和队列建⽴索引过程属于CPU密集型任务，应该使⽤固定⼤⼩的线程池配置，来不及处理的任务放⼊队列。线程池最⼤线程数量应配置为 CPU核⼼数+1，队列可以适当的增加，但要控制⼤⼩，过⼤的队列会导致较⾼的GC压⼒ 并发执⾏bulk请求bulk写请求是个⻓任务，为了给系统增加⾜够的写⼊压⼒，写⼊过程应该多个客户端、多线程地并⾏执⾏，直⾄CPU打满。 ⾃动⽣成Doc ID如果写⼊doc时指定了id，则ES会先尝试读取原来doc的版本号以判断是否需要更新，这会涉及⼀次读取磁盘的操作。总结下来两点： 减少磁盘的IO操作 ⾃动⽣成的ID具有⼀定的规律，有利于FST的压缩。 Lucene从4.0版本开始⼤量使⽤FST（Finite State Transducer）；具有两个优点：1）空间占⽤⼩。通过对词典中单词前缀和后缀的重复利⽤，压缩了存储空间；2）查询速度快，O(len(str))的查询时间复杂度 调整字段Mappings减少字段数量、对于不需要建⽴索引的字段，不写⼊ES（ES+HBase的组合使⽤） 将不需要建⽴索引的字段index属性设置为not_analyzed或no。对字段不分词，或者不索引，可以减少很多运算操作，降低CPU使⽤ 减少字段内容⻓度 使⽤不同的分词器，不同的分词器在索引过程中运算复杂度也有较⼤的差异 调整_source字段_source字段⽤于存储doc原始数据，对于部分不需要存储的字段，可以通过includes、excludes过滤。实际环境，⼀般不做调整 禁⽤_all字段ES 5.x _all默认开启，ES 6.x _all字段默认为不启⽤。_all字段中包含所有字段分词后的关键词，作⽤是可以在搜索的时候不指定特定字段，从所有字段中检索。ES 6.x默认禁⽤_all字段主要有以下⼏点原因： 由于需要从其他的全部字段复制所有字段值，导致_all字段占⽤⾮常⼤的空间 _all字段有⾃⼰的分析器，在进⾏某些查询时，结果不符合预期 由于数据重复引起的额外建⽴索引的开销 想要调试时，其内容不容易检查 有些⽤户甚⾄不知道存在这个字段，导致了查询混乱 可以通过mapping中将enabled设置为false来禁⽤_all字段，禁⽤_all字段可以明显降低对CPU和I/O的压⼒。 对Analyzed的字段禁⽤NormsNorms⽤于在搜索时计算doc的评分，如果不需要评分，则可以将其禁⽤： “title”: {“type”: “text”, “norms”: {“enabled”: false}} index_options设置index_options⽤于控制在建⽴倒排索引过程中，哪些内容会被添加到倒排索引中；例如doc数量、词频、positions、offsets等，优化这些设置可以⼀定程度上降低索引过程中的运算任务（较少使用）。 数据查询过程查询流程示意图查询模型查询优化为⽂件系统cache预留⾜够的内存命中cache可以降低对磁盘的直接访问频率，搜索很依赖对系统cache的命中；如果某个请求需要从磁盘读取数据，则⼀定会产⽣相对较⾼的延迟。应该⾄少为系统cache预留⼀半的可⽤物理内存，更⼤的内存有更⾼的cache命中率。 使⽤更快的硬件搜索性能在⼀般情况下更多的是在于IO能⼒，使⽤SSD会⽐旋转类存储介质好的多。如果搜索类型属于计算⽐较多，则可以考虑使⽤更快的CPU。 ⽂档模型为了让搜索时的成本更低，⽂档应该合理建模。特别是应该避免join操作，嵌套（nested）会使查询慢⼏倍，⽗⼦（parent-child）关系可能使查询慢数百倍，因此最好通过⾮规范化（denormalizing）⽂档来回答相同的问题，则可以显著提⾼搜索速度。 预索引数据例如根据价格区间进行group，以及计算数量，则可以增加price_range字段 PUT index/type/1 { “designation”: “spoon”, “price”: 13 } 富化为 PUT index/type/1 { “designation”: “spoon”, “price”: 13, “price_range”: “10 - 100” } 优化⽇期搜索在使⽤⽇期范围检索时，使⽤now的查询通常不能缓存，因为匹配到的范围⼀直在变化。但是从⽤户体验的⻆度来看，切换到⼀个完整的⽇期通常是可以接受的，这样可以更好地利⽤查询缓存。因为使⽤now形成的⽇期是⼀个⾮固定的值，每次查询从当前now往前推算形成的时间间隔都会是⼀个崭新的值，因此⽤不到缓存。","categories":[],"tags":[]},{"title":"FST构建过程","slug":"TreasureBox/Elasticsearch/学习笔记/5.Luence/3.FST构建过程","date":"2023-03-05T02:47:36.392Z","updated":"2023-04-28T09:25:47.290Z","comments":true,"path":"2023/03/05/treasurebox/elasticsearch/xue-xi-bi-ji/5.luence/3.fst-gou-jian-guo-cheng/","link":"","permalink":"http://example.com/2023/03/05/treasurebox/elasticsearch/xue-xi-bi-ji/5.luence/3.fst-gou-jian-guo-cheng/","excerpt":"","text":"FST构建过程FST表示有限状态集 FSM(Finle State machine)有限状态机表示有限个状态(State)集合以及这些状态之间转移和动作的数学模型，其中一个状态被标记为开始状态，0个或更多的状态被标记为final状态。 要素： 有限个状态 同一时间只能处于同一个状态 不同状态可以互相转换 状态是无序 例如： 睡觉——&gt;工作——&gt;卫生间——&gt;吃饭 睡觉——&gt;吃饭——&gt;卫生间——&gt;工作 睡觉——&gt;卫生间——&gt;工作——&gt;吃饭 FSA 有限状态接收机要素： 确定性：在任何给定状态下，对于任何输入，最多只能遍历一个transition 非循环：不可能重复遍历同一个状态 Final唯一性：当且仅当有限状态机在输入序列的末尾处于最终状态时，才接受特定输入序列 输入msbtech 输入msn 输入wltech FST 有限状态转换机FST最重要的功能是可以实现key到value的映射，相当于HashMa p&lt;key, value&gt;，FST的查询速度要比HashMap要慢一些，但是FST的内存消耗要比HashMap少很多，FST在Lucene中大量使用，例如：倒排索引存储，同义词典的存储，搜索关键词等 例如给定一些词项： msb/10 msbtech/5 msn/2 wltech/8 wth/16 Lucene源码解析FST构建过程","categories":[],"tags":[]},{"title":"压缩算法","slug":"TreasureBox/Elasticsearch/学习笔记/5.Luence/2.压缩算法","date":"2023-03-05T02:47:02.265Z","updated":"2023-04-28T09:25:47.289Z","comments":true,"path":"2023/03/05/treasurebox/elasticsearch/xue-xi-bi-ji/5.luence/2.ya-suo-suan-fa/","link":"","permalink":"http://example.com/2023/03/05/treasurebox/elasticsearch/xue-xi-bi-ji/5.luence/2.ya-suo-suan-fa/","excerpt":"","text":"posting list压缩算法FOR压缩算法RBM压缩","categories":[],"tags":[]},{"title":"mac","slug":"TreasureBox/Elasticsearch/本地调试ElasticSearch/mac","date":"2023-03-02T13:39:56.058Z","updated":"2023-04-28T09:25:47.263Z","comments":true,"path":"2023/03/02/treasurebox/elasticsearch/ben-di-diao-shi-elasticsearch/mac/","link":"","permalink":"http://example.com/2023/03/02/treasurebox/elasticsearch/ben-di-diao-shi-elasticsearch/mac/","excerpt":"","text":"mac环境运行linux参考链接：https://www.elastic.co/cn/blog/how-to-debug-elasticsearch-source-code-in-intellij-idea 首先clone ElasticSearch源码到本地1234git clone https://github.com/elastic/elasticsearch.gitcd elasticsearch git checkout --track origin/6.6 安装IntelliJ IDEA 软件 安装Java并配置java路径 elasticsearch6.6 可以基于java11构建，但是也需要java9的部分功能，所以需要安装java9和java11. java9:https://www.oracle.com/java/technologies/javase/javase9-archive-downloads.html java11:https://www.oracle.com/java/technologies/downloads/#java11 123456789101112# 打开文件vim ～/.bash_profile# 加入java安装路径JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.2.jdk/Contents/Home export JAVA_HOMEJAVA9_HOME=/Library/Java/JavaVirtualMachines/jdk-9.0.4.jdk/Contents/Home export JAVA9_HOME退出文件然后输入：source ～/.bash_profile 使用IntelliJ IDEA 打开elasticsearch源码 初始化gradlew，详细步骤可以参考es代码中的CONTRIBUTING.md文件12345#在终端中执行./gradlew idea./gradlew run --debug-jvm 然后等待片刻，如果遇到这个报错，说明8000端口被占用，需要开放端口。 下图表示运行成功 这时在浏览器上访问http://localhost:9200/并不能访问，需要在idea上配置debug模式 新建一个remote连接： 修改名称和端口 看到如下日志代表成功 在浏览器上输入http://localhost:9200/即可访问![image-20230302231400414](mac/images/image-20230302231400414.png) 源码文件说明 docs 项目文件 distribution 分发 libs 用于构建项目其他部分的库。这些是注定的 modules 模块 plugins 插件 qa 质量保证 server 服务器组件，包含所有模块和插件 test 测试框架和测试工具 x-pack ES其余部分集成的商业许可码 Gradle Build 使用gradle构建和打包 Configurations Gradle依赖的配置","categories":[],"tags":[]},{"title":"elsaticsearch操作手册","slug":"TreasureBox/Elasticsearch/操作手册/elsaticsearch操作手册","date":"2023-02-24T06:56:57.159Z","updated":"2023-04-28T09:25:47.266Z","comments":true,"path":"2023/02/24/treasurebox/elasticsearch/cao-zuo-shou-ce/elsaticsearch-cao-zuo-shou-ce/","link":"","permalink":"http://example.com/2023/02/24/treasurebox/elasticsearch/cao-zuo-shou-ce/elsaticsearch-cao-zuo-shou-ce/","excerpt":"","text":"ES操作手册 集群 集群异常情况GET _cluster/allocation/explain 可选参数： include_disk_info：bool，可选，如果为true，返回有关磁盘使用情况和分片大小的情况，默认为false。 include_yes_decisions：可选，布尔值）如果true，则在解释中返回YES决定 12# 查看集群状态异常GET _cluster/allocation/explain 集群配置GET /_cluster/settings 查询参数 flat_settings:（可选，布尔值）如果true，则以平面格式返回设置。默认为 false. include_defaults:（可选，布尔值）如果true，返回所有默认集群设置。默认为false. master_timeout:（可选，时间单位）等待连接到主节点的时间。如果在超时到期之前未收到响应，则请求失败并返回错误。默认为 30s. timeout:（可选，时间单位）等待响应的时间。如果在超时到期之前未收到响应，则请求失败并返回错误。默认为30s. 集群健康度：GET /_cluster/health/&lt;target&gt; 集群state：GET _cluster/state 集群stats： GET _cluster/stats GET /_cluster/stats/nodes/&lt;node_filter&gt; 更新集群配置 PUT _cluster/settings，persistent表示永久更新，transient表示临时更新 修改集群恢复时每秒的大小 123456PUT /_cluster/settings{ \"persistent\" : { \"indices.recovery.max_bytes_per_sec\" : \"50mb\" }} 修改集群允许通配符删除 12345678910# 修改集群配置，允许使用通配符删除PUT _cluster/settings{ \"persistent\":{ \"action.destructive_requires_name\":false }, \"transient\":{ \"action.destructive_requires_name\":false }} 节点功能查询，获取集群中每个节点的作用 GET /_nodes/usage GET /_nodes/&lt;node_id&gt;/usage GET /_nodes/usage/&lt;metric&gt; GET /_nodes/&lt;node_id&gt;/usage/&lt;metric&gt; 节点热线程：获取每个选定节点上的热线程情况 GET /_nodes/hot_threads GET /_nodes/&lt;node_id&gt;/hot_threads 查询参数： ignore_idle_threads：可选，布尔值，如果为真，则过滤掉已知空闲县城 **interval**：（可选，时间单位）对线程进行第二次采样的时间间隔。默认为500ms. **snapshots**：（可选，整数）线程堆栈跟踪的样本数。默认为 10. **threads**：（可选，整数）指定要为其提供信息的热线程数。默认为3. **master_timeout**：（可选，时间单位）等待连接到主节点的时间。如果在超时到期之前未收到响应，则请求失败并返回错误。默认为 30s. **timeout：（可选，时间单位）等待响应的时间。如果在超时到期之前未收到响应，则请求失败并返回错误。默认为30s.type**（可选，字符串）要采样的类型。可用选项有block、cpu和 wait。默认为cpu. 1234# 示例GET /_nodes/hot_threads GET /_nodes/nodeId1,nodeId2/hot_threadsGET /_nodes/hot_threads 查询节点信息：检索一个或集群全部节点信息。 GET /_nodes GET /_nodes/&lt;node_id&gt; GET /_nodes/&lt;metric&gt; GET /_nodes/&lt;node_id&gt;/&lt;metric&gt; metric可选的参数 **aggregations**：有关可用聚合类型的信息。 **http**：有关此节点的 HTTP 接口的信息。 **indices**：与索引相关的节点级配置： total_indexing_buffer: 此节点上索引缓冲区的最大大小。 **ingest**：有关摄取管道和处理器的信息。 **jvm**：JVM 信息，包括其名称、版本和配置。 **os**：操作系统信息，包括其名称和版本。 **plugins**：有关每个节点安装的插件和模块的详细信息。以下信息适用于每个插件和模块： name: 插件名称 version: 构建插件的 Elasticsearch 版本 description: 插件用途的简短描述 classname: 插件入口点的完全限定类名 has_native_controller: 插件是否有一个本地控制器进程 **process**：进程信息，包括数字进程 ID。 **settings**：列出文件中定义的所有正在使用的节点设置elasticsearch.yml。 **thread_pool**：有关每个线程池的配置信息。 **transport**：有关节点传输接口的信息。 验证节点是否可以删除POST /_internal/prevalidate_node_removal 此 API 检查尝试从集群中删除指定节点是否可能成功。对于没有未分配分片的集群，删除任何节点都被认为是安全的，这意味着删除节点很可能会成功。如果集群的red集群健康状况为 ，它会验证节点的移除不会冒移除未分配分片的最后剩余副本的风险。 响应包括删除指定节点的整体安全性，以及每个节点的详细响应。响应的特定于节点的部分还包括有关为什么删除该节点可能不成功的更多详细信息。 节点重新加载安全设置 节点统计 挂起的集群任务 远程集群信息 任务管理 投票配置排除 创建或更新所需的节点 获取所需的节点 删除节点 获取剩余的节点 分片 查看索引分片:GET _cat/shards?v 索引 查看所有索引123456789101112131415161718# 查看索引按照大小排序GET _cat/indices?s=store.size:desc&amp;v#创建索引curl -XPUT \"http://127.0.0.1:9200/test1/\" -d'{ \"settings\":{ \"number_of_shards\" : \"1\", \"number_of_replicas\" : \"1\" }}' -H\"content-type:application/json\"#删除索引DELETE test# 批量删除索引DELETE test_* 创建索引指定mapping1curl -XPUT \"127.0.0.1:9200/test1\" -H\"content-type:application/json\" -d'{\"mappings\":{\"properties\":{\"field1\":{\"type\":\"keyword\",\"copy_to\":\"field_all\"},\"field2\":{\"type\":\"text\"},\"field_all\":{\"type\":\"text\"}}}}' 查看索引mapping12345678910111213141516171819202122232425262728293031323334353637383940$ curl -XGET '127.0.0.1:9200/test/_mapping?pretty'# ignore_above 表示最长存储的长度，超过时会被丢弃{ \"test\" : { \"mappings\" : { \"properties\" : { \"desc\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } }, \"name\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } }, \"price\" : { \"type\" : \"long\" }, \"tags\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } } } } }} 文档操作 插入数据123456curl -XPOST \"http://127.0.0.1:9200/test/_doc\" -d'{ \"name\": \"iphone11\", \"desc\": \"256G\", \"price\": 20, \"tags\":[\"shouji\", \"fangshui\", \"nfc\"]}' -H\"content-type:application/json\" 修改数据1curl -XPOST \"http://127.0.0.1:9200/test/_update/1\" -d'{\"doc\":{\"name\": \"iphone14\"}}' -H\"content-type:application/json\"","categories":[],"tags":[]},{"title":"算法","slug":"TreasureBox/数据结构/算法","date":"2023-02-11T13:24:29.470Z","updated":"2023-04-28T09:25:47.099Z","comments":true,"path":"2023/02/11/treasurebox/shu-ju-jie-gou/suan-fa/","link":"","permalink":"http://example.com/2023/02/11/treasurebox/shu-ju-jie-gou/suan-fa/","excerpt":"","text":"递归递归：在函数中自己调用自身，类似于压栈 递归三要素： 递归边界：一定要有终止条件 逻辑处理 调用自身 状态清理 例如： 斐波那契 某个数的阶乘 分治：Divde &amp; Conquer分而治之：将一个大问题依次解决，类似于庖丁解牛。 经典算法：二分查找、快排 贪心算法简单来说：问题能够分解成子问题来解决，子问题的最优解能递推到最终的最优解，这样子问题最优解称为最优子结构。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。 广度优先算法Breadth First Search 在树（图/状态集）中查找特定节点 每层推进的过程中没有重复的，先扫描某个节点时，将该节点的所有子节点全部加入，以作为下次继续推进。 又称为地毯式搜索 深度优先Depth First Search 每层推进的过程中没有重复的，先扫描某个节点时，将某个节点一直扫描到叶子节点之后，再扫描该节点的其他节点。 二分查找 单调递增或递减 存在上下界 能够通过索引访问 位运算什么是位运算：程序中所有数在计算机内存中都是以二进制的形式储存的。位运算说白了就是对证书在内存中的二进制位进行操作。比如：and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子：6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它的二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）： 1110 AND 1011 &gt;&gt; 0010(b)——&gt; 2(d) 由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。 符号 描述 运算规则 &amp; 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同时为0，相异为1 - 取反 0变1，1变0 &lt;&lt; 左移 各二进制位全部左移若敢为，高位丢弃，低位补0 &gt;&gt; 右移 各二进制位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方式不一样，有的补符号位(算数右移)，有的补0（逻辑右移） 动态规划(Dynamic Programming)动态规划分为4个思路： 递归+记忆化 ——&gt; 递推 状态的定义：opt[n]，dp[n]，fib[n] 状态转移方程：opt[n] = best_of(opt[n-1],opt[n-2],…) 最优子结构 先规划最基础的一步怎么执行，然后逐层反推，得到最优的方案 DP vs 回溯 vs 贪心 回溯（递归）—— 重复计算，尽可能考虑重复计算问题，减少重复计算 贪心 —— 永远局部最优 DP —— 记录局部最优子结构 / 多种记录值 并查集并查集(union &amp; find)是一种树形的数据结构，用于处理一些不交集(Disjoint Sets)的合并及查询问题 Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一个子集 union：将两个子集合并为同一个集合。 示例，给定一串数组1 2 3 4 5 6 7 8 拆分为1 2 5 6 8 3 4 7子集形式 生活中的例子 小弟——&gt; 老大 帮派识别 两种优化方式：并查集的深度成为rank 将rank低的合并到rank高的并查集中 进行读路径优化：将d c b a a路径全部压缩为d a,c a,b a,a a Cache 缓存 记忆 钱包——储物柜 代码模块 LRU Cache Least recently used（最近最少使用） Double LinkedList O(1)查询，查询最近的数据是O(1) O(1)修改 LFU Cache LFU ——least frequently used 最近最不常用页面置换算法 LRU——least recently used 最近最少使用页面置换算法 Bloom Filter 布隆过滤器一个很长的二进制向量和一个映射函数 布隆过滤器可以用于检索一个元素是否在一个集合中 他的优点是空间效率和查询效率远远超过一般算法，缺点是有一定的误识别率和删除困难 误识别率：数据存在时会出现误判，不存在时一定不存在 删除困难：哈希之后的结果不好删除，可能会误删其他元素的值 案例： 比特币 分布式系统（Map-Reduce） 现实中的算法问题适用于找房子，找女朋友，吃饭等等选择问题。 假设1年找2个女朋友， 如果能选择之前的，O(n) 如果不能后悔，则用37%原则 其他： Priority Queue 一个任务的密度=重要程度/完成时间 Kelly Formula 凯利公式 Game Theory 博弈论 代码模版 递归 DFS：深度优先遍历 BFS：广度优先遍历 二分查找 DP方程 练习和切题持续练习+精深练习（刻意练习） 除了做熟悉的题和会做的题之外，去刻意练习自己不熟悉的算法和数据结构，不要为了切题而切题 做过的题目后续要返回再复习 面试答题四件套 Clarification 询问题目细节、边界条件、可能的极端错误 Possible Solution 所有可能的解法都和面试官沟通一下 时间复杂度 &amp; 空间复杂度 最优解 Coding 写代码 Test Cases 测试用例 沟通和交流很重要 最后常学常新","categories":[],"tags":[]},{"title":"trie","slug":"TreasureBox/数据结构/2.trie","date":"2023-02-11T12:15:52.181Z","updated":"2023-04-28T09:25:47.101Z","comments":true,"path":"2023/02/11/treasurebox/shu-ju-jie-gou/2.trie/","link":"","permalink":"http://example.com/2023/02/11/treasurebox/shu-ju-jie-gou/2.trie/","excerpt":"","text":"Trie树trie的数据结构trie树，即字典树有称为单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用于统计和排序大量的字符串（但不限于字符串），所以经常被搜索引擎系统用于文本词频统计。 它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。 trie的核心思想Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 trie的基本性质 根节点不包含字符，除根节点外每个节点都只包含一个字符。 从根节点到某一节点，路径上经过的字符串连接起来，为该节点对应的字符串 每个节点的所有子节点包含的字符都不相同 树&amp;二叉树&amp;二叉搜索树 trie结构类似生活中倒立的树。 树最头上的节点叫做头结点，左边任何一个树叫做左子树，右边叫右子树。 其中节点称为父节点，同一个父节点的子节点称为兄弟节点。 子节点距离头节点的距离为层级，头节点所在的层级为level0. 二叉搜索树(Binary Search Tree)：也称为二叉搜索树、有序二叉树(Ordered binary tree)、排序二叉树（Sorted binary tree），是指一颗空树或者具有下列性质的二叉树： 左子树上所有结点的值均小于它的根节点的值。 右子树上所有结点的值均大于它的根结点的值。 Recursively，左、右子树也分别为二叉查找树。 二叉树遍历 前序遍历：根左右 中序遍历：左根右 后序遍历：左右根","categories":[],"tags":[]},{"title":"code review总结","slug":"TreasureBox/技术文档/code review总结","date":"2022-12-29T15:00:53.786Z","updated":"2023-04-28T09:25:47.185Z","comments":true,"path":"2022/12/29/treasurebox/ji-zhu-wen-dang/code-review-zong-jie/","link":"","permalink":"http://example.com/2022/12/29/treasurebox/ji-zhu-wen-dang/code-review-zong-jie/","excerpt":"","text":"前言作为公司代码委员会golang分会的理事，作为(还未任命)的技术leader，我review了很多代码，看了很多别人的review评论。发现，即使是委员会的委员，code review的水品，写出好代码的水品，不乏缺乏根本性的思路、设计原则的同学。特此，想分享一下我的很多理念和思路。 为什么技术人员包括leader都要做code review​ 谚语曰: ‘Talk Is Cheap, Show Me The Code’。知易行难，知行合一难。嘴里要讲出来总是轻松，把别人讲过的话记住，组织一下语言，再讲出来，很容易。绝知此事要躬行。设计理念你可能道听途说了一些，以为自己掌握了，但是你会做么？有能力去思考、改进自己当前的实践方式和实践中的代码细节么？不客气地说，很多人仅仅是知道并且认同了某个设计理念，进而产生了一种虚假的安心感—自己的技术并不差。但是，他根本没有去实践这些设计理念，甚至根本实践不了这些设计理念，从结果来说，他懂不懂这些道理/理念，有什么差别？变成了自欺欺人。 ​ 代码，是设计理念落地的地方，是技术的呈现和根本。同学们可以在review过程中做到落地沟通，不再是空对空的讨论，可以在实际问题中产生思考的碰撞，互相学习，大家都掌握团队里积累出来最好的实践方式！当然，如果leader没时间写代码，仅仅是review代码，指出其他同学某些实践方式不好，要给出好的实践的意见，即使没亲手写代码，也是对最佳实践要有很多思考。 为什么同学们要在review中思考和总结最佳实践我这里先给一个我自己的总结：所谓架构师，就是掌握大量设计理念和原则、落地到各种语言及附带工具链（生态）下的实践方法、垂直行业模型理解，定制系统模型设计和工程实践规范细则。进而控制30+万行代码项目的开发便利性、可维护性、可测试性、运营质量。 接着，有一些同学就说了，张小龙老板是厉害的技术人，他是这样的人么？阿里巴巴的王坚是厉害的CTO，他懂golang、c++、java么？接着，我这里拓展讲解一下，我们和他们的不同。我的总结，厉害的技术人，主要可以分为下面几个方向： 奇技淫巧 掌握很多技巧，以及发现技巧一系列思路，比如很多编程大赛，比的就是这个。但是，这个对工程，用处好像并不是很大。 领域奠基 比如约翰*卡马克，他创造出了现代计算机图形高效渲染的方法论。不论如果没有他，后面会不会有人发明，他就是第一个发明了。1999年，卡马克登上了美国时代杂志评选出来的科技领域50大影响力人物榜单，并且名列第10位。但是，类似的殿堂级位置，没有几个，不够大家分，没我们的事儿。 理论研究 八十年代李开复博士坚持采用隐含马尔可夫模型的框架，成功地开发了世界上第一个大词汇量连续语音识别系统Sphinx。我辈工程师，好像擅长这个的很少。 产品成功 小龙哥，不解释，同学们应该也做不到。 最佳实践 这个是大家都可以做到，按照上面架构师的定义。在这条路上走得好，就能为任何公司组件技术团队，组织建设高质量的系统。 从上面的讨论中，可以看出，我们普通工程师的进化之路，就是不断打磨最佳实践方法论、落地细节。 代码变坏的根源在讨论什么代码是好代码之前，我们先讨论什么是不好的。计算机是人造的学科，我们自己制造了很多问题，进而去思考解法。 重复的代码123456789101112131415161718192021// BatchGetQQTinyWithAdmin 获取QQ uin的tinyID, 需要主uin的tiny和登录态// friendUins 可以是空列表, 只要admin uin的tinyfunc BatchGetQQTinyWithAdmin(ctx context.Context, adminUin uint64, friendUin []uint64) ( adminTiny uint64, sig []byte, frdTiny map[uint64]uint64, err error) { var friendAccountList []*basedef.AccountInfo for _, v := range friendUin { friendAccountList = append(friendAccountList, &amp;basedef.AccountInfo{ AccountType: proto.String(def.StrQQU), Userid: proto.String(fmt.Sprint(v)), }) } req := &amp;cmd0xb91.ReqBody{ Appid: proto.Uint32(model.DocAppID), CheckMethod: proto.String(CheckQQ), AdminAccount: &amp;basedef.AccountInfo{ AccountType: proto.String(def.StrQQU), Userid: proto.String(fmt.Sprint(adminUin)), }, FriendAccountList: friendAccountList, } 因为最开始协议设计得不好，第一个使用接口的人，没有类似上面这个函数的代码，自己实现了一个嵌入逻辑代码的填写请求结构结构体的代码，一开始，挺好的。但当有第二个人，第三个人干了类似的事情，我们将无法再重构这个协议，必须做到麻烦的向前兼容。而且每个同学，都要理解一遍上面这个协议怎么填，理解有问题，就触发bug。或者，如果某个错误的理解，普遍存在，我们就得找到所有这些重复的片段，都修改一遍。 当你要读一个数据，发现两个地方有，不知道该选择哪个。当你要实现一个功能，发现两个rpc接口、两个函数能做到，你不知道选哪一个。你有面临过这样的’人生难题’么？其实怎么选并不重要了，你写的这个代码已经在走向shit的道路上迈出了坚实的一步。 但是，A little copying is better than a little dependency。这里提一嘴，不展开。 这里，我必须额外说一句。大家使用trpc。感觉自己被鼓励’每个服务搞一个git’。那，你这个服务里访问db的代码，rpc的代码，各种可以复用的代码，是用的大家都复用的git下的代码么？每次都重复写一遍，db字段细节改了，每个使用过db的server对应的git都改一遍？这个通用git已经写好的接口应该不知道哪些git下的代码因为自己不向前兼容的修改而永远放弃了向前不兼容的修改？ 早期有效的决策不再有效很多时候，我们第一版代码写出来，是没有太大的问题的。比如，下面这个代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Update 增量更新func (s *FilePrivilegeStore) Update(key def.PrivilegeKey, clear, isMerge bool, subtract []*access.AccessInfo, increment []*access.AccessInfo, policy *uint32, adv *access.AdvPolicy, shareKey string, importQQGroupID uint64) error { // 获取之前的数据 info, err := s.Get(key) if err != nil { return err } incOnlyModify := update(info, &amp;key, clear, subtract, increment, policy, adv, shareKey, importQQGroupID) stat := statAndUpdateAccessInfo(info) if !incOnlyModify { if stat.groupNumber &gt; model.FilePrivilegeGroupMax { return errors.Errorf(errors.PrivilegeGroupLimit, \"group num %d larger than limit %d\", stat.groupNumber, model.FilePrivilegeGroupMax) } } if !isMerge { if key.DomainID == uint64(access.SPECIAL_FOLDER_DOMAIN_ID) &amp;&amp; len(info.AccessInfos) &gt; model.FilePrivilegeMaxFolderNum { return errors.Errorf(errors.PrivilegeFolderLimit, \"folder owner num %d larger than limit %d\", len(info.AccessInfos), model.FilePrivilegeMaxFolderNum) } if len(info.AccessInfos) &gt; model.FilePrivilegeMaxNum { return errors.Errorf(errors.PrivilegeUserLimit, \"file owner num %d larger than limit %d\", len(info.AccessInfos), model.FilePrivilegeMaxNum) } } pbDataSt := infoToData(info, &amp;key) var updateBuf []byte if updateBuf, err = proto.Marshal(pbDataSt); err != nil { return errors.Wrapf(err, errors.MarshalPBError, \"FilePrivilegeStore.Update Marshal data error, key[%v]\", key) } if err = s.setCKV(generateKey(&amp;key), updateBuf); err != nil { return errors.Wrapf(err, errors.Code(err), \"FilePrivilegeStore.Update setCKV error, key[%v]\", key) } return nil} 现在看，这个代码挺好的，长度没超过80行，逻辑比价清晰。但是当isMerge这里判断逻辑，如果加入更多的逻辑，把局部行数撑到50行以上，这个函数，味道就坏了。出现两个问题： 1）函数内代码不在一个逻辑层次上，阅读代码，本来在阅读着顶层逻辑，突然就掉入了长达50行的isMerge的逻辑处理细节，还没看完，读者已经忘了前面的代码讲了什么，需要来回看，挑战自己大脑的cache尺寸。 2）代码有问题后，再新加代码的同学，是改还是不改前人写好的代码呢？要不要往里面填屎，堆屎山呢？出bug谁来背？这是一个灵魂拷问。 过早的优化这个大家听了很多了，这里不赘述。 对合理性没有苛求‘两种写法都ok，你随便挑一种吧’，’我这样也没什么吧’，这是我经常听到的话。 1234567891011121314151617181920// Get 获取IPfunc (i *IPGetter) Get(cardName string) string { i.l.RLock() ip, found := i.m[cardName] i.l.RUnlock() if found { return ip } i.l.Lock() var err error ip, err = getNetIP(cardName) if err == nil { i.m[cardName] = ip } i.l.Unlock() return ip} i.l.Unlock()可以放在当前的位置，也可以放在i.l.Lock()下面，做成defer。两种在最初构造的时候，好像都行。这个时候，很多同学态度就变得不坚决。实际上，这里必须是defer的。 1234567891011 i.l.Lock()defer i.l.Unlock()var err errorip, err = getNetIP(cardName)if err != nil { return \"127.0.0.1\"}i.m[cardName] = ipreturn ip 这样的修改，是极有可能发生的，它还是要变成defer，那，为什么不一开始就是defer，进入最合理的状态？不一开始就进入最合理的状态，在后续协作种，其他同学很可能犯错！ ##总是面向对象/总喜欢封装 我是软件工程科班出身。学的第一门编程预言是c++。教材是这本 。当时自己读完教材，初入程序设计之门，对于里面讲的’封装’，惊为天人，多么美妙的设计啊，面向对象，多么智慧的设计啊。但是，这些年来，我看到了大牛’云风’对于’毕业生使用mysql api就喜欢搞个class封装再用’的嘲讽；看到了各种莫名其妙的class定义；体会到了经常要去看一个莫名其妙的继承树，必须要把整个继承树整体读明白才能确认一个细小的逻辑分支；多次体会到了我需要辛苦地压抑住自己的抵触情绪，去细度一个自作聪明的被封装的代码，确认我的bug。除了UI类场景，我认为少用继承、多用组合。 1234567template&lt;class _PKG_TYPE&gt;class CSuperAction : public CSuperActionBase { public: typedef _PKG_TYPE pkg_type; typedef CSuperAction&lt;pkg_type&gt; this_type; ...} 这是sspp的代码。CSuperAction和CSuperActionBase，一会儿super，一会儿又base，Super和SuperBase是在怎样的两个抽象层次上，不通读代码，没人能读明白。我想确认任何细节，都要把多个层次的代码都通读了，有什么封装性可言？ 好，你说是作者没有把class name取得好。那，问题是，你能取得好么？一个刚入职的T1.2的同学能把class name、class树设计得好么？即使是对简单的业务模型，也需要无数次’坏’的对象抽象实践，才能培养出一个具有合格的class抽象能力的同学，这对于大型却松散的团队协作，不是破坏性的？已经有了一套继承树，想要添加功能就只能在这个继承树里添加，以前的继承树不再适合新的需求，这个继承树上所有的class，以及使用它们的地方，你都去改？不，是个正常人都会放弃，开始堆屎山。 封装，就是我可以不关心实现。但是，做一个稳定的系统，每一层设计都可能出问题。abi，总有合适的用法和不合适的用法，真的存在我们能完全不关心封装的部分是怎么实现的？不，你不能。bug和性能问题，常常就出现在，你用了错误的用法去使用一个封装好的函数。即使是android、ios的api，golang、java现成的api，我们常常都要去探究实现，才能把api用好。那，我们是不是该一上来，就做一个透明性很强的函数，才更为合理？使用者想知道细节，进来吧，我的实现很易读，你看看就明白，使用时不会迷路！对于逻辑复杂的函数，我们还要强调函数内部工作方式’可以让读者在大脑里想象呈现完整过程’的可显性，让使用者轻松读懂，有把握，使用时，不迷路！ 根本没有设计这个最可怕，所有需求，上手就是一顿撸，’设计是什么东西？我一个文件5w行，一个函数5k行，干不完需求？’从第一行代码开始，就是无设计的，随意地踩着满地的泥坑，对于旁人的眼光没有感觉，一个人独舞，产出的代码，完成了需求，毁灭了接手自己代码的人本该用来啪啪啪的夜晚~ 这个就不举例了，每个同学应该都能在自己的项目类发现这种代码。 必须形而上的思考常常，同学们听演讲，公开课，就喜欢听一些细枝末节的’干活’。这没有问题。但是，你干了几年活，学习了多少干货知识点？构建起自己的技术思考’面’，进入立体的’工程思维’，把技术细节和系统要满足的需求在思考上连接起来了么？当听一个需求的时候，你能思考到自己的code package该怎么组织，函数该怎么组织了么？我相信，在腾讯，大多数人没做到，不客气地说，即使是很多T4。 那，技术点要怎么和需求连接起来呢？答案很简单，你需要在时间里总结，总结出一些明确的原则、思维过程。思考怎么去总结，特别像是在思考哲学问题。从一些琐碎的细节中，由具体情况上升到一些原则、公理。同时，大家在接受原则时，不应该是接受和记住原则本身，而应该是结构原则，让这个原则在自己这里重新推理一遍，自己完全掌握这个原则的适用范围。 再进一步具体地说，对于工程最佳实践的形而上的思考过程，就是： 把工程实践中遇到的问题，从问题类型和解法类型，两个角度去归类，总结出一些有限适用的原则，就从点到了面。把诸多总结出的原则，组合应用到自己的项目代码中，就是把多个面结合起来构建了一套立体的最佳实践的方案。当你这套方案能适应30w+行代码的项目，超过30人的项目，你就架构师入门了！当你这个项目，是多端，多语言，代码量超过300w行，参与人数超过300人，代码质量依然很高，代码依然在高效地自我迭代，每天消除掉过时的代码，填充高质量的替换旧代码和新生的代码。恭喜你，你已经是一个很高级的架构师了！再进一步，你对某个业务模型有独到或者全面的理解，构建了一套行业第一的解决方案，结合刚才高质量实现的能力，实现了这么一个项目。没啥好说的，你已经是专家工程师了。级别再高，我就不了解了，不在这里讨论。 那么，我们要重头开始积累思考和总结？不，有一本书叫做&lt;unix编程艺术&gt;，我在不同的时期分别读了3遍，等一会，我讲一些里面提到的，我觉得在腾讯尤其值得拿出来说的原则。这些原则，正好就能作为code review时大家判定代码质量的准绳。但，在那之前，我得讲一下另外一个很重要的话题，模型设计。 model设计没读过oauth2.0 RFC，就去设计第三方授权登陆的人，终归还要再发明一个撇脚的oauth。 2012年我刚毕业，我和一个去了广州联通公司的华南理工毕业生聊天。当时他说他工作很不开心，因为工作里 不经常写代码，而且认为自己，有ACM竞赛金牌级的算法熟练度+对CPP代码的熟悉，写下一个个指针操作内存，什么程序写不出来，什么事情做不好。当时我觉得，挺有道理，编程工具在手，我什么事情做不了？ 现在，我会告诉他，复杂如linux操作系统、Chromium引擎、windows office，你做不了。原因是，他根本没进入软件工程的工程世界。不是会搬砖就能修出港珠澳大桥。但是，这么回答并不好，举证用的论据离我们太遥远了。见微知著。我现在会回答，你做不了，简单如一个权限系统，你知道怎么做么？堆积一堆逻辑层次一维展开的ifelse？简单如一个共享文件管理，你知道怎么做么？堆积一堆逻辑层次一维展开的ifelse？你联通有上完台服务器，你要怎么写一个管理平台？堆积一堆逻辑层次一维展开的ifelse？ 上来就是干，能实现上面提到的三个看似简单的需求？想一想，亚马逊、阿里云折腾了多少年，最后才找到了容器+Kubernetes的大杀器。这里，需要谷歌多少年在BORG系统上的实践，提出了优秀的服务编排领域模型。权限领域，有RBAC、DAC、MAC等等模型，到了业务，又会有细节的不同。如Domain Driven Design说的，没有良好的领域思考和模型抽象，逻辑复杂度就是n^2指数级的，你得写多少ifelse，得思考多少可能的if路径，来cover所有的不合符预期的情况。你必须要有Domain思考探索、model拆解/抽象/构建的能力。有人问过我，要怎么有效地获得这个能力？这个问题我没能回答，就像是在问我，怎么才能获得MIT博士的学术能力？我无法回答。唯一回答就是，进入某个领域，就是首先去看前人的思考，站在前人的肩膀上，再用上自己的通识能力，去进一步思考。至于怎么建立好的通识思考能力，可能得去常青藤读个书吧：）或者，就在工程实践中思考和锻炼自己的这个能力！ 同时，基于model设计的代码，能更好地适应产品经理不断变更的需求。比如说，一个calendar(日历)应用，简单来想，不要太简单！以’userid_date’为key记录一个用户的每日安排不就完成了么？只往前走一步，设计了一个任务，上限分发给100w个人，创建这么一个任务，是往100w个人下面添加一条记录？你得改掉之前的设计，换db。再往前走一步，要拉出某个用户和某个人一起要参与的所有事务，是把两个人的所有任务来做join？好像还行。如果是和100个人一起参与的所有任务呢？100个人的任务来join？不现实了吧。好，你引入一个群组id，那么，你最开始的’userid_date’为key的设计，是不是又要修改和做数据迁移了？经常来一个需求，你就得把系统推翻重来，或者根本就只能拒绝用户的需求，这样的战斗力，还好意思叫自己工程师？你一开始就应该思考自己面对的业务领域，思考自己的日历应用可能的模型边界，把可能要做的能力都拿进来思考，构建一个model，设计一套通用的store层接口，基于通用接口的逻辑代码。当产品不断发展，就是不停往模型里填内容，而不是推翻重来。这，思考模型边界，构建模型细节，就是两个很重要的能力，也是绝大多数腾讯产品经理不具备的能力，你得具备，对整个团队都是极其有益的。你面对产品经理时，就听取他们出于对用户体验负责思考出的需求点，到你自己这里，用一个完整的模型去涵盖这些零碎的点。 model设计，是形而上思考中的一个方面，一个特别重要的方面。接下来，我们来抄袭抄袭unix操作系统构建的实践为我们提出的前人实践经验和’公理’总结。在自己的coding/code review中，站在巨人的肩膀上去思考。不重复地发现经典力学，而是往相对论挺进。 UNIX设计哲学不懂Unix的人注定最终还要重复发明一个撇脚的Unix。–Henry Spenncer, 1987.11 下面这一段话太经典，我必须要摘抄一遍(自《UNIX编程艺术》)：“工程和设计的每个分支都有自己的技术文化。在大多数工程领域中，就一个专业人员的素养组成来说，有些不成文的行业素养具有与标准手册及教科书同等重要的地位(并且随着专业人员经验的日积月累，这些经验常常会比书本更重要)。资深工程师们在工作中会积累大量的隐性知识，他们用类似禅宗’教外别传’的方式，通过言传身教传授给后辈。软件工程算是此规则的一个例外：技术变革如此之快，软件环境日新月异，软件技术文化暂如朝露。然而，例外之中也有例外。确有极少数软件技术被证明经久耐用，足以演进为强势的技术文化、有鲜明特色的艺术和世代相传的设计哲学。“ 接下来，我用我的理解，讲解一下几个我们常常做不到的原则。 Keep It Simple Stuped!KISS原则，大家应该是如雷贯耳了。但是，你真的在遵守？什么是Simple？简单？golang语言主要设计者之一的Rob Pike说’大道至简’，这个’简’和简单是一个意思么？ 首先，简单不是面对一个问题，我们印入眼帘第一映像的解法为简单。我说一句，感受一下。”把一个事情做出来容易，把事情用最简单有效的方法做出来，是一个很难的事情。”比如，做一个三方授权，oauth2.0很简单，所有概念和细节都是紧凑、完备、易用的。你觉得要设计到oauth2.0这个效果很容易么？要做到简单，就要对自己处理的问题有全面的了解，然后需要不断积累思考，才能做到从各个角度和层级去认识这个问题，打磨出一个通俗、紧凑、完备的设计，就像ios的交互设计。简单不是容易做到的，需要大家在不断的时间和code review过程中去积累思考，pk中触发思考，交流中总结思考，才能做得愈发地好，接近’大道至简’。 两张经典的模型图，简单又全面，感受一下，没看懂，可以立即自行google学习一下：RBAC:logging: 原则3 组合原则: 设计时考虑拼接组合关于OOP，关于继承，我前面已经说过了。那我们怎么组织自己的模块？对，用组合的方式来达到。linux操作系统离我们这么近，它是怎么架构起来的？往小里说，我们一个串联一个业务请求的数据集合，如果使用BaseSession，XXXSession inherit BaseSession的设计，其实，这个继承树，很难适应层出不穷的变化。但是如果使用组合，就可以拆解出UserSignature等等各种可能需要的部件，在需要的时候组合使用，不断添加新的部件而没有对老的继承树的记忆这个心智负担。 使用组合，其实就是要让你明确清楚自己现在所拥有的是哪个部件。如果部件过于多，其实完成组合最终成品这个步骤，就会有较高的心智负担，每个部件展开来，琳琅满目，眼花缭乱。比如QT这个通用UI框架，看它的Class列表，有1000多个。如果不用继承树把它组织起来，平铺展开，组合出一个页面，将会变得心智负担高到无法承受。OOP在’需要无数元素同时展现出来’这种复杂度极高的场景，有效的控制了复杂度 。’那么，古尔丹，代价是什么呢？’代价就是，一开始做出这个自上而下的设计，牵一发而动全身，每次调整都变得异常困难。实际项目中，各种职业级别不同的同学一起协作修改一个server的代码，就会出现，职级低的同学改哪里都改不对，根本没能力进行修改，高级别的同学能修改对，也不愿意大规模修改，整个项目变得愈发不合理。对整个继承树没有完全认识的同学都没有资格进行任何一个对继承树有调整的修改，协作变得寸步难行。代码的修改，都变成了依赖一个高级架构师高强度监控继承体系的变化，低级别同学们束手束脚的结果。组合，就很好的解决了这个问题，把问题不断细分，每个同学都可以很好地攻克自己需要攻克的点，实现一个package。产品逻辑代码，只需要去组合各个package，就能达到效果。 这是golang标准库里http request的定义，它就是Http请求所有特性集合出来的结果。其中通用/异变/多种实现的部分，通过duck interface抽象，比如Body io.ReadCloser。你想知道哪些细节，就从组合成request的部件入手，要修改，只需要修改对应部件。[这段代码后，对比.NET的HTTP基于OOP的抽象] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224// A Request represents an HTTP request received by a server// or to be sent by a client.//// The field semantics differ slightly between client and server// usage. In addition to the notes on the fields below, see the// documentation for Request.Write and RoundTripper.type Request struct { // Method specifies the HTTP method (GET, POST, PUT, etc.). // For client requests, an empty string means GET. // // Go's HTTP client does not support sending a request with // the CONNECT method. See the documentation on Transport for // details. Method string // URL specifies either the URI being requested (for server // requests) or the URL to access (for client requests). // // For server requests, the URL is parsed from the URI // supplied on the Request-Line as stored in RequestURI. For // most requests, fields other than Path and RawQuery will be // empty. (See RFC 7230, Section 5.3) // // For client requests, the URL's Host specifies the server to // connect to, while the Request's Host field optionally // specifies the Host header value to send in the HTTP // request. URL *url.URL // The protocol version for incoming server requests. // // For client requests, these fields are ignored. The HTTP // client code always uses either HTTP/1.1 or HTTP/2. // See the docs on Transport for details. Proto string // \"HTTP/1.0\" ProtoMajor int // 1 ProtoMinor int // 0 // Header contains the request header fields either received // by the server or to be sent by the client. // // If a server received a request with header lines, // // Host: example.com // accept-encoding: gzip, deflate // Accept-Language: en-us // fOO: Bar // foo: two // // then // // Header = map[string][]string{ // \"Accept-Encoding\": {\"gzip, deflate\"}, // \"Accept-Language\": {\"en-us\"}, // \"Foo\": {\"Bar\", \"two\"}, // } // // For incoming requests, the Host header is promoted to the // Request.Host field and removed from the Header map. // // HTTP defines that header names are case-insensitive. The // request parser implements this by using CanonicalHeaderKey, // making the first character and any characters following a // hyphen uppercase and the rest lowercase. // // For client requests, certain headers such as Content-Length // and Connection are automatically written when needed and // values in Header may be ignored. See the documentation // for the Request.Write method. Header Header // Body is the request's body. // // For client requests, a nil body means the request has no // body, such as a GET request. The HTTP Client's Transport // is responsible for calling the Close method. // // For server requests, the Request Body is always non-nil // but will return EOF immediately when no body is present. // The Server will close the request body. The ServeHTTP // Handler does not need to. Body io.ReadCloser // GetBody defines an optional func to return a new copy of // Body. It is used for client requests when a redirect requires // reading the body more than once. Use of GetBody still // requires setting Body. // // For server requests, it is unused. GetBody func() (io.ReadCloser, error) // ContentLength records the length of the associated content. // The value -1 indicates that the length is unknown. // Values &gt;= 0 indicate that the given number of bytes may // be read from Body. // // For client requests, a value of 0 with a non-nil Body is // also treated as unknown. ContentLength int64 // TransferEncoding lists the transfer encodings from outermost to // innermost. An empty list denotes the \"identity\" encoding. // TransferEncoding can usually be ignored; chunked encoding is // automatically added and removed as necessary when sending and // receiving requests. TransferEncoding []string // Close indicates whether to close the connection after // replying to this request (for servers) or after sending this // request and reading its response (for clients). // // For server requests, the HTTP server handles this automatically // and this field is not needed by Handlers. // // For client requests, setting this field prevents re-use of // TCP connections between requests to the same hosts, as if // Transport.DisableKeepAlives were set. Close bool // For server requests, Host specifies the host on which the // URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this // is either the value of the \"Host\" header or the host name // given in the URL itself. For HTTP/2, it is the value of the // \":authority\" pseudo-header field. // It may be of the form \"host:port\". For international domain // names, Host may be in Punycode or Unicode form. Use // golang.org/x/net/idna to convert it to either format if // needed. // To prevent DNS rebinding attacks, server Handlers should // validate that the Host header has a value for which the // Handler considers itself authoritative. The included // ServeMux supports patterns registered to particular host // names and thus protects its registered Handlers. // // For client requests, Host optionally overrides the Host // header to send. If empty, the Request.Write method uses // the value of URL.Host. Host may contain an international // domain name. Host string // Form contains the parsed form data, including both the URL // field's query parameters and the PATCH, POST, or PUT form data. // This field is only available after ParseForm is called. // The HTTP client ignores Form and uses Body instead. Form url.Values // PostForm contains the parsed form data from PATCH, POST // or PUT body parameters. // // This field is only available after ParseForm is called. // The HTTP client ignores PostForm and uses Body instead. PostForm url.Values // MultipartForm is the parsed multipart form, including file uploads. // This field is only available after ParseMultipartForm is called. // The HTTP client ignores MultipartForm and uses Body instead. MultipartForm *multipart.Form // Trailer specifies additional headers that are sent after the request // body. // // For server requests, the Trailer map initially contains only the // trailer keys, with nil values. (The client declares which trailers it // will later send.) While the handler is reading from Body, it must // not reference Trailer. After reading from Body returns EOF, Trailer // can be read again and will contain non-nil values, if they were sent // by the client. // // For client requests, Trailer must be initialized to a map containing // the trailer keys to later send. The values may be nil or their final // values. The ContentLength must be 0 or -1, to send a chunked request. // After the HTTP request is sent the map values can be updated while // the request body is read. Once the body returns EOF, the caller must // not mutate Trailer. // // Few HTTP clients, servers, or proxies support HTTP trailers. Trailer Header // RemoteAddr allows HTTP servers and other software to record // the network address that sent the request, usually for // logging. This field is not filled in by ReadRequest and // has no defined format. The HTTP server in this package // sets RemoteAddr to an \"IP:port\" address before invoking a // handler. // This field is ignored by the HTTP client. RemoteAddr string // RequestURI is the unmodified request-target of the // Request-Line (RFC 7230, Section 3.1.1) as sent by the client // to a server. Usually the URL field should be used instead. // It is an error to set this field in an HTTP client request. RequestURI string // TLS allows HTTP servers and other software to record // information about the TLS connection on which the request // was received. This field is not filled in by ReadRequest. // The HTTP server in this package sets the field for // TLS-enabled connections before invoking a handler; // otherwise it leaves the field nil. // This field is ignored by the HTTP client. TLS *tls.ConnectionState // Cancel is an optional channel whose closure indicates that the client // request should be regarded as canceled. Not all implementations of // RoundTripper may support Cancel. // // For server requests, this field is not applicable. // // Deprecated: Set the Request's context with NewRequestWithContext // instead. If a Request's Cancel field and context are both // set, it is undefined whether Cancel is respected. Cancel &lt;-chan struct{} // Response is the redirect response which caused this request // to be created. This field is only populated during client // redirects. Response *Response // ctx is either the client or server context. It should only // be modified via copying the whole Request using WithContext. // It is unexported to prevent people from using Context wrong // and mutating the contexts held by callers of the same request. ctx context.Context} 看看.NET里对于web服务的抽象，仅仅看到末端，不去看完整个继承树的完整图景，我根本无法知道我关心的某个细节在什么位置。进而，我要往整个http服务体系里修改任何功能，都无法抛开对整体完整设计的理解和熟悉，还极容易没有知觉地破坏者整体的设计。 说到组合，还有一个关系很紧密的词，叫插件化。大家都用vscode用得很开心，它比visual studio成功在哪里？如果vscode通过添加一堆插件达到visual studio具备的能力，那么它将变成另一个和 visual studio差不多的东西，叫做vs studio吧。大家应该发现问题了，我们很多时候其实并不需要visual studio的大多数功能，而且希望灵活定制化一些比较小众的能力，用一些小众的插件。甚至，我们希望选择不同实现的同类型插件。这就是组合的力量，各种不同的组合，它简单，却又满足了各种需求，灵活多变，要实现一个插件，不需要事先掌握一个庞大的体系。体现在代码上，也是一样的道理。至少后端开发领域，组合，比OOP，’香’很多。 原则6 吝啬原则: 除非确无它法, 不要编写庞大的程序“大”，是男性们的一致追求。”大”的系统，才能拿得出手去评T11、T12。于是，我们总倾向于把系(肚)统(子)搞大。一个T5的同学做一个服务，也总要搞”大”一点，才好意思拉leader们来评审自己的方案。leader们一看方案，很大，很好，很全面。但是，真的需要这么大么？ 我又要说了”那么，古尔丹，代价是什么呢？”。代价是代码越多，越难维护，难调整。C语言之父Ken Thompson说”删除一行代码，给我带来的成就感要比添加一行要大”。我们对于代码，要吝啬。能把系统做小，就不要做大。腾讯不乏200w+行的客户端，很大，很”牛逼”。但是，同学们自问，现在还调整得动架构么。手Q的同学们，看看自己代码，曾经叹息过么。能小做的事情就小做，寻求通用化，通过duck interface(甚至多进程，用于隔离能力的多线程)把模块、能力隔离开，时刻想着删减代码量，才能保持代码的可维护性和面对未来的需求、架构，调整自身的活力。客户端代码，UI渲染模块可以复杂吊炸天，非UI部分应该追求最简单，能力接口化，可替换、重组合能力强。 落地到大家的代码，review时，就应该最关注核心struct定义，构建起一个完备的模型，核心interface，明确抽象model对外部的依赖，明确抽象model对外提供的能力。其他代码，就是要用最简单、平平无奇的代码实现模型内部细节。 原则7 透明性原则: 设计要可见，以便审查和调试首先，定义一下，什么是透明性和可显性。 “如果没有阴暗的角落和隐藏的深度，软件系统就是透明的。透明性是一种被动的品质。如果实际上能预测到程序行为的全部或大部分情况，并能建立简单的心理模型，这个程序就是透明的，因为可以看透机器究竟在干什么。 如果软件系统所包含的功能是为了帮助人们对软件建立正确的’做什么、怎么做’的心理模型而设计，这个软件系统就是可显的。因此，举例来说，对用户而言，良好的文档有助于提高可显性；对程序员而言，良好的变量和函数名有助于提高可显性。可显性是一种主动品质。在软件种要达到这一点，仅仅做到不晦涩是不够的，还必须要尽力做到有帮助。” 我们要写好程序，减少bug，就要增强自己对代码的控制力。你始终做到，理解自己调用的函数/复用的代码大概是怎么实现的。不然，你可能就会在单线程状态机的server里调用有IO阻塞的函数，让自己的server吞吐量直接掉到底。进而，为了保证大家能对自己代码能做到有控制力，所有人写的函数，就必须具备很高的透明性。而不是写一些看了一阵看不明白的函数/代码，结果被迫使用你代码的人，直接放弃了对掌控力的追去，甚至放弃复用你的代码，另起炉灶，走线了’制造重复代码’的深渊。 透明性其实相对容易做到的，大家有意识地锻炼一两个月，就能做得很好。可显性就不容易了。有一个现象是，你写的每一个函数都不超过80行，每一行我都能看懂，但是你层层调用，很多函数调用，组合起来怎么就实现了某个功能，看两遍，还是看不懂。第三遍可能才能大概看懂。大概看懂了，但太复杂，很难在大脑里构建起你实现这个功能的整体流程。结果就是，阅读者根本做不到对你的代码有好的掌控力。 可显性的标准很简单，大家看一段代码，懂不懂，一下就明白了。但是，如何做好可显性？那就是要追求合理的函数分组，合理的函数上下级层次，同一层次的代码才会出现在同一个函数里，追求通俗易懂的函数分组分层方式，是通往可显性的道路。 当然，复杂如linux操作系统，office文档，问题本身就很复杂，拆解、分层、组合得再合理，都难简历心理模型。这个时候，就需要完备的文档了。完备的文档还需要出现在离代码最近的地方，让人’知道这里复杂的逻辑有文档’，而不是其实文档，但是阅读者不知道。再看看上面golang标准库里的http.Request，感受到它在可显性上的努力了么？对，就去学它。 原则10 通俗原则: 接口设计避免标新立异程序员啊，我们不仅喜欢”大”。我们还喜欢”吊”，我们就是要与众不同，才显得自己厉害。然而，标新立异，就提升了别人理解的难度。 一般，我们这么定义一个’点’，使用x表示横坐标，用y表示纵坐标： 1234type Point struct { X float64 Y float64} 你就是要不同、精准： 1234type Point struct { VerticalOrdinate float64 HorizontalOrdinate float64} 很好，你用词很精准，一般人还驳斥不了你。但是，多数人读你的VerticalOrdinate就是没有读X理解来得快，来得容易懂、方便。你是在刻意制造协作成本。 上面的例子常见，但还不是最小立异原则最想说明的问题。想想一下，一个程序里，你把用’+’这个符号表示数组添加元素，而不是数学’加’，’result := 1+2’ –&gt; ‘result = []int{1, 2}’而不是’result=3’，那么，你这个标新立异，对程序的破坏性，简直无法想象。“最小立异原则的另一面是避免表象想死而实际却略有不同。这会极端危险，因为表象相似往往导致人们产生错误的假定。所以最好让不同事物有明显区别，而不要看起来几乎一模一样。” – Henry Spencer。 你实现一个db.Add()函数却做着db.AddOrUpdate()的操作，有人使用了你的接口，错误地把数据覆盖了。小心以后有人扎小人来诅咒你。 原则11 缄默原则: 如果一个程序没什么好说的，就沉默这个原则，应该是大家最经常破坏的原则之一。一段简短的代码里插入了各种’log(“cmd xxx enter”)’, ‘log(“req data “ + req.String())’，非常害怕自己信息打印得不够。害怕自己不知道程序执行成功了，总要最后’log(“success”)’。但是，我问一下大家，你们真的耐心看过别人写的代码打的一堆日志么？不是自己需要哪个，就在一堆日志里，再打印一个日志出来一个带有特殊标记的日志’log(“this_is_my_log_mark” + xxxxx)’？结果，第一个作者打印的日志，在代码交接给其他人或者在跟别人协作的时候，这个日志根本没有价值，反而提升了大家看日志的难度。 一个服务一跑起来，就疯狂打日志，请求处理正常也打一堆日志。滚滚而来的日志，把错误日志淹没在里面。错误日志失去了效果，简单地tail查看日志，眼花缭乱，看不出任何问题，这不就成了’为了捕获问题’而让自己’根本无法捕获问题’了么？ 沉默是金。除了简单的stat log，如果你的程序’发声’了，那么它抛出的信息就一定要有效！打印一个log(‘process fail’)也是毫无价值，到底什么fail了？是哪个用户带着什么参数在哪个环节怎么fail了？如果发声，就要把必要信息给全。不然就是不发声，表示自己好好地work着呢。不发声就是最好的消息，现在我的work一切正常！ “设计良好的程序将用户的注意力视为有限的宝贵资源，只有在必要时才要求使用。”程序员自己的主力，也是宝贵的资源！只有有必要的时候，日志才跑来提醒程序员’我有问题，来看看’，而且，必须要给到足够的信息，让一把讲明白现在发生了什么。而不是程序员还需要很多辅助手段来搞明白到底发生了什么。 每当我发布程序 ，我抽查一个机器，看它的日志。发现只有每分钟外部接入、内部rpc的个数/延时分布日志的时候，我就心情很愉悦。我知道，这一分钟，它的陈功率又是100%，没任何问题！ 原则12 补救原则: 出现异常时，马上退出并给出足够错误信息其实这个问题很简单，如果出现异常，异常并不会因为我们尝试掩盖它，它就不存在了。所以，程序错误和逻辑错误要严格区分对待。这是一个态度问题。 ‘异常是互联网服务器的常态’。逻辑错误通过metrics统计，我们做好告警分析。对于程序错误 ，我们就必须要严格做到在问题最早出现的位置就把必要的信息搜集起来，高调地告知开发和维护者’我出现异常了，请立即修复我!’。可以是直接就没有被捕获的panic了。也可以在一个最上层的位置统一做好recover机制，但是在recover的时候一定要能获得准确异常位置的准确异常信息。不能有中间catch机制，catch之后丢失很多信息再往上传递。 很多Java开发的同学，不区分程序错误和逻辑错误，要么都很宽容，要么都很严格，对代码的可维护性是毁灭性的破坏。”我的程序没有程序错误，如果有，我当时就解决了。”只有这样，才能保持程序代码质量的相对稳定，在火苗出现时扑灭火灾是最好的扑灭火灾的方式。当然，更有效的方式是全面自动化测试的预防：） 具体实践点前面提了好多思考方向的问题。大的原则问题和方向。我这里，再来给大家简单列举几个细节执行点吧。毕竟，大家要上手，是从执行开始，然后才是总结思考，能把我的思考方式抄过去。下面是针对golang语言的，其他语言略有不同。以及，我一时也想不全我所执行的 所有细则，这就是我强调’原则’的重要性，原则是可枚举的。 对于代码格式规范，100%严格执行，严重容不得一点沙。 文件绝不能超过800行，超过，一定要思考怎么拆文件。工程思维，就在于拆文件的时候积累。 函数对决不能超过80行，超过，一定要思考怎么拆函数，思考函数分组，层次。工程思维，就在于拆文件的时候积累。 代码嵌套层次不能超过4层，超过了就得改。多想想能不能early return。工程思维，就在于拆文件的时候积累。 1234567if !needContinue { doA() return} else { doB() return} 1234567if !needContinue { doA() return}doB()return 下面这个就是early return，把两端代码从逻辑上解耦了。 从目录、package、文件、struct、function一层层下来 ，信息一定不能出现冗余。比如file.FileProperty这种定义。只有每个’定语’只出现在一个位置，才为’做好逻辑、定义分组/分层’提供了可能性。 多用多级目录来组织代码所承载的信息，即使某一些中间目录只有一个子目录。 随着代码的扩展，老的代码违反了一些设计原则，应该立即原地局部重构，维持住代码质量不滑坡。比如:拆文件；拆函数；用Session来保存一个复杂的流程型函数的所有信息；重新调整目录结构。 基于上一点考虑，我们应该尽量让项目的代码有一定的组织、层次关系。我个人的当前实践是除了特别通用的代码，都放在一个git里。特别通用、修改少的代码，逐渐独立出git，作为子git连接到当前项目git，让goland的Refactor特性、各种Refactor工具能帮助我们快速、安全局部重构。 自己的项目代码，应该有一个内生的层级和逻辑关系。flat平铺展开是非常不利于代码复用的。怎么复用、怎么组织复用，肯定会变成’人生难题’。T4-T7的同学根本无力解决这种难题。 如果被review的代码虽然简短，但是你看了一眼却发现不咋懂，那就一定有问题。自己看不出来，就找高级别的同学交流。这是你和别review代码的同学成长的时刻。 日志要少打。要打日志就要把关键索引信息带上。必要的日志必须打。 有疑问就立即问，不要怕问错。让代码作者给出解释。不要怕问出极低问题。 不要说’建议’，提问题，就是刚，你pk不过我，就给改！ 请积极使用trpc。总是要和老板站在一起！只有和老板达成的对于代码质量建设的共识，才能在团队里更好地做好代码质量建设。 消灭重复！消灭重复！消灭重复！ 主干开发最后，我来为’主干开发’多说一句话。道理很简单，只有每次被review代码不到500行，reviewer才能快速地看完，而且几乎不会看漏。超过500行，reviewer就不能仔细看，只能大概浏览了。而且，让你调整500行代码内的逻辑比调整3000行甚至更多的代码，容易很多，降低不仅仅是6倍，而是一到两个数量级。有问题，在刚出现的时候就调整了，不会给被revew的人带来大的修改负担。 关于CI(continuous integration)，还有很多好的资料和书籍，大家应该及时去学习学习。 《unix编程艺术》建议大家把这本书找出来读一读。特别是，T7及更高级别的同学。你们已经积累了大量的代码实践，亟需对’工程性’做思考总结。很多工程方法论都过时了，这本书的内容，是例外中的例外。它所表达出的内容没有因为软件技术的不断更替而过时。 佛教禅宗讲’不立文字’(不立文字，教外别传，直指人心，见性成佛)，很多道理和感悟是不能用文字传达的，文字的表达能力，不能表达。大家尝尝因为”自己听说过、知道某个道理”而产生一种安心感，认为”我懂了这个道理”，但是自己却不能在实践中做到。知易行难，知道却做不到，在工程实践里，就和’不懂这个道理’没有任何区别了。 曾经，我面试过一个别的公司的总监，讲得好像一套一套，代码拉出来遛一遛，根本就没做到，仅仅会道听途说。他在工程实践上的探索前路可以说已经基本断绝了。我只能祝君能做好向上管理，走自己的纯管理道路吧。请不要再说自己对技术有追求，是个技术人了！ 所以，大家不仅仅是看看我这篇文章，而是在实践中去不断践行和积累自己的’教外别传’吧。 Software Engineering at Google也是一本必读好书，可惜没找到中文翻译。(电子版放附件里了)","categories":[],"tags":[]},{"title":"mysql介绍","slug":"TreasureBox/数据库/mysql/0.mysql介绍","date":"2022-12-28T14:55:55.170Z","updated":"2023-04-28T09:25:47.201Z","comments":true,"path":"2022/12/28/treasurebox/shu-ju-ku/mysql/0.mysql-jie-shao/","link":"","permalink":"http://example.com/2022/12/28/treasurebox/shu-ju-ku/mysql/0.mysql-jie-shao/","excerpt":"","text":"mysql技能栈从18年开始自己做项目，到后来实习、毕业参加工作，mysql一直扮演着重要角色，偶然也用到过oracle，mongoDB等数据库，但是mysql一直有独特的魅力，吸引着我把它搞明白。这些年工作中使用mysql遇到了很多问题，所以本文带着问题出发，从这些问题中逐渐揭开mysql的神秘面纱。如果本文中对知识点讲的不够细致或者有错误，欢迎各位多多指教。 一条sql的执行流程","categories":[],"tags":[]},{"title":"day4","slug":"TreasureBox/Go/Go基础/4.day4","date":"2022-07-16T08:29:38.354Z","updated":"2023-04-28T09:25:47.110Z","comments":true,"path":"2022/07/16/treasurebox/go/go-ji-chu/4.day4/","link":"","permalink":"http://example.com/2022/07/16/treasurebox/go/go-ji-chu/4.day4/","excerpt":"","text":"day04 函数 函数的定义 123func 函数名(参数)返回值{ 函数体} 函数进阶 高阶函数：函数可以作为参数也可以作为返回值 12345678910111213141516171819202122package mainimport \"fmt\"func main() { test1(test, \"word\")}// 使用函数名作为参数，并在该方法中调用func test1(f func(name string), name string) { f(name)}func test(name string) { fmt.Println(\"name=\", name)}// 使用函数作为返回值func test2() (f func()) { return f} 闭包 123456789101112131415161718192021//闭包是什么？//闭包是一个函数，这个函数引用了他外部作用域的变量，外部函数的返回值必须是内嵌函数。//闭包 = 函数 + 外部变量的引用package mainimport \"fmt\"func main() { f := f1() f()}func f1() func() { i := 3 f := func() { fmt.Println(i) } return f} defer：延迟调用，多用于处理资源释放 内置函数：panic和recover 递归函数 结构体 123456789101112131415161718192021// 结构体：自定义类型和类型别名// type后边跟的是类型，相当于构建一个自己的数据类型type myInt int// 加一个=时代表给int类型起别名type myInt2 = int// 结构体占用一块连续的内存空间type x struct { a int8 // 8bit，1byte b string c []string d map[string]int}// 声明一个匿名结构体，多用于在函数内部临时使用 var s struct { name string age int } 构造函数：返回一个结构体变量的函数。 1234567891011121314151617181920212223package main// 构造函数：返回一个结构体变量的函数，约定成俗使用new命名// 返回的结构体还是结构体指针// 当结构体比较大的时候，尽量使用结构体指针，减少程序的运行开销type Person struct { name string age int gender string hobby []string}func newPerson(name string, age int) Person { var p Person p.name = name p.age = age return p}func main() { newPerson(\"zs\", 20)} 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport \"fmt\"// 标识符：变量名、函数名、类型名、方法名// 如果标识符的首字母是大写的，就表示对外部可见（暴露的，公有的），在其他包中可以使用，否则只能在当前包中使用// 方法：是作用与特定类型的函数，在函数名之前声明指定的类型// 可以传拷贝的值也可以传地址// 1. 需要修改接收者中的值// 2. 接收者是拷贝代价比较大的对象// 3. 保持一致性，如果使用指针接收者，就全部使用指针接收者// Dog 这是一个Dog的结构体type Dog struct { name string}// 构造函数func newDog(name string) (d Dog) { d = Dog{name: name} return}// 针对Dog类型定义方法// 传的是拷贝的值func (d Dog) wang() { d.name = \"kaixin\" fmt.Printf(\"%s汪汪汪\", d.name)}// 传的是地址func (d *Dog) wang2() { d.name = \"kaixin\" fmt.Printf(\"%s汪汪汪\", d.name)}func main() { d1 := newDog(\"白雪\") d1.wang2() fmt.Println(\"%s\", d1.name)}// 只能给自定义的类型添加方法，不能给其他包中的类型添加// 如果需要给其他包中的类型添加方法，需要自定义类型type myInt intfunc (i myInt) f1() { fmt.Printf(\"%s\\n\", i)}","categories":[],"tags":[]},{"title":"goroutine","slug":"TreasureBox/Go/Go基础/Go协程/goroutine","date":"2022-07-13T03:11:54.454Z","updated":"2023-04-28T09:25:47.114Z","comments":true,"path":"2022/07/13/treasurebox/go/go-ji-chu/go-xie-cheng/goroutine/","link":"","permalink":"http://example.com/2022/07/13/treasurebox/go/go-ji-chu/go-xie-cheng/goroutine/","excerpt":"","text":"Goroutinego语言中的进程、线程、协程、并发和并行、goroutine启动，goroutine特点，runtime包函数1234567891011121314151617181920212223242526272829303132333435363738394041 goroutine是go语言中的协程，MPG概念中重要的一环，当goroutine运行时，系统会分配一个系统级的线程M给逻辑处理器，逻辑处理器的个数可以设置，默认占用所有的核数。 若干个goroutine在逻辑处理器中顺序执行。 当goroutine阻塞时，比如打开文件时，调度器就会降这个线程与处理器分离，并创建一个新线程来运行这个处理器上提供的服务。当被阻塞的系统调用执行完成并返回时， 对应的goroutine会放回到本地运行队列，而之前的线程会保存好，之后可以继续使用。 调用方式 go funcname()goroutine特点： 1.go的执行是非阻塞的，不会等待。 2.go后边的函数的返回值会被忽略。 3.调度器不会保证多个goroutine的执行次序 4.没有父子goroutine的概念，所有的goroutine是平等的被调度和被执行的。 5.go程序在执行时会单独为main函数创建一个goroutin，遇到其他go关键字时再去创建其他的goroutine 6.主函数返回时，所有的goroutine都会被直接打断，程序退出;所以必须要在主函数中进行阻塞，才能保证goroutine执行完成。 7.go没有暴露goroutine id给用户，所以不能在一个goroutine里面显示的操作另一个goroutine，不过runtime包提供了一些函数和设置goroutine的相关信息 8.runtime.NumGoroutine返回一个进程的所有goroutine数，main()的goroutine也被算在里面。因此实际创建的goroutine数量为扣除main()的goroutine数。 一旦主goroutine中的代码（也就是main函数中的代码执行完毕），当前Go程序就会结束运行。如此一来，如果在Go程序结束的那一刻还有goroutine未得到运行机会，就不会再获得运行机会，其中的代码不会再执行。 严谨地讲，go语言不会保证这些goroutine会以怎样的顺序运行。由于主goroutine会与我们手动启用的其他goroutine一起接受调度。 又因为调度器很可能会在goroutine中的代码只执行了一部分的时候暂停，以期所有的goroutine有更公平的运行机会。所以哪个goroutine先执行完，哪个goroutine后执行完往往是不可预知的。 runtime包函数：在go语言程序运行时（runtime）实现了一个小型的任务调度器，提供了修改Go语言运行时配置参数的能力。这套调度器的工作原理类似于系统调度线程，go程序调度器可以高效地将CPU资源分配给每一个任务。 GOMAXPROCS：设置逻辑CPU核数。 fmt.Println(\"GOMAXPROCS0\", runtime.GOMAXPROCS(0)) 查询当前的GOMAXPROCS值 fmt.Println(\"GOMAXPROCS1\", runtime.GOMAXPROCS(1)) 设置单核心执行 fmt.Println(\"GOMAXPROCS2\", runtime.GOMAXPROCS(2)) 设置多核并发执行 Goexit：结束当前goroutine的运行，Goexit在结束当前goroutine运行之前会调用当前goroutine已经注册的defer。 Goexit并不会产生panic，所以该goroutine defer里面的recover调用都返回nil。 调用runtime.Goexit将立即终止当前goroutine执行，调度器确保所有已注册defer延迟调用被执行。 Gosched：goroutine可能切换的点： 1. I/O、select 2. channel 3. 等待锁 4. 函数调用(有时) 5. runtime.Gosched() 和协程yield作用类似，Gosched是放弃当前调度执行机会，将当前goroutine暂停，放回队列等待下次被调度执行。 用于让出CPU时间片。类似于接力赛，A先跑了一会碰到代码runtime.Gosched()就把接力棒交给B，A先歇着，B继续跑 Gosched会在不同的goroutine之间切换，当main goroutine退出时，其他的goroutine都会直接退出。 一个逻辑处理器处理goroutine时间较长 给予调度器的内部算法，一个正运行的goroutine在工作结束前，可以被停止并重新调度。 调度器这样做的目的是防止某个goroutine长时间占用逻辑处理器。当goroutine占用时间过长时，调度器会停止当前正运行的goroutine，并给其他可运行的goroutine运行的机会。","categories":[],"tags":[]},{"title":"kafka详解","slug":"TreasureBox/消息队列/kafka/1.kafka详解","date":"2022-06-24T02:10:21.975Z","updated":"2023-04-28T09:25:47.291Z","comments":true,"path":"2022/06/24/treasurebox/xiao-xi-dui-lie/kafka/1.kafka-xiang-jie/","link":"","permalink":"http://example.com/2022/06/24/treasurebox/xiao-xi-dui-lie/kafka/1.kafka-xiang-jie/","excerpt":"","text":"kafka入门须知 kafka概述kafka是一款开源的消息引擎系统。常见的两种消息传输模型如下： 点对点模型 发布/订阅模型 kafka同时支持这两种模型，是如何做到的？（通过消费者组实现） 消息引擎系统在什么场景下使用？—削峰填谷。所谓的削峰填谷就是指缓冲上下游瞬发的流量，使其更加平滑。对于发送能力很强的上游系统，如果没有消息引擎的保护，下游系统可能会直接被压垮导致全链路服务雪崩，消息引擎可一直在很大程度上避免流量的震荡。消息引擎系统的另一大好处是发送方和接收方的松耦合，减少系统间不必要的交互（生产者、消费者模式）。 kafka的体系架构一个典型的kafka体系架构包含若干Producer、若干Broker、若干Consumer，以及一个zookeeper集群。其中zookeeper负责集群元数据的管理、控制器选举等操作。Producer将消息发送到Broker，Broker负责将收到的消息存储到磁盘中，而Consumer负责从Broker订阅并消费消息。 整个kafka体系结构中引入了3个术语： Producer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到kafka中。 Consumer：消费者，也就是接收消息的一方。消费者连接到kafka上并接收消息，从而进行相应的业务逻辑处理。 Broker：服务节点代理。对于Kafka而言，Broker可以简单的看做一个独立的Kafka服务节点或Kafka实例。大多数情况下也可以将Broker看做一个Kafka服务器，前提是这台服务器上只部署了一个Kafka实例。一个或多个Broker组成一个Kafka集群。一般而言，习惯使用首字母小写的broker来表示服务代理节点。 在kafka中，还有两个很重要的概念——主题(Topic)与分区（Partition）。kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到kafka集群的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。 主题是一个逻辑上的概念，还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区成为主题分区（Topic-Partition）。同一个主题下的不同分区包含的消息是不同的，分区在存储层面上可以看做一个可追加的日志(Log)文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。 offset是消息在分区中的唯一标识，是一个单调递增且不变的值。Kafka通过它来保证消息在分区内的顺序性，不过offset并不跨越分区，也就是说，Kafka保证的是分区有序而不是主题有序。 如图所示kafka某主题中，分为4个分区，消息被顺序追加到每个分区日志文件的尾部。Kafka中的分区可以分布在不同的服务器(Broker)中，也就是说，一个主题可以横跨多个Broker，以此来提供比单个Broker更强大的性能。 每一条消息在被发送到Broker之前，会根据分区规则选择存储到哪个具体的分区，如果分区规则设定的合理，所有的消息都可以均匀地分配到不同的分区中；如果一个主题只对应一个文件，那么这个文件所在的机器I/O将会成为这个主题的性能瓶颈，而分区解决了这个问题。在创建主题的时候可以通过指定的参数来设置分区的个数，也可以在主题创建完成之后去修改分区的数量，通过增加分区的数量可以实现水平扩展。 不考虑多副本的情况，一个分区对应一个日志（Log）。为了防止Log过大，Kafka又引入了日志分段（LogSegment）的概念，将Log切分为多个LogSegment，相当于一个巨型文件被平均分配为多个相对较小的文件，这样也便于消息的维护和清理。事实上，Log和LogSegment也不是纯粹物理意义上的概念。Log在物理上只以文件夹的形式存储，而每个LogSegment对应于磁盘上的一个日志文件和两个索引文件，以及可能的其他文件（比如以”.txnindex”为后缀的事务索引文件）。如下图描绘了主题、分区、副本、Log以及LogSegment之间的关系。 多副本机制Kafka为分区引入了多副本(Replica)机制，通过增加副本数量可以提升容灾能力。备份的思想就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在Kafka中被称为副本(Replica)。 同一个分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样），副本之间是”一主多从”的关系，其中Leader副本负责处理读写请求，follwoer副本只负责与Leader副本的消息同步。副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。Kafka通过多副本机制实现了故障的自动转移，当Kafka集群中的某个broker失效时仍能保证服务可用。 我们知道一些其他的系统中的follower副本可以对外提供服务，比如mysql中的从库可以对外提供读操作，但是Kafka中的follower副本不像mysql的副本可以单独对外提供服务。 为什么Kafka不像MySQL和Redis那样对外提供服务？ 首先，Redis和MySQL都支持主从读写分离，这与他们的使用场景有关。对于那种读操作很多而写操作相对不频繁的负载类型而言，采用读写分离是非常不错的方案——可以添加很多的follower横向扩展，提升读操作性能。反观Kafka，它的主要使用场景是消息引擎而不是以数据存储的方式对外提供服务，通常涉及频繁的生产消息和消费消息，这不属于典型的读多写少场景，因此读写分离方案不适合当前场景。 第二，Kafka副本使用的是异步拉取，因此存在leader和follower之间的不一致性。如果要采用读写分离，则要处理副本lag引入的一致性问题。 第三，主写从读模式是为了减轻leader节点的压力，将读请求的负载均衡到follower节点，如果kafka的分区相对均匀地分散到各个broker上，同样可以起到负载均衡的效果，没必要刻意实现主写从读增加代码实现的复杂程度。 如下是kafka分区和副本的架构图： 如上图所示，Kafka集群中有4个Broker，某个主题中有3个分区，且副本因子（即副本个数）也为3，如此每个分区便有1个leader副本和2个follower副本。生产者和消费者只与leader副本进行交互，而follower副本只负责消息的同步，很多时候follwoer副本中的消息相对leader副本而言会有一定的滞后。 Kafka消费端也具备一定的容灾能力。Consumer使用(pull)模式从服务器端拉取数据，并且保存消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息丢失。 分区中所有的副本统称为AR(Assigned Replicas)。所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR(In-Sync Replicas)，ISR集合是AR几何中的一个子集。消息会先发送到leader副本，然后follower副本才能从leader副本中拉取消息进行同步，同步期间follower副本相对于leader副本而言会有一定程度的滞后。 “一定程度的同步”是指可忍受的滞后范围，这个参数可以配置，与leader副本同步滞后过多的副本（不包括leader副本）组成OSR（Out-of-Sync Replicas），由此可见，AR=ISR+OSR。在正常情况下，所有的follower副本都应该与leader副本保持一定程度的同步，即AR=ISR，OSR集合为空。 leader副本负责维护和跟中ISR几何中所有follower副本的滞后状态，当follower副本“追上”leader副本时，leader副本就会将OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader，而在OSR几何中的副本则没有任何机会（也可以通过修改参数配置来改变）。 ISR与KW和LEO也有紧密的关系。HW是High Watermark的缩写，俗称高水位，他标识了一个特定的消息偏移量（offset），消费者只能拉取到这个offset之前的消息。 ![image-20220628200511940](1.kafka详解/images/5.kafka offset详解.png) 如上图所示，代表一个日志文件，这个日志文件中有9条消息，第一条消息的offset（LogStartOffset）为0，最后一条的offset为8，offset为9 的消息代表下一条将要写入的消息。日志文件的HW为6，表示消费者只能拉取到offset在0-5之间的消息，而offset为6的消息对消费者而言是不可见的。 LEO是Log End Offset的缩写，它标识当前日志文件中下一条待写入消息的offset，上图中offset为9的位置即为当前日志文件的LEO，LEO的大小相当于当前日志分区中最后一条消息的offset值加1。分区ISR几何中的每个副本都会维护自身的LEO，而ISR集合中最小的LEO即为分区的HW，对消费者而言只能消费HW之前的消息。 分区机制虽然有了副本机制可以保证数据的高可用，但没有解决伸缩性（Scalability）问题。什么是伸缩性呢？拿副本来说，虽然现在有了领导者副本和追随者副本，但倘若领导者副本积累了太多的数据，以至于单台Broker机器无法容纳，此时应该怎么办呢？一个很自然的想法就是能否把数据分割成多分保存在不同的Broker中？这种机制就是所谓的分区。 kafka的生产者 为什么要分区 分区策略 轮询策略 随机策略 按消息键保存策略 kafka的消费者 消费模型 消费者组 重平衡 消费者组重平衡流程 位移主题 位移提交 kafka的客户端 kafka副本机制 副本角色","categories":[],"tags":[]},{"title":"QueryDSL","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/3.QueryDSL","date":"2022-06-21T13:59:34.671Z","updated":"2023-04-28T09:25:47.283Z","comments":true,"path":"2022/06/21/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/3.querydsl/","link":"","permalink":"http://example.com/2022/06/21/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/3.querydsl/","excerpt":"","text":"Query DSL(Domain Specific Language) 查询上下文使用query关键字进行检索，倾向于相关度搜索，故需要计算评分。搜索是Elasticsearch最关键和重要的部分。 相关度评分：_score概念：相关度评分用于对搜索结果排序，评分越高则认为其结果和搜索的预期值相关度越高，即越符合搜索预期值。在7.x之前相关度评分默认使用TF/IDF算法计算而来，7.x之后默认为BM25。在核心知识篇不必关心相关评分的具体原理，只需知晓其概念即可。 排序：相关度评分为搜索结果的排序依据，默认情况下评分越高，则结果越靠前。 元数据：_source 禁用_source： 好处：节省存储开销 坏处： 不支持update、update_by_query和reindex API。 不支持高亮。 不支持reindex、更改mapping分析器和版本升级。 通过查看索引时使用的原始文档来调试查询或聚合的功能。 将来有可能自动修复索引损坏。 总结：如果只是为了节省磁盘，可以压缩索引比禁用_source更好。 数据源过滤器： includes： 结果中返回哪些field excludes： 结果中不要返回哪些field，不返回的field不代表不能通过该字段进行检索，因为元数据不存在不代表索引不存在 在mapping中定义过滤：支持通配符，但是这种方式不推荐，因为mapping不可变 123456789101112131415PUT product{ \"mappings\": { \"_source\": { \"includes\": [ \"name\", \"price\" ], \"excludes\": [ \"desc\", \"tags\" ] } }} 常用过滤规则 “_source”: “false”, “_source”: “obj.*”, “_source”: [ “obj1.*“, “obj2.*“ ], “_source”: {“includes”: [ “obj1.*“, “obj2.*“ ],“excludes”: [ “*.description” ] } Query String 查询所有：GET /product/_search 带参数：GET /product/_search?q=name:xiaomi 分页：GET /product/_search?from=0&amp;size=2&amp;sort=price:asc 精准匹配 exact valueGET /product/_search?q=date:2021-06-01 _all搜索 相当于在所有有索引的字段中检索GET /product/_search?q=2021-06-01 12345678910111213141516171819DELETE product# 验证_all搜索PUT product{ \"mappings\": { \"properties\": { \"desc\": { \"type\": \"text\", \"index\": false } } }}# 先初始化数据POST /product/_update/5{ \"doc\": { \"desc\": \"erji zhong de kendeji 2021-06-01\" } 全文检索-Fulltext query123456GET index/_search{ \"query\": { *** }} match：匹配包含某个term的子句，用于text字段分词之后的查询(全文检索)123456789# 只要desc包含\"xiaomi\",\"vivo\",\"iphone\"中的任意一个GET product/_search{ \"query\": { \"match\": { \"desc\": \"xiaomi vivo iphone\" } }} match_all：匹配所有结果的子句12345678# 查询所有数据GET product/_search{ \"query\": { \"match_all\": { } }} multi_match：多字段条件匹配，一般用于全文检索12345678910# 查name或者desc中包含xiaomi的数据，or的关系GET product/_search{ \"query\": { \"multi_match\": { \"query\": \"xiaomi\", \"fields\": [\"name\", \"desc\"] } }} match_phrase：短语查询123456789101112131415161718192021222324# 必须包含要查询的短语，如下：要求desc字段中必须包含“xiaomi made”GET product/_search{ \"query\": { \"match_phrase\": { \"desc\": \"xiaomi made\" } }}# 示例分词结果GET _analyze{ \"analyzer\": \"standard\", \"text\":\"xiaomi made\"}# 示例分词结果GET _analyze{ \"analyzer\": \"standard\", \"text\":\"xiaomi made 2023-03-06\"} 精准查询——Term query term：匹配和搜索词项(分词后)完全相等的结果 term和match_phrase区别： match_phrase 会将检索关键词分词，match_phrase的分词结果必须在被检索字段的分词中都包含，而且顺序必须相同，而且默认必须都是连续的，term搜索不会将搜索词分词 term和keyword区别 term是对于搜索词不分词，keyword是字段类型，是对于source data中的字段值不分词 terms：匹配和搜索词项列表中任意项匹配的结果 range：范围查找 过滤器-Filter123456789101112GET _search{ \"query\": { \"constant_score\": { \"filter\": { \"term\": { \"status\": \"active\" } } } }} filter query和filter的主要区别在： filter是结果导向的而query是过程导向。query倾向于“当前文档和查询的语句的相关度”，而filter倾向于“当前文档和查询的条件是不是相符”。即在查询过程中，query是要对查询的每个结果计算相关性得分的，而filter不会。另外filter有相应的缓存机制，可以提高查询效率 1234567891011121314# constant_score 表示固定分数，不计算得分GET product/_search{ \"query\": { \"constant_score\": { \"filter\": { \"term\": { \"name\": \"phone\" } }, \"boost\": 1.2 # 查询结果的默认分数 } }} 组合查询-Bool query bool：可以组合多个查询条件，bool查询也是采用more_matches_is_better的机制，因此满足must和should子句的文档将会合并起来计算分值，多个条件and的关系。 must：必须满足子句（查询）条件，并将有助于得分，查询结果会记分。 filter：筛选时不计算相关度分数，cache子句（查询）必须出现在匹配的文档中。但是不像 must要求相关度，查询的分数将被忽略。Filter子句在filter上下文中执行，计分被忽略，并且子句被考虑用于缓存。 should：查询子句中可能符合的条件（or查询）。 must_not：必须不满足不子句查询。子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存。由于忽略计分，所有文档的分数会返回为0。 minimum_should_match：指定should返回的文档必须匹配的子句的数量或百分比。如果设置值为1，则要求should语句中至少有一个子句会查询。如果跟must或filter连用事，默认值为0，should失效，不参与查询。 备注 ​ 测试数据用到的mapping PUT product{ “mappings”: { “_doc”: { “properties”: { “name”: { “type”: “text” }, “price”: { “type”: “float” }, “desc”: { “type”: “text” }, “tags”: { “type”: “text” }, “add_date”: { “type”: “date”, “format”: “YYYY-MM-DD” } }, “_source”: { “enabled”: true } } }}","categories":[],"tags":[]},{"title":"笔记 (copy)","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/笔记 (copy)","date":"2022-06-21T13:59:33.011Z","updated":"2023-04-28T09:25:47.277Z","comments":true,"path":"2022/06/21/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/bi-ji-copy/","link":"","permalink":"http://example.com/2022/06/21/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/bi-ji-copy/","excerpt":"","text":"分词器1 normalization：文档规范化,提高召回率2 字符过滤器（character filter）：分词之前的预处理，过滤无用字符 HTML Strip Character Filter：html_strip 参数：escaped_tags 需要保留的html标签 Mapping Character Filter：type mapping Pattern Replace Character Filter：type pattern_replace 3 令牌过滤器（token filter）：停用词、时态转换、大小写转换、同义词转换、语气词处理等。比如：has=&gt;have him=&gt;he apples=&gt;apple the/oh/a=&gt;干掉4 分词器（tokenizer）：切词5 常见分词器： standard analyzer：默认分词器，中文支持的不理想，会逐字拆分。 pattern tokenizer：以正则匹配分隔符，把文本拆分成若干词项。 simple pattern tokenizer：以正则匹配词项，速度比pattern tokenizer快。 whitespace analyzer：以空白符分隔 Tim_cookie 6 自定义分词器：custom analyzer char_filter：内置或自定义字符过滤器 。 token filter：内置或自定义token filter 。 tokenizer：内置或自定义切词器。 7 中文分词器：ik分词 安装和部署 ik下载地址：https://github.com/medcl/elasticsearch-analysis-ik Github加速器：https://github.com/fhefh2015/Fast-GitHub 创建插件文件夹 cd your-es-root/plugins/ &amp;&amp; mkdir ik 将插件解压缩到文件夹 your-es-root/plugins/ik 重新启动es IK文件描述 IKAnalyzer.cfg.xml：IK分词配置文件 主词库：main.dic 英文停用词：stopword.dic，不会建立在倒排索引中 特殊词库： quantifier.dic：特殊词库：计量单位等 suffix.dic：特殊词库：行政单位 surname.dic：特殊词库：百家姓 preposition：特殊词库：语气词 自定义词库：网络词汇、流行词、自造词等 ik提供的两种analyzer: ik_max_word会将文本做最细粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,和,国国,国歌”，会穷尽各种可能的组合，适合 Term Query； ik_smart: 会做最粗粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”，适合 Phrase 查询。 热更新 远程词库文件 优点：上手简单 缺点： 词库的管理不方便，要操作直接操作磁盘文件，检索页很麻烦 文件的读写没有专门的优化性能不好 多一层接口调用和网络传输 ik访问数据库 MySQL驱动版本兼容性 https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-versions.html https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-versions.html 驱动下载地址 https://mvnrepository.com/artifact/mysql/mysql-connector-java","categories":[],"tags":[]},{"title":"Mapping","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/2.Mapping","date":"2022-06-21T13:54:52.764Z","updated":"2023-04-28T09:25:47.283Z","comments":true,"path":"2022/06/21/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/2.mapping/","link":"","permalink":"http://example.com/2022/06/21/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/2.mapping/","excerpt":"","text":"Mapping 概念ES中的mapping有点类似与RDB中“表结构”的概念，在MySQL中，表结构里包含了字段名称，字段的类型还有索引信息等。在Mapping里也包含了一些属性，比如字段名称、类型、字段使用的分词器、是否评分、是否创建索引等属性，并且在ES中一个字段可以有对个类型。分词器、评分等概念。 查看mapping1GET /index/_mappings ES数据类型 常见类型 数字类型 long 个带符号的 64 位整数，最小值为，最大值为。 -263 263-1 integer 一个带符号的 32 位整数，最小值为，最大值为。 -231 231-1 short 一个带符号的 16 位整数，最小值为-32768，最大值为32767。 byte 一个带符号的 8 位整数，最小值为-128，最大值为127。 double 双精度 64 位 IEEE 754 浮点数，仅限于有限值。最小2的-1074次方 float 单精度 32 位 IEEE 754 浮点数，仅限于有限值。最小2的-149次方 half_float 半精度 16 位 IEEE 754 浮点数，仅限于有限值。最小2的-24次方 scaled_float 由 支持的有限浮点数long，按固定double比例因子缩放 keyword类型 keyword：适用于索引结构化的字段，可以用于过滤、排序、聚合。keyword类型的字段只能通过精确值（exact value）搜索到。Id应该用keyword constant_keyword：始终包含相同值的关键字字段 wildcard：可针对类似grep的通配符查询优化日志行和类似的关键字值 关键字字段通常用于排序， 汇总和Term查询，例如term。 Date类型：包括date和 date_nanos alias：为现有字段定义别名。 binary（二进制）：binary range（区间类型）：integer_range、float_range、long_range、double_range、date_range text 当一个字段是要被全文搜索的，比如Email内容、产品描述，这些字段应该使用text类型。设置text类型以后，字段内容会被分析，在生成倒排索 引以前，字符串会被分析器分成一个一个词项。text类型的字段不用于排序，很少用于聚合。（解释一下为啥不会为text创建正排索引：大量堆空间，尤其是 在加载高基数text字段时。字段数据一旦加载到堆中，就在该段的生命周期内保持在那里。同样，加载字段数据是一个昂贵的过程，可能导致用户遇到延迟问题。这就是默认情况下禁用字段数据的原因） 对象关系类型： object：用于单个JSON对象 nested：用于JSON对象数组 flattened：允许将整个JSON对象索引为单个字段。 结构化类型： geo-point：纬度/经度积分 geo-shape：用于多边形等复杂形状 point：笛卡尔坐标点 shape：笛卡尔任意几何图形 特殊类型： IP地址：ip 用于IPv4和IPv6地址 completion：提供自动完成建议 tocken_count：计算字符串中令牌的数量 murmur3：在索引时计算值的哈希并将其存储在索引中 annotated-text：索引包含特殊标记的文本（通常用于标识命名实体） percolator：接受来自query-dsl的查询 join：为同一索引内的文档定义父/子关系 rank features：记录数字功能以提高查询时的点击率。 dense vector：记录浮点值的密集向量。 sparse vector：记录浮点值的稀疏向量。 search-as-you-type：针对查询优化的文本字段，以实现按需输入的完成 histogram：histogram 用于百分位数聚合的预聚合数值。 constant keyword：keyword当所有文档都具有相同值时的情况的 专业化。 array（数组） 在Elasticsearch中，数组不需要专用的字段数据类型。默认情况下，任何字段都可以包含零个或多个值，但是数组中的所有值都必须具有相同的数据类型。 新增 date_nanos：date plus 纳秒 features：… 两种映射类型 Dynamic field mapping： 整数 =&gt; long 浮点数 =&gt; float true || false =&gt; boolean 日期 =&gt; date 数组 =&gt; 取决于数组中的第一个有效值 对象 =&gt; object 字符串 =&gt; 如果不是数字和日期类型，会被映射为text和keyword两个类型 除了以上字段类型之外，其他类型都必须显示映射，也就是必须手工指定，因为其他类型ES无法自动识别，如下表示java基础类型占用的字节大小。 基本数据类型 占用的内存（byte） 范围 byte 1 -2^7 ~ 2^7-1 short 2 -2^15 ~ 2^15-1 int 4 -2^31 ~ 2^31-1 long 8 -2^63 ~ 2^63-1 float 4 -3.4e+38 ~ 3.4e+38 double 8 -1.7e+308 ~ 1.7e+308 boolean 1 true/false char 2 0~65535 Expllcit field mapping：手动映射12345678910PUT /product{ \"mappings\": { \"properties\": { \"field\": { \"mapping_parameter\": \"parameter_value\" } } }} 映射参数 index：是否对创建对当前字段创建倒排索引，默认true，如果不创建索引，该字段不会通过索引被搜索到,但是仍然会在source元数据中展示 analyzer：指定分析器（character filter、tokenizer、Token filters） boost：对当前字段相关度的评分权重，默认1 coerce：是否允许强制类型转换 ，例如”1”转为1，默认为true，false时不能强制类型转换，类型不符合时会报错 copy_to：该参数允许将多个字段的值复制到组字段中，然后可以将其作为单个字段进行查询 doc_values：为了提升排序和聚合效率，默认true，如果确定不需要对字段进行排序或聚合，也不需要通过脚本访问字段值，则可以禁用doc值以节省磁盘空间（不支持text和annotated_text） dynamic：控制是否可以动态添加新字段 true 新检测到的字段将添加到映射中。（默认） false 新检测到的字段将被忽略。这些字段将不会被索引，因此将无法搜索，但仍会出现在_source返回的匹配项中。这些字段不会添加到映射中，必须显式添加新字段。 strict 如果检测到新字段，则会引发异常并拒绝文档。必须将新字段显式添加到映射中 eager_global_ordinals：用于聚合的字段上，优化聚合性能。 Frozen indices（冻结索引）：有些索引使用率很高，会被保存在内存中，有些使用率特别低，宁愿在使用的时候重新创建，在使用完毕后丢弃数据，Frozen indices的数据命中频率小，不适用于高搜索负载，数据不会被保存在内存中，堆空间占用比普通索引少得多，Frozen indices是只读的，请求可能是秒级或者分钟级。eager_global_ordinals不适用于Frozen indices enable 是否创建倒排索引，可以对字段操作，也可以对索引操作，如果不创建索引，仍然可以检索并在_source元数据中展示，谨慎使用，该状态无法修改。 123456PUT my_index{ \"mappings\": { \"enabled\": false }} fielddata 查询时的内存数据结构，在首次用当前字段聚合、排序或者在脚本中使用时，设置字段的fileddata为true fields：给field创建多字段，用于不同目的（全文检索或者聚合分析排序） format：格式化 1234\"date\": { \"type\": \"date\", \"format\": \"yyyy-MM-dd\" } ignore_above：超过长度将被忽略 ignore_malformed：忽略类型错误，默认为false，为true时类型不符会报错，如“foo”插入int类型中 index_options：控制将哪些信息添加到反向索引中以进行搜索和突出显示，仅用于text字段 Index_phrases：提升exact_value查询速度，但是要消耗更多磁盘空间 Index_prefixes：前缀搜索 min_chars：前缀最小长度，&gt;0，默认2（包含） max_chars：前缀最大长度，&lt;20，默认5（包含） meta：附加元数据 normalizer： norms：是否禁用评分（在filter和聚合字段上应该禁用）。 null_value：为null值设置默认值 position_increment_gap： proterties：除了mapping还可用于object的属性设置 search_analyzer：设置单独的查询时分析器：** similarity：为字段设置相关度算法，支持BM25、claassic（TF-IDF）、boolean store：设置字段是否仅查询 term_vector：运维参数 ​","categories":[],"tags":[]},{"title":"项目实战篇","slug":"TreasureBox/Elasticsearch/学习笔记/3.项目实战篇-2week/项目实战篇","date":"2022-06-09T11:27:41.467Z","updated":"2023-04-28T09:25:47.287Z","comments":true,"path":"2022/06/09/treasurebox/elasticsearch/xue-xi-bi-ji/3.xiang-mu-shi-zhan-pian-2week/xiang-mu-shi-zhan-pian/","link":"","permalink":"http://example.com/2022/06/09/treasurebox/elasticsearch/xue-xi-bi-ji/3.xiang-mu-shi-zhan-pian-2week/xiang-mu-shi-zhan-pian/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"运维调优篇","slug":"TreasureBox/Elasticsearch/学习笔记/4.运维调优篇-2week/运维调优篇","date":"2022-06-09T11:27:32.974Z","updated":"2023-04-28T09:25:47.287Z","comments":true,"path":"2022/06/09/treasurebox/elasticsearch/xue-xi-bi-ji/4.yun-wei-diao-you-pian-2week/yun-wei-diao-you-pian/","link":"","permalink":"http://example.com/2022/06/09/treasurebox/elasticsearch/xue-xi-bi-ji/4.yun-wei-diao-you-pian-2week/yun-wei-diao-you-pian/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"高手进阶篇","slug":"TreasureBox/Elasticsearch/学习笔记/2.高手进阶篇-2week/高手进阶篇","date":"2022-06-09T11:27:17.594Z","updated":"2023-04-28T09:25:47.287Z","comments":true,"path":"2022/06/09/treasurebox/elasticsearch/xue-xi-bi-ji/2.gao-shou-jin-jie-pian-2week/gao-shou-jin-jie-pian/","link":"","permalink":"http://example.com/2022/06/09/treasurebox/elasticsearch/xue-xi-bi-ji/2.gao-shou-jin-jie-pian-2week/gao-shou-jin-jie-pian/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"es基本介绍","slug":"TreasureBox/Elasticsearch/学习笔记/1.核心知识篇-2week/1.es基本介绍","date":"2022-06-09T11:23:04.635Z","updated":"2023-04-28T09:25:47.272Z","comments":true,"path":"2022/06/09/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/1.es-ji-ben-jie-shao/","link":"","permalink":"http://example.com/2022/06/09/treasurebox/elasticsearch/xue-xi-bi-ji/1.he-xin-zhi-shi-pian-2week/1.es-ji-ben-jie-shao/","excerpt":"","text":"核心知识篇简介ElasticStack四大金刚 elasticsearch 基于Json的分布式搜索和分析引擎 Logstash 动态数据收集管道，生态丰富 Kibana 提供数据的可视化页面 Beats 轻量级的数据采集器 环境安装兼容性查看：https://www.elastic.co/cn/support/matrix#matrix_os 安装EShttps://www.elastic.co/cn/downloads/past-releases#enterprise-search 集群健康度检查 Green：所有Primary和Replica均为activate，集群健康 Yellow：至少有一个Replica不可用，但是所有Primary均为activate，数据仍然可以保证完整性 Red：至少有一个Primary为不可用状态，数据不完整，集群不可用 查看集群状态12345678910111213141516171819202122curl -XGET \"http://127.0.0.1:9200/_cluster/health\"# 在索引级别上显示异常情况curl -XGET \"http://127.0.0.1:9200/_cluster/health?level=indices\"curl -XGET \"http://127.0.0.1:9200/_cluster/allocation/explain\"{ \"cluster_name\": \"elasticsearch\", # 集群名称 \"status\": \"yellow\", # 集群状态 \"timed_out\": false, # 是否超时 \"number_of_nodes\": 1, # 节点数量 \"number_of_data_nodes\": 1, # 数据节点数量 \"active_primary_shards\": 19, # 活跃的主分片数量 \"active_shards\": 19, # 活跃的分片数量 \"relocating_shards\": 0, # 将要迁往到其他节点的分片 \"initializing_shards\": 0, # 正在初始化的分片数量 \"unassigned_shards\": 2, # 未分配的分片数量 \"delayed_unassigned_shards\": 0, # 延时待分配到具体节点上的分片数 \"number_of_pending_tasks\": 0, #主节点创建索引并分配shards等任务数，正常为0 \"number_of_in_flight_fetch\": 0, # 在分片中执行的集群更新的数量，比如修改某个字段值，正同步到其他副分片的，未分配分片不统计在内 \"task_max_waiting_in_queue_millis\": 0, # 集群任务在队列中等待的最长时长 \"active_shards_percent_as_number\": 90.47619047619048 # 活跃分片占比} 核心概念倒排索引 包含term index，term dectionary，posting List。 分别表示：词项索引、词项字典、倒排表 term index term dictionary posting list 标记匹配 apple 1,2,3,…10w orange 3.4.5 True banana 8 True cluster：集群中的基本元素是节点，节点又分为不同的角色，同一个机器中尽量不部署多个节点。 master：候选节点，维护集群元数据，节点状态，创建索引，索引主副分片，选主之后其他节点将信息发送到主节点，主节点再分发到其他节点。data：数据节点data_content：数据内容节点data_hot：热节点，可写可更新节点data_warm：warm节点，一般用于不再更新的节点，只查询data_code：冷节点，只读索引，存放历史数据Ingest：预处理节点，作用类似于Logstash中的Filterml(machine learning)：机器学习节点remote_cluster_client：候选客户端节点transform：转换节点voting_only：仅投票节点 index：索引 类似数据库的概念，以分片为单位，可以设置副本及分片个数 type：类型 每一个index中分为不同的type，使用type可以在同一个index里存储多种类型的数据，可以减少index的数量，好处是搜索同一个index 的多个type时不会产生额外的开销，因为遍历的分片数是一样的。 缺点是不同type名称相同的字段要完全保持一致如字段类型等；在某个type有的字段，在其他没有该字段的type也会消耗资源（posting list，doc value）。搜索评分是在index级别计算，多个type会相互影响。 在7.x版本中开始弱化，使用_doc进行统一使用，在8.x版本中彻底删除 shard：分片一个索引中包含一个或者多个分片，在7.0之前默认创建5个分片，每个主分片一个副本；7.0之后默认创建1个主分片。副本可以在索引创建之后修改数量，但是主分片的数量一旦确定之后不能修改，只能删除之后重新创建。主分片挂掉之后副分片升级为主分片。原分片加入之后从当前主分片中同步数据。主分片和副分片不会在同一个节点中。 每个分片都是一个Lucene实例，有完整的创建索引和处理请求能力，搜索时所有的分片都会被扫描，最终被ES合并所有的搜索结果。 ES会在nodes上做分片均衡：所有的分片尽量均匀的分布在所有的节点上rebalance，分片平衡策略。 一个doc不会存在于多个主分片中，但是当每个主分片的副本数量不唯一时，可以同时存在于多个副本中 每个主分片和副分片不能同时存在于同一个节点中，所以如果设置副本&gt;0时，最少有两个节点，否则分片一直处于无法分配状态，如下图： doc 文档：es中的数据都是以文档的形式存储，是数据存储的基本单元，每个doc都会有_id字段，可以在存储时指定_id，或者es会自动生成，es默认根据doc做routing，","categories":[],"tags":[]},{"title":"ES安装","slug":"TreasureBox/Elasticsearch/0.ES安装","date":"2022-05-27T12:16:52.147Z","updated":"2023-04-28T09:25:47.257Z","comments":true,"path":"2022/05/27/treasurebox/elasticsearch/0.es-an-zhuang/","link":"","permalink":"http://example.com/2022/05/27/treasurebox/elasticsearch/0.es-an-zhuang/","excerpt":"","text":"title: ElasticSearch 安装安装 centos系统中安装，es7.6版本中已经有JDK，所以机器不需要本地JDK，可以不用安装JDK： 123cd /home/softwarewget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.2-linux-x86_64.tar.gztar -zxvf elasticsearch-7.6.2-linux-x86_64.tar.gz 各文件夹作用 1234567891011bin 可执行脚本，包含启动文件等config 配置文件jdk/jdk.app java的jar文件，自带的java环境lib elastic组件的jar包LICENSE.txt logs 日志文件夹，需要修改为其他目录data 默认的数据存放目录，包含节点、分片、索引、文档的所有数据，生产环境必须修改。modules 依赖的模块NOTICE.txt plugins 插件的存放位置，如IK分词器等README.asciidoc 配置文件 12345678910es安装目录中的config文件夹下config/elasticsearch.yml ES的初始化配置 主要修改，打开以下注释： node.name: node-1 cluster.initial_master_nodes: [\"node-1\"] config/jvm.options jvm的配置文件 注意这两个参数要设置为一致，否则会报错 -Xms512m -Xmx512m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# ======================== Elasticsearch Configuration =========================## NOTE: Elasticsearch comes with reasonable defaults for most settings.# Before you set out to tweak and tune the configuration, make sure you# understand what are you trying to accomplish and the consequences.## The primary way of configuring a node is via this file. This template lists# the most important settings you may want to configure for a production cluster.## Please consult the documentation for further information on configuration options:# https://www.elastic.co/guide/en/elasticsearch/reference/index.html## ---------------------------------- Cluster -----------------------------------## Use a descriptive name for your cluster:# 集群名称#cluster.name: my-application## ------------------------------------ Node ------------------------------------## Use a descriptive name for the node:# 节点名称#node.name: node-1## Add custom attributes to the node:##node.attr.rack: r1## ----------------------------------- Paths ------------------------------------## Path to directory where to store the data (separate multiple locations by comma):# 数据的保存路径#path.data: /path/to/data## Path to log files:# 日志文件保存位置#path.logs: /path/to/logs## ----------------------------------- Memory -----------------------------------## Lock the memory on startup:# 锁定物理内存地址，防止es内存被交换出去，就是避免es使用swap交换分区，频繁的交换，会导致IOPS变高#bootstrap.memory_lock: true## Make sure that the heap size is set to about half the memory available# on the system and that the owner of the process is allowed to use this# limit.## Elasticsearch performs poorly when the system is swapping the memory.## ---------------------------------- Network -----------------------------------# By default Elasticsearch is only accessible on localhost. Set a different# address here to expose this node on the network:#network.host: 192.168.0.1## By default Elasticsearch listens for HTTP traffic on the first free port it# finds starting at 9200. Set a specific HTTP port here:# 开启的端口，默认9200#http.port: 9200## For more information, consult the network module documentation.## --------------------------------- Discovery ----------------------------------## Pass an initial list of hosts to perform discovery when this node is started:# The default list of hosts is [\"127.0.0.1\", \"[::1]\"]##discovery.seed_hosts: [\"host1\", \"host2\"]## Bootstrap the cluster using an initial set of master-eligible nodes:# 可以升级为master节点的节点名称，要与node.name配置相同#cluster.initial_master_nodes: [\"node-1\", \"node-2\"]# For more information, consult the discovery and cluster formation module documentation.# ---------------------------------- Various -----------------------------------# Require explicit names when deleting indices:# 默认情况下 Elasticsearch 不允许通配符删除。此更改破坏了许多集成测试#action.destructive_requires_name: true 启动 前台启动：./bin/elasticsearch 后台启动：bin/elasticsearch -d 启动之后使用浏览器访问：http://127.0.0.1:9200/ 12345启动时如果报错：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]则切换到root用户，然后编辑/etc/sysctl.conf，在最后一行加入：vm.max_map_count=262144 #max_map_count文件包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量sysctl -p # 保存之后退出执行，让配置生效 数据存储目录 节点","categories":[],"tags":[]},{"title":"安装","slug":"TreasureBox/grafana/1. 安装","date":"2022-05-26T12:01:16.163Z","updated":"2023-04-28T09:25:47.206Z","comments":true,"path":"2022/05/26/treasurebox/grafana/1.an-zhuang/","link":"","permalink":"http://example.com/2022/05/26/treasurebox/grafana/1.an-zhuang/","excerpt":"","text":"Grafana安装Ubuntu 和 Debian （64 位）SHA256：86acf244ddbbb4b59d4b043d67ad504787facc49b76564f26bb6a5140af76d78 sudo apt-get install -y adduser libfontconfig1 wget https://dl.grafana.com/enterprise/release/grafana-enterprise_8.0.4_amd64.debsudo dpkg -i grafana-enterprise_8.0.4_amd64.deb 阅读 Ubuntu / Debian 安装指南 了解更多信息。 我们还提供了一个 APT 包存储库。 独立 Linux 二进制文件（64 位）SHA256：5a6ebec00a099a3b9231538ae1c5135853c8b7f4a668ba42aa5d43f77c34bcaf wget https://dl.grafana.com/enterprise/release/grafana-enterprise-8.0.4.linux-amd64.tar.gztar -zxvf grafana -enterprise-8.0.4.linux-amd64.tar.gz Red Hat、CentOS、RHEL 和 Fedora （64 位）SHA256：1ded5b790d22ef5e066de7724f8d74635377947dcfa3453428d235b01e0d108b wget https://dl.grafana.com/enterprise/release/grafana-enterprise-8.0.4-1.x86_64.rpmsudo yum install grafana-enterprise-8.0.4-1.x86_64.rpm OpenSUSE 和 SUSE wget https://dl.grafana.com/enterprise/release/grafana-enterprise-8.0.4-1.x86_64.rpmsudo rpm -i –nodeps grafana-enterprise-8.0.4-1.x86_64.rpm 配置项在/etc/grafana/grafana.ini文件中 centos7操作 12345[root@cxm ~]#systemctl daemon-reload[root@cxm ~]#systemctl start grafana-server[root@cxm ~]#systemctl stop grafana-server[root@cxm ~]#systemctl restart grafana-server[root@cxm ~]#systemctl status grafana-server","categories":[],"tags":[]},{"title":"git0-安装","slug":"TreasureBox/git命令/git0-安装","date":"2022-05-20T06:27:44.205Z","updated":"2023-04-28T09:25:47.222Z","comments":true,"path":"2022/05/20/treasurebox/git-ming-ling/git0-an-zhuang/","link":"","permalink":"http://example.com/2022/05/20/treasurebox/git-ming-ling/git0-an-zhuang/","excerpt":"","text":"安装 linux环境安装 1yum -y install git mac安装 windows安装","categories":[],"tags":[]},{"title":"Docker安装","slug":"TreasureBox/Docker/2.Docker安装","date":"2022-05-20T03:24:35.108Z","updated":"2023-04-28T09:25:47.108Z","comments":true,"path":"2022/05/20/treasurebox/docker/2.docker-an-zhuang/","link":"","permalink":"http://example.com/2022/05/20/treasurebox/docker/2.docker-an-zhuang/","excerpt":"","text":"title: Docker安装Docker安装 docker hub https://hub.docker.com/search/?type=image&amp;image_filter=official&amp;q= linux安装 先清理旧的docker镜像 12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装所需的软件包 1234567sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 sudo yum-config-manager \\ --add-repo \\ https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 安装最新版的docker engine-community和containerd 1sudo yum install docker-ce docker-ce-cli containerd.io 解决报错，执行完之后重新执行3 1sudo yum install docker-ce docker-ce-cli containerd.io 启动和测试 12sudo systemctl start dockersudo docker run hello-world mac安装","categories":[],"tags":[]},{"title":"hadoop03组件","slug":"TreasureBox/hadoop03组件","date":"2022-05-19T01:29:16.909Z","updated":"2023-04-28T09:25:47.097Z","comments":true,"path":"2022/05/19/treasurebox/hadoop03-zu-jian/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/hadoop03-zu-jian/","excerpt":"","text":"hadoop03机器启动hdfs，hbase bash /opt/module/hadoop-3.1.3/sbin/start-dfs.shbash /opt/module/hadoop-3.1.3/sbin/start-yarn.sh/opt/module/apache-zookeeper-3.7.0/bin/zkServer.sh startbash /opt/module/hbase-2.4.12/bin/start-hbase.shbash /opt/module/hbase-2.4.12/bin/hbase-daemons.sh –config $HBASE_HOME/conf start thrift –infoport 9096 -p 9097","categories":[],"tags":[]},{"title":"tencent","slug":"TreasureBox/总结/1.tencent","date":"2022-05-19T01:14:40.419Z","updated":"2023-04-28T09:25:47.179Z","comments":true,"path":"2022/05/19/treasurebox/zong-jie/1.tencent/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/zong-jie/1.tencent/","excerpt":"","text":"1、Mysql索引联合索引，联合索引不生效怎么办 1.索引失效分析工具：使用explain命令加在要分析的sql语句前面，在执行结果中查看key这一列的值，如果为NULL，说明没有使用索引。 索引失效的场景： or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效。 复合索引未使用左列索引，即不是使用第一列索引，索引失效。 like以%开头，当like前缀没有%，后缀有%时，索引有效; 需要类型转换; （比如在一个int字段中使用字符串进行查询，或者在varchar字段中使用int进行查询） where中索引列有运算，或者索引列使用了函数;（比如在查询name时使用LENGTH方法） where中在索引字段上使用not，&lt;&gt;，!=。（不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。key&lt;&gt;0 改为 key&gt;0 or key&lt;0。）不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。优化方法：key&lt;&gt;0 改为 key&gt;0 or key&lt;0。 如果mysql觉得全表扫描更快时（数据少）; 在索引列上使用 IS NULL 或 IS NOT NULL操作。 （索引是不索引空值的，所以这样的操作不能使用索引，可以用其他的办法处理，例如：数字类型，判断大于0，字符串类型设置一个默认值，判断是否等于默认值即可。） 2、分库分表设计怎么保证id的唯一 雪花算法、自增数据库控制 3、redis过期删除的策略 volatile-lru：从已设置过期时间的数据集（server.db[i].expires中挑选最近最少使用的数据淘汰。 allkeys-lru：从数据集（server.db[i].dict）中挑选最少使用的数据淘汰。 volatle-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。 volatle-lru ：从已设置过期时间的数据集（server.db[i].expires）中挑选最近使用次数最少的数据淘汰。 allkeys-lfu：从数据集（server.db[i].dict）中挑选最近使用次数最少的数据淘汰。 volatile-random：从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰。 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 4、redis的hash结构的key跟value都有哪些数据类型 5、mysql事务的隔离级别 读未提交：该事务中读取了其他事务未提交的数据，导致使用了脏数据。没有视图的概念。可能会导致脏读、幻读、不可重复读问题。 读已提交：一个事务修改了数据且成功提交事务后，才可查询到更新后的数据。读提交隔离时开始执行SQL时创建视图。 可重复读：一个事务在执行过程中查询到的数据，总是与该事务启动时看到的数据是一致的。未提交变更对其他事务也是不可见的。可重复读视图是在事务启动时创建的，整个事务期间都使用这个视图。 串行化：对于同一行记录，写会加写锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。川行化直接使用加锁的方式来避免并行访问。 6、脏读、幻读产生的场景 7、python代码怎么提升if，else的效率 8、python代码怎么进行测试 单元测试，unitest 9、python2跟python3的区别 python2 print是一个方法，py3是一个类 py2.6中对format方法有严格限制，必须使用下标 py2中除法使用的是地板除，比如5/2得到的是2。py3中得到的是2.5 py3默认编码是utf8，py2中使用utf8编码时需要显示指出 2.x raise语句使用逗号将抛出对象类型和参数分开，3.x取消了这种奇葩的写法，直接调用构造函数抛出对象即可，只有继承自BaseException的对象才可以被抛出。 py3中移除了&lt;&gt;表示不等于的写法 py3中移除了long类型，只有int类型 py3中的字典的keys、values、items方法返回的是迭代器。py2中返回的是列表。 six库中有很多兼容py2和py3的库 10、python的数据类型怎么存储的，哪些可变跟不可变 不可变：数字、字符串、远足 可变：列表、集合、字典 11、单点登录原理 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权 12、linux中查看端口占用，查看进程资源占用，哪些是close状态 lsof -i:端口或netstat -anp | grep 端口号 netstat -nulpt查看所有端口使用情况 ps -ef 13、常用的linux命令 top、ps、netstat、ls、cat、cd、vim、 14、GIL全局解释器锁 GIL使得对象模型都是可以并发访问。GIL全局解释器锁解决多线程之间数据完整性和状态同步的问题，但是这个锁在同一时刻只有一个线程在运行，所以在多核的情况下也只能发挥出单核的性能,多线程依旧像是单线程的运行 15、抓包工具 tcp dump 16、代码的异常怎么处理 try、catch 17、用过哪些orm框架，怎么实现的 peewee、sql_alchemy、底层基于pymysql 18、怎么查看sql的索引命中情况 explain语句 19、B树跟B+的区别。 B树，即二叉搜索树。 所有非叶子结点至多拥有两个儿子（left和right） 所有节点存储一个关键字 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树。 B树的搜索从根节点开始，如果查询的关键字与节点的关键字相等，那么命中；如果比节点小，则进入左分支。如果B树所有非叶子结点的左右子树节点树木均保持差不多（平衡），那么B树的查找频率逼近二分查找。但B树在经过多次插入删除后，有可能导致不同的结构，实际使用的B树是在原B树的基础上加上平衡算法，即平衡二叉树. B-树：是一种多路搜索树 定义任意非叶子结点最多只有M个儿子，且M&gt;2。 根节点的儿子数为[2,M] 除根节点以外的非叶子结点儿子数为[M/2,M] 每个节点存放至少M/2-1（向上取整）和至多M-1个关键字；至少(2个关键字) 非叶子结点的关键字:[k1]，[k2]，…k[M-1]；且k[i]&lt;k[i+1] 非叶子结点的关键字：k[1]，p[2],…,P[M]；其中p[1]指向关键字小于k[1]的子树，P[M]指向关键字大于k[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 所有叶子结点位于同一层；如（M=3） B-树的搜索从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复直到所对应的儿子指针为空，或已经是叶子结点。 B-树的特性： 关键字集合分布在整颗树中 任何一个关键字出现且只出现在一个节点中 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 自动层次控制 由于限制了除根节点以外的非叶子结点，至少含有M/2个儿子，确保了节点的至少利用率，底层搜索性能为Olong2N。B-树的性能总是等价于二分查找，也就没有B树平衡的问题。由于M/2的限制，在插入节点时，如果节点已满，需要将节点分裂为两个各占M/2的节点，删除节点时，需将两个不足M/2的兄弟节点合并。 B+树是B-树的变体，也是一种多路搜索树； 其定义基本与B-树相同 非叶子结点的子树指针与关键字个数相同 非叶子结点的子树指针P[i]，指向关键字属于[K[i],K[i+1]]的子树，B-树是开区间 为所有叶子结点增加一个链指针 所有关键字都在叶子结点出现。 B+树搜索也与B-树基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找； B+树特性： 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的。 不可能在非叶子结点命中 非叶子结点相当于叶子结点的索引（稀疏索引），叶子结点相当于存储（关键字）数据的数据层 更适合文件索引系统 B*树 是B+树的变体，在B+树的非根与非叶子结点再增加指向兄弟的指针。 B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）； ​ B+树的分裂： 当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针； B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针； B*树的分裂： 当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）； 如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针； 所以，B*树分配新结点的概率比B+树要低，空间使用率更高； 小结 B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点； B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；","categories":[],"tags":[]},{"title":"升哲科技","slug":"TreasureBox/总结/2.升哲科技","date":"2022-05-19T01:14:40.419Z","updated":"2023-04-28T09:25:47.178Z","comments":true,"path":"2022/05/19/treasurebox/zong-jie/2.sheng-zhe-ke-ji/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/zong-jie/2.sheng-zhe-ke-ji/","excerpt":"","text":"1、python多进程、多线程、协程，gil，100个请求怎么用50个线程跑 进程：程序的一次执行过程被成为进程，是CPU调度的最小单位 线程：进程由若干个线程组成，且最少有一个线程， 协程：微线程，切换受代码控制 2、tornado跟django的对比，tornado为什么这么快 tornado是协程，django是线程 3、设计模式，知道的设计模式有哪些，怎么使用？ 单例 工厂 MTV 修饰器模式 4、单例模式怎么用，使用场景？ 控制一个类只会产生一个对象，通常用于数据库连接 5、数据库连接池的概念 在 6、进程池 多进程共享某个消息队列，从队列中消费消息处理 7、除了mysql，mongo，redis三种数据库还用过哪些，优缺点是什么 sqlite，轻量级，并发支持很弱 8、nginx负载均衡 怎么实现？ 9、mysql使用在项目中怎么使用的？mysql索引怎么设计的，数据量大怎么分库分表，数据最多的多少 B+树，联合索引，自增为主键索引，char和varchar的区别， 按照日期分库分表， 或者地域，用户ID之类的信息 10、根据日期查询的时候怎么查，比如查5个月，数据在5张表中？ 通过中间件对数据查询请求进行切分，比如数据落库时根据time字段识别该数据应该落在哪里，查询时根据传入的time区间对查询做拆分。 11、redis在项目中怎么用的，底层实现原理 缓存。 str，list，hash，set，zset，布隆过滤器，队列等。各数据结构的底层实现？ 12、redis的持久化 RDB：快照 AOF：命令追加 13、redis怎么监听挂了没 哨兵，ElasticSearch采用类似的机制 14、mongo在项目中的使用 优势：非关系型数据库，数据按照文档行存储，存储不确定数据结构的场景 15、rabitmq使用场景，为什么选择，有没有更好的 削峰填谷，单播广播 kafka等 16、redis哨兵 ��广播 kafka等 16、redis哨兵","categories":[],"tags":[]},{"title":"数据结构初识","slug":"TreasureBox/数据结构/1.数据结构初识","date":"2022-05-19T01:14:40.419Z","updated":"2023-04-28T09:25:47.104Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-jie-gou/1.shu-ju-jie-gou-chu-shi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-jie-gou/1.shu-ju-jie-gou-chu-shi/","excerpt":"","text":"数据结构分为逻辑结构和物理结构 逻辑结构：指数据对象中数据元素之间的相互关系，也是最需要关注和讨论的问题。 物理结构：指数据的逻辑结构在计算机中的存储形式。 一、逻辑结构1、集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他不三不四的关系。 2、线性结构：元素之间一对一的关系 3、树形结构：数据元素之间存在一种一对多的层次关系，类似树。 4、图形结构：图形结构的元素是多对多的关系。 二、物理结构1、存储器主要是针对计算机中的内存而言。 2、数据元素的存储形式有两种：顺序存储和链式存储， 顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。通过指针存放数据元素的地址，获取元素的顺序。 三、什么是算法算法是解决特定问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作。 算法特征：输入，输出，有穷性，确定性，可行性。 四、线性表线性表(List)：由零个或多个数据元素组成的有限序列。 首先它是一个序列，也就是元素之间有先来后到。 若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。 线性表强调是有限的，无论计算机发展到多强大，它处理的元素都是有限的。 数据结构包含： 数组、链表、栈、队列、树��列、树","categories":[],"tags":[]},{"title":"1、TCPIP网络模型","slug":"TreasureBox/网络协议/1、TCPIP网络模型","date":"2022-05-19T01:14:40.419Z","updated":"2023-04-28T09:25:47.105Z","comments":true,"path":"2022/05/19/treasurebox/wang-luo-xie-yi/1-tcpip-wang-luo-mo-xing/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/wang-luo-xie-yi/1-tcpip-wang-luo-mo-xing/","excerpt":"","text":"[TOC] 一、TCP/IP网络模型计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信，使用哪种语言进行通信、怎样结束通信等规则都事先确定。 TCP/IP是互联网相关的是互联网相关的各类协议簇的总称，比如TCP，UDP，IP，FTP，HTTP，ICMP，SMTP等属于TCP/IP族内的协议。 TCP/IP模型是互联网的基础，它是一些列网络协议的总称，这些协议可以分为四层。 链路层：负责封装和解封装IP报文，发送和接收ARP/RARP报文等。 网络层：负责路由以及把分组报文发送给目标网络或主机 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。 应用层：负责向用户提供应用程序，比如HTTP，FTP，Telnet，DNS，SMTP等。 OSI七层模型 TCP/IP概念层模型 功能 TCP/IP协议簇 应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 表示层 数据格式化，代码转换，数据加密 没有协议 会话层 应用层 解除或建立与别的接点的联系 没有协议 传输层 传输层 提供对端的接口 TCP，UDP 网络层 网络层 为数据包选择路由 IP，TCMP，RIP，OSPF，ICMP 数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，MTV 物理层 链路层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 二、UDPUDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OIS，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组，组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。 1、面向无连接首先UDP是不需要和TP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。 具体就是： 在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传输给网络层了。 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不回拼接操作。 2、有单播、多播、广播功能UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。 3、UDP是面向报文的发送方的UDP对应用程序交下来的报文，在添加首部后就向下交给IP层。UDP对应用层交下来的报文，既不合并也不拆分，而是保留这些报文的边界。因此。应用程序必须选择合适大小的报文。 4、不可靠性首先不可靠性体现在无连接上，通信都不需要建立连接。想发就发。这样的情况不可靠。 并且收到什么数据就传递什么数据，并且不会备份数据，发送数据也不回关心对方是否已经正确接收数据。 网络环境时好时坏，但是UDP没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不回对发送频率调整，这样的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景(比如电话会议)就需要使用UDP而不是TCP。 5、头部开销小，传输数据报文时很高效。 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的校验和(IPv4可选字段)，该字段用于头部信息和数据中的错误。 因此UDP的头部开销少，只有八字节，相比TCP的至少二十字节要少得多，在传输数据报文时是很高效的。 三、TCP当一台计算机想要跟另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如：查看网页或电子邮件时，希望完整且顺序查看网页，下载文件时，希望获得完整的文件，而不仅仅是文件的一部分，这时就需要用到TCP。 TCP全称是传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC793定义，TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构。 1、连接过程第一次握手：客户端向服务端发送连接请求报文段，该报文段中包含自身的数据通讯初识序号。请求发送后，客户端便进入SYN-SENT状态。 第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入SYN—RECEIVED状态。 第三次握手：当客户端收到连接同意后，还要向服务端发送一个确认报文。客户端发完这个报文段之后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接建立成功。 为什么TCP建立连接需要三次握手，而不是两次呢？这是因为为了防止出现时效的链接请求报文段被服务端接收的情况，从而产生错误。 2、TCP断开连接TCP是全双工的，在断开连接时两端都需要发送FIN和ACK。 第一次挥手：若客户端A认为数据发送完成，则它需要向服务端B发送连接释放请求。 第二次挥手：B收到连接释放请求后，会告诉应用层钥匙房TCP连接，然后会发送ACK包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。 第三次挥手：B如果此时有未发送完成的数据会继续发送，发送完毕后会向A发送连接释放请求，然后B便进入LAST-ACK状态。 第四次挥手：A收到释放请求后，向B发送确认应答，此时A进入TIME—WAIT状态。该状态会持续2MSL（最大段生存期，只报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段没有B的重发请求的话，就会进入CLOSED状态。当B收到确认应答后，也便进入CLOSED状态。 3、TCP协议的特点 面向连接 面向连接，是指发送数据之前必须在两端建立连接。建立连接的方式是三次握手，这样可以建立可靠的链接。建立连接是为数据的可靠传输做基础。 仅支持单播传输 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 面向字节流 TCP不像UDP一样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 可靠传输 对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已经成功收到的字节发回一个想要的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据(假设丢失了)将会被重传。 提供拥塞控制 当网络出现拥塞时，TCP能够减少向网络注入数据的速率和数量，缓解拥塞。 TCP提供全双工通信 TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP链接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）。 四、TCP和UDP对比1、对比 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小 首部最小20字节，最大60字节 适用场景 适用于实时应用(IP电话、视频会议、直播等) 适用于要求可靠传输的应用，比如文件传输等。 2、总结 TCP虽然向上层提供面向连接的可靠服务，UDP向上层提供无连接不可靠服务。 虽然UDP并没有TCP传输来的准确，但是也能在很多实时性要求高的地方有所作为。 对数据准去性要求高，速度可以相对慢的，可以选用TCP。 ��求高的地方有所作为。 对数据准去性要求高，速度可以相对慢的，可以选用TCP。","categories":[],"tags":[]},{"title":"redis常见面试题","slug":"TreasureBox/数据库/redis/1.redis常见面试题","date":"2022-05-19T01:14:40.416Z","updated":"2023-04-28T09:25:47.191Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/redis/1.redis-chang-jian-mian-shi-ti/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/redis/1.redis-chang-jian-mian-shi-ti/","excerpt":"","text":"一、Redis常见面试题 redis基本数据类型 有String，Hash，List，Set，Sort，SortedSet五种基本的数据结构，除此以外，还有HyperLogLog，Geo，Pub/Sub三种，还有Redis Module像BloomFilter，RedisSearch，Redis-ML。 大量key过期时间设置同一个时间过期，一般需要注意什么？ 如果大量的key过期时间设置的过于集中，到过期的时间点时，redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，一般需要在过期时间上加一个随机值，使得过期时间分散一些。 加上首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好卡在失效的时间点大量用户涌入，就有可能造成缓存雪崩。 使用过redis分布式锁吗？是怎么回事？ 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？ 使用set指令可以把setnx和expire合成一条指令使用。 假入redis中有1亿个key，其中有10W个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？ 使用keys指令可以扫出指定模式的key列表。 如果redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ redis是单线程，keys指令会导致线程阻塞一段时间，线上服务会停顿，指导指令执行完毕，服务才能恢复。这个时候可以试用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 不过，增量式迭代命令也不是没有缺点的：试用SMEMBERS命令可以返回集合键当前包含的所有元素，但是对于scan这类增量式迭代命令来说，因为在对键进行增量式迭代的过程中，键可能会被修改，所以增量式迭代命令只能对被返回的元素提供有限的保证。 使用过redis做异步队列吗？是怎么使用的？ 一般使用list结构做为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，要适当sleep一会再重试。 如果不使用sleep呢？ list有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 能不能一次消费多次？ 使用pub/sub主题订阅者模式，可以实现1:N的消息队列。 pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等。 Redis如何实现延时队列？ 使用sorted set，用时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。 Redis是怎么持久化的？服务主从数据怎么交互的？ RDB做镜像全量持久化，AOF做增量持久化，因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。 如果突然机器掉电会怎样？ 取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。 RDB的原理是什么？ fork和cow，fork指redis通过创建子进程来进行RDB操作，cow指copy onwrite，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。 Pipeline有什么好处，为什么要用pipeline。可以将多次IO往返的时间缩短为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。 Redis的同步机制有了解么？ Redis可以使用主从同步、从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后。在通过主节点将期间修改的操作记录同步到负直节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可。有点类似数据库的binlog。 是否使用过redis集群，集群的高可用怎么保证，集群的原理是什么？ Redis Sentinal 着眼于高可用，在master宕机时会自动将salve提升为master，继续提供服务。 Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。使用Cluster进行分片存储。","categories":[],"tags":[]},{"title":"1基本命令","slug":"TreasureBox/数据库/redis/2.1基本命令","date":"2022-05-19T01:14:40.416Z","updated":"2023-04-28T09:25:47.188Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/redis/2.1-ji-ben-ming-ling/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/redis/2.1-ji-ben-ming-ling/","excerpt":"","text":"[TOC] 一、redis基础知识客户端和服务器命令：​ 默认端口号6379 服务器命令：​ redis-server redis.windows.conf 客户端命令：​ redis-cli 一个redis.windows.conf配置文件，就是一个redis服务器。需要启动多个服务器时，只需修改配置文件的名称，再使用redis-server命令即可。 redis和memcache相比的独特之处 redis可以用来存储(storge)，有持久化的功能（是可以存储到硬盘中），而memcached用来做缓存（cache）。 redis存储的数据有结构；对于memcache来说，存储的数据只有一种数据类型——字符串，而redis则可以存储字符串，链表，哈希结构，集合，有序集合。， redis目录下的重要文件的意义 redis-benchmark：性能测试工具 redis-check-dump：日志文件检测工具（比如断电造成日志损坏，可以检测并修复。） redis-check-dump：快照文件检测工具，效果同上。 redis-cli：客户端。 redis-server：服务端 redis.windows.conf：配置文件 二：基础命令 **keys ***：返回所有的key keys list：返回名以list开头的所有key exists list1：判断名为list1的key是否存在，存在返回1，不存在返回0 del list1：删除一个键list1 exprice list1 10：设置键名为list1的过期时间为10秒后 ttl list1：查看键名为list1的过期时间，若为-1，表示以过期或永不过期 move age 1：将键名为age的转移到1数据库中 select 1：表示进入1数据库，默认在0中，一共有16个，从0到15 persist age：移除age的过期时间。 flushdb：删除所有的数据，清除当前所在库的所有数据。 flushall：清空所有数据。 （一）.字符串类型 存命令 取命令 mset mget setnx msetnx incr decr incrby decrby setrange getrange set get set方法：设置key对应的值为string类型的value，如果该key已经存在，则覆盖，所以在redis中key唯一。 12127.0.0.1:6379&gt; set name lijieOK get：根据key获取value的值 12127.0.0.1:6379&gt; get name\"lijie\" setnx：设置一个不存在的字符串，返回0表示设置失败，已存在。返回1表示设置新值成功，nx是not exit的意思。 1234127.0.0.1:6379&gt; setnx name zs(integer) 0127.0.0.1:6379&gt; setnx age 20(integer) 1 setex：设置字符串，同时设置有效期 12345678127.0.0.1:6379&gt; setex lvjia 10 'jia'OK（立即查询）127.0.0.1:6379&gt; get lvjia\"jia\"（10秒后启动）127.0.0.1:6379&gt; get lvjia(nil) setrange：替换字符串，参数为开始位置下标(从0开始)，替换成什么 12345678127.0.0.1:6379&gt; set email lvjia@sina.comOK127.0.0.1:6379&gt; get email\"lvjia@sina.com\"127.0.0.1:6379&gt; setrange email 6 163.com(integer) 14127.0.0.1:6379&gt; get email\"lvjia@163.comm\" msetnx：一次设置多个不存在的key-value，返回1表示全部设置成功，返回0表示全部失败。 12345678910127.0.0.1:6379&gt; msetnx name3 kk name4 mm name2 lvjia(integer) 1127.0.0.1:6379&gt; get name3\"kk\"127.0.0.1:6379&gt; get name2\"lvjia\"127.0.0.1:6379&gt; get name4\"mm\"127.0.0.1:6379&gt; msetnx name3 cc name4 dd(integer) 0 getset：获取原值，并设置新值 1234127.0.0.1:6379&gt; getset name4 UU\"mm\"127.0.0.1:6379&gt; get name4\"UU\" getrange：获取key对应value的子字符串 12127.0.0.1:6379&gt; getrange email 0 4\"lvjia\" mget：一次获取多个key对应的value值，不存在返回nil 1234567127.0.0.1:6379&gt; mget name1 name2 name3 name4 name5 name61) (nil)2) \"lvjia\"3) \"kk\"4) \"UU\"5) (nil)6) (nil) incr：对key对应的value做加1操作，并返回新值 1234127.0.0.1:6379&gt; get age\"21\"127.0.0.1:6379&gt; incr age(integer) 22 incrby：与incr类似，加指定值，key不存在的时候会设置key，并认为该key原来的value=0 12345678910127.0.0.1:6379&gt; get age\"22\"127.0.0.1:6379&gt; incrby age 9(integer) 31127.0.0.1:6379&gt; get height(nil)127.0.0.1:6379&gt; incrby height 10(integer) 10127.0.0.1:6379&gt; get height\"10\" decr：对key对应的value做减1操作。 1234127.0.0.1:6379&gt; get height\"10\"127.0.0.1:6379&gt; decr height(integer) 9 decrby:对key对应的value减去指定的值 123456127.0.0.1:6379&gt; get height\"9\"127.0.0.1:6379&gt; decrby height 3(integer) 6127.0.0.1:6379&gt; decrby height -3(integer) 9 append:对key对应的value字符串追加，返回新字符串的长度 123456127.0.0.1:6379&gt; get name\"lijie\"127.0.0.1:6379&gt; append name ML(integer) 7127.0.0.1:6379&gt; get name\"lijieML\" strlen:获取key对应value的长度 123456127.0.0.1:6379&gt; get name\"lijie\"127.0.0.1:6379&gt; append name ML(integer) 7127.0.0.1:6379&gt; get name\"lijieML\" del：删除指定key，可一下指定多个，会返回删除成功的条数 12345678910127.0.0.1:6379&gt; get name\"lijieML\"127.0.0.1:6379&gt; del age name(integer) 2127.0.0.1:6379&gt; get name(nil)127.0.0.1:6379&gt; get age(nil)127.0.0.1:6379&gt; del name1(integer) （二）.hash类型Redis hash是一个string类型的filed和value的映射表。Hash特别适合存储对象。相比较于对象的每个字段存成单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便存取整个对象。 hset：设置hash field为指定值，如果key不存在，则先创建，key存在则替换，如果不存在时返回1，存在时返回0。 1234127.0.0.1:6379&gt; hset user:001 name zs(integer) 1127.0.0.1:6379&gt; hset user:001 name lvjia(integer) 0 hget：获取指定field字段的值 12127.0.0.1:6379&gt; hget user:001 name\"lvjia\" hsetnx：设置hash field为指定值，如果key不存在，则先创建，如果存在则返回0，表示设置失败。 1234127.0.0.1:6379&gt; hsetnx user:001 name dachang(integer) 0127.0.0.1:6379&gt; hsetnx user:001 age 20(integer) 1 hmset：同时设置hash的多个field 123456127.0.0.1:6379&gt; hmset user:002 name lvjia age 20OK127.0.0.1:6379&gt; hget user:002 name\"lvjia\"127.0.0.1:6379&gt; hget user:002 age\"20\" hmget：获取多个指定的hash field，必须指定获取的key的名称 123127.0.0.1:6379&gt; hmget user:002 name age1) \"lvjia\"2) \"20\" hincrby：对hash field加上指定的值 123456127.0.0.1:6379&gt; hget user:002 age\"20\"127.0.0.1:6379&gt; hincrby user:002 age 5(integer) 25127.0.0.1:6379&gt; hincrby user:002 age -4(integer) 21 hexists：测试指定的field是否存在，返回1表示存在，返回0表示不存在。 123456127.0.0.1:6379&gt; hexists user:002 name(integer) 1127.0.0.1:6379&gt; hexists user:002 age(integer) 1127.0.0.1:6379&gt; hexists user:002 height(integer) 0 hdel：返回指定hash的field的数量，返回1表示删除成功，0表示删除失败 1234127.0.0.1:6379&gt; hdel user:001 age(integer) 1127.0.0.1:6379&gt; hdel user:001 address(integer) 0 hkeys：返回hash的所有field 12345127.0.0.1:6379&gt; hkeys user:0011) \"name\"127.0.0.1:6379&gt; hkeys user:0021) \"name\"2) \"age\" hvals:返回hash的所有value 12345127.0.0.1:6379&gt; hvals user:0011) \"lvjia\"127.0.0.1:6379&gt; hvals user:0021) \"lvjia\"2) \"21\" hlen:返回hash的key的长度 12127.0.0.1:6379&gt; hlen user1) \"lvjia\" （三）.list类型list是一个链表结构，主要功能是push、pop，获取一个范围的所有值等等，操作中key理解为链表的名字。Redis的list类型其实就是一个每个子元素都是string类型的双向链表。我们可以通过push、pop这些操作链表的头部或者链表尾部添加元素，这样list既可以为栈，又可以作为队列。 lpush：在key对应list的头部添加字符串元素，返回list元素中的个数 1234127.0.0.1:6379[1]&gt; lpush list1 \"hello\"(integer) 1127.0.0.1:6379[1]&gt; lpush list1 \"word\"(integer 2 lrange：获取list中的元素，后边跟两个参数分别代表起始位置和结束位置。 123127.0.0.1:6379[1]&gt; lrange list1 0 -11) \"word\"2) \"hello\" rpush：在key对应的list尾部添加元素 12345678910127.0.0.1:6379[1]&gt; rpush list2 10(integer) 1127.0.0.1:6379[1]&gt; rpush list2 11(integer) 2127.0.0.1:6379[1]&gt; rpush list2 12(integer) 3127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"10\"2) \"11\"3) \"12\" linsert：在key对应list的特定位置前或者后添加字符串 1234567891011121314127.0.0.1:6379[1]&gt; linsert list2 before 11 10.5(integer) 4127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"10\"2) \"10.5\"3) \"11\"4) \"12\"127.0.0.1:6379[1]&gt; linsert list2 before 1 2(integer) -1127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"10\"2) \"10.5\"3) \"11\"4) \"12\" lset：更改list中指定下标的元素，返回ok表示设置成功 1234567891011121314127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"10\"2) \"10.5\"3) \"11\"4) \"12\"127.0.0.1:6379[1]&gt; lset list2 1 10.00OK127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"10\"2) \"10.00\"3) \"11\"4) \"12\"127.0.0.1:6379[1]&gt; lset list2 10 10.00(error) ERR index out of range lrem：从key对应list中删除n个和value相同的元素(n&lt;0从尾部删除，n=0全部删除) 123456789127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"10.00\"2) \"11\"3) \"12\"127.0.0.1:6379[1]&gt; lrem list2 2 10.00(integer) 1127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"11\"2) \"12\" ltrim：保留list中指定范围的数据全部删除 1234567891011127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"11\"2) \"12\"3) \"10\"4) \"20\"5) \"30\"127.0.0.1:6379[1]&gt; ltrim list2 1 2OK127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"12\"2) \"10\" lpop：从list的头部删除元素，并返回该元素 1234567127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"12\"2) \"10\"127.0.0.1:6379[1]&gt; lpop list2\"12\"127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"10\" rpop：从list尾部删除元素，并返回该元素 rpoplpush：从第一个list的尾部删除元素，并添加到第二个list的头部。 123456789101112127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"10\"127.0.0.1:6379[1]&gt; lrange list1 0 -11) \"word\"2) \"hello\"127.0.0.1:6379[1]&gt; rpoplpush list1 list2\"hello\"127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"hello\"2) \"10\"127.0.0.1:6379[1]&gt; lrange list1 0 -11) \"word\" lindex：返回名称为key的list中的index位置的元素 12345127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"hello\"2) \"10\"127.0.0.1:6379[1]&gt; lindex list2 1\"10\" llen：返回指定key对应list的长度 12345127.0.0.1:6379[1]&gt; lrange list2 0 -11) \"hello\"2) \"10\"127.0.0.1:6379[1]&gt; llen list2(integer) 2 （四）.set类型Set是一个string类型的无序集合，不允许重复。Set是通过hash table实现的。添加、删除、查找复杂度都是0/1。对集合我们可以取并集、交集、差集。 sadd：向key对应的set集合中添加元素，返回1表示添加成功，返回0表示失败。 1234567127.0.0.1:6379[2]&gt; sadd myset1 lvjia(integer) 1127.0.0.1:6379[2]&gt; sadd myset1 lvjia(integer) 0127.0.0.1:6379[2]&gt; sadd myset1 dachang(integer) 1 smembers：查看集合中的元素 123127.0.0.1:6379[2]&gt; smembers myset11) \"dachang\"2) \"lvjia\" srem：删除key对应set集合中的元素，返回1表示删除成功，0表示失败。 1234567127.0.0.1:6379[2]&gt; smembers myset11) \"dachang\"2) \"lvjia\"127.0.0.1:6379[2]&gt; srem myset1 two(integer) 0127.0.0.1:6379[2]&gt; srem myset1 dachang(integer) 1 spop：随即删除set中的一个元素并返回该元素 1234567127.0.0.1:6379[2]&gt; spop myset1\"dachang\"127.0.0.1:6379[2]&gt; spop myset1\"haha\"127.0.0.1:6379[2]&gt; smembers myset11) \"wahaha\"2) \"lvjia\" sdiff：返回给定set集合的差集（以前边的set集合为标准） 12345678910127.0.0.1:6379[2]&gt; smembers myset21) \"hhaha\"2) \"haha\"3) \"wahaha\"127.0.0.1:6379[2]&gt; smembers myset11) \"wahaha\"2) \"lvjia\"127.0.0.1:6379[2]&gt; sdiff myset2 myset11) \"hhaha\"2) \"haha\" sdiffstore：返回所有给定的set集合的差集，并将差集添加到另一个集合中。 1234567891011127.0.0.1:6379[2]&gt; smembers myset11) \"wahaha\"2) \"lvjia\"127.0.0.1:6379[2]&gt; smembers myset21) \"hhaha\"2) \"haha\"3) \"wahaha\"127.0.0.1:6379[2]&gt; sdiffstore myset3 myset1 myset2(integer) 1127.0.0.1:6379[2]&gt; smembers myset31) \"lvjia\" sinter：返回所有给定集合的交集。 123456789127.0.0.1:6379[2]&gt; smembers myset11) \"wahaha\"2) \"lvjia\"127.0.0.1:6379[2]&gt; smembers myset21) \"hhaha\"2) \"haha\"3) \"wahaha\"127.0.0.1:6379[2]&gt; sinter myset1 myset21) \"wahaha\" sinterstore：返回所有给定集合key的交集，并将结果存为另一个key 12345678910111213127.0.0.1:6379[2]&gt; smembers myset11) \"wahaha\"2) \"lvjia\"127.0.0.1:6379[2]&gt; smebers myset2(error) ERR unknown command 'smebers'127.0.0.1:6379[2]&gt; smembers myset21) \"hhaha\"2) \"haha\"3) \"wahaha\"127.0.0.1:6379[2]&gt; sinterstore myset4 myset1 myset2(integer) 1127.0.0.1:6379[2]&gt; smembers myset41) \"wahaha\" sunion：返回所有给定集合的并集。 12345127.0.0.1:6379[2]&gt; sunion myset1 myset21) \"hhaha\"2) \"haha\"3) \"lvjia\"4) \"wahaha\" sunionstore：返回所有给定集合的并集，并将结果存入另一个集合。 1234567891011121314127.0.0.1:6379[2]&gt; smembers myset11) \"wahaha\"2) \"lvjia\"127.0.0.1:6379[2]&gt; smembers myset21) \"hhaha\"2) \"haha\"3) \"wahaha\"127.0.0.1:6379[2]&gt; sunionstore myset5 myset1 myset2(integer) 4127.0.0.1:6379[2]&gt; smembers myset51) \"hhaha\"2) \"haha\"3) \"lvjia\"4) \"wahaha\" smove：从第一个集合中移除元素并将该元素添加到另一个集合中。 123456789101112127.0.0.1:6379[2]&gt; smembers myset11) \"wahaha\"2) \"lvjia\"127.0.0.1:6379[2]&gt; smembers myset21) \"hhaha\"2) \"haha\"3) \"wahaha\"127.0.0.1:6379[2]&gt; smove myset2 myset1 wahaha(integer) 1127.0.0.1:6379[2]&gt; smembers myset11) \"wahaha\"2) \"lvjia\" scard：返回set集合中元素的个数。llen(list),strlen(str)，hlen(hash) 12345127.0.0.1:6379[2]&gt; smembers myset21) \"hhaha\"2) \"haha\"127.0.0.1:6379[2]&gt; scard myset1(integer) 2 sismember：测试member元素是否是名为key的set集合，返回1表示是，返回0表示不是。 1234567127.0.0.1:6379[2]&gt; smembers myset11) \"wahaha\"2) \"lvjia\"127.0.0.1:6379[2]&gt; sismember myset1 two(integer) 0127.0.0.1:6379[2]&gt; sismember myset1 wahaha(integer) 1 srandmember：随即返回set集合中的几个元素，但不删除这几个元素 12345678127.0.0.1:6379[2]&gt; srandmember myset1\"wahaha\"127.0.0.1:6379[2]&gt; smembers myset21) \"hhaha\"2) \"haha\"127.0.0.1:6379[2]&gt; srandmember myset1 21) \"lvjia\"2) \"wahaha\" （五）.sorted set类型sorted set是set的一个升级版，它在set的基础上增加了一个顺序属性，这一属性在添加元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以理解为有两列的MySQL表，一列存value，一列存顺序。操作key理解为zset的名字。 zadd：向有序集合zset中添加元素并指定顺序，如果该元素已存在就更新元素顺序。 1234127.0.0.1:6379[3]&gt; zadd myzset1 1 one(integer) 1127.0.0.1:6379[3]&gt; zadd myzset1 2 two(integer) 1 zrange：从zset集合中取元素，（withscores）输出元素顺序号 12345127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"one\"2) \"1\"3) \"two\"4) \"2\" zrem：删除zset集合中指定的元素 1234567127.0.0.1:6379[3]&gt; zrem myzset1 dachang(integer) 1127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"one\"2) \"1\"3) \"lvjia\"4) \"5\" zincrby：若zset中已经存在元素member、则该元素的score增加increment否则向该集合中添加该元素，其score的值为increment。 1234567891011121314127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"one\"2) \"1\"3) \"lvjia\"4) \"5\"127.0.0.1:6379[3]&gt; zincrby myzset1 2 one\"3\"127.0.0.1:6379[3]&gt; zincrby myzset1 2 one\"5\"127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"lvjia\"2) \"5\"3) \"one\"4) \"5\" zrank：返回zset中元素member的排名(score从小到大排序)即下标 1234567891011127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"dachang\"2) \"1\"3) \"lvjia\"4) \"2\"5) \"one\"6) \"5\"127.0.0.1:6379[3]&gt; zrank myzset1 dachang(integer) 0127.0.0.1:6379[3]&gt; zrank myzset1 lvjia(integer) 1 zrevrank：返回zset集合中member元素的排名（按照score倒叙）即下标 123456789127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"dachang\"2) \"1\"3) \"lvjia\"4) \"2\"5) \"one\"6) \"5\"127.0.0.1:6379[3]&gt; zrevrank myzset1 dachang(integer) 2 zrevrange：从zset集合中倒叙（score倒叙）获取元素 1234567127.0.0.1:6379[3]&gt; zrevrange myzset1 0 -1 withscores1) \"one\"2) \"5\"3) \"lvjia\"4) \"2\"5) \"dachang\"6) \"1\" zrangebyscore：从zset集合中根据score顺序获取元素 12345678910127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"dachang\"2) \"1\"3) \"lvjia\"4) \"2\"5) \"one\"6) \"5\"127.0.0.1:6379[3]&gt; zrangebyscore myzset1 4 5 withscores1) \"one\"2) \"5\" zcount：返回zset集合中score在给定区间的所有元素个数 123456789127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"dachang\"2) \"1\"3) \"lvjia\"4) \"2\"5) \"one\"6) \"5\"127.0.0.1:6379[3]&gt; zcount myzset1 4 5(integer) 1 zcard：返回zset集合中所有元素个数 123456789127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"dachang\"2) \"1\"3) \"lvjia\"4) \"2\"5) \"one\"6) \"5\"127.0.0.1:6379[3]&gt; zcard myzset1(integer) 3 zremrangebyrank：删除集合中排名（下标）在给定区间的元素。 123456789101112127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"lvjia\"2) \"1\"3) \"dachang\"4) \"2\"5) \"haha\"6) \"3\"127.0.0.1:6379[3]&gt; zremrangebyrank myzset1 0 1(integer) 2127.0.0.1:6379[3]&gt; zrange myzset1 0 -1 withscores1) \"haha\"2) \"3\" zremrangebyscore：删除集合中顺序（score值）在给定区间的元素 12345678910111213141516171819202122232425262728127.0.0.1:6379[9]&gt; ZADD myzset 1 \"one\"(integer) 1127.0.0.1:6379[9]&gt; ZADD myzset 2 \"two\"(integer) 1127.0.0.1:6379[9]&gt; ZADD myzset 3 \"three\"(integer) 1127.0.0.1:6379[9]&gt; ZADD myzset 4 \"four\"(integer) 1127.0.0.1:6379[9]&gt; ZADD myzset 5 \"five\"(integer) 1127.0.0.1:6379[9]&gt; zrange myset 0 -1(empty list or set)127.0.0.1:6379[9]&gt; zrange myzset 0 -11) \"one\"2) \"two\"3) \"three\"4) \"four\"5) \"five\"127.0.0.1:6379[9]&gt; ZREMRANGEBYSCORE myzset 2 4(integer) 3127.0.0.1:6379[9]&gt; zrange myzset 0 -11) \"one\"2) \"five\"127.0.0.1:6379[9]&gt; zrange myzset 0 -1 withscores1) \"one\"2) \"1\"3) \"five\"4) \"5\" （六）发布/订阅（七）布隆过滤器 12345678910111213141516171819202122232425262728127.0.0.1:6379[9]&gt; ZADD myzset 1 \"one\"(integer) 1127.0.0.1:6379[9]&gt; ZADD myzset 2 \"two\"(integer) 1127.0.0.1:6379[9]&gt; ZADD myzset 3 \"three\"(integer) 1127.0.0.1:6379[9]&gt; ZADD myzset 4 \"four\"(integer) 1127.0.0.1:6379[9]&gt; ZADD myzset 5 \"five\"(integer) 1127.0.0.1:6379[9]&gt; zrange myset 0 -1(empty list or set)127.0.0.1:6379[9]&gt; zrange myzset 0 -11) \"one\"2) \"two\"3) \"three\"4) \"four\"5) \"five\"127.0.0.1:6379[9]&gt; ZREMRANGEBYSCORE myzset 2 4(integer) 3127.0.0.1:6379[9]&gt; zrange myzset 0 -11) \"one\"2) \"five\"127.0.0.1:6379[9]&gt; zrange myzset 0 -1 withscores1) \"one\"2) \"1\"3) \"five\"4) \"5\" （六）发布/订阅（七）布隆过滤器","categories":[],"tags":[]},{"title":"redis高阶","slug":"TreasureBox/数据库/redis/3.redis高阶","date":"2022-05-19T01:14:40.416Z","updated":"2023-04-28T09:25:47.190Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/redis/3.redis-gao-jie/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/redis/3.redis-gao-jie/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"索引","slug":"TreasureBox/数据库/mysql/6.索引","date":"2022-05-19T01:14:40.414Z","updated":"2023-04-28T09:25:47.202Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/6.suo-yin/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/6.suo-yin/","excerpt":"","text":"索引一、索引介绍 1、索引是为了提升查询速度，会降低添加数据、更新数据、删除数据的速度。 2、经常用于where查询条件的字段添加索引 如：id。 3、字段重复数据较大的数据不适合添加索引，如：性别，保证数据的唯一性，唯一性越高查询速度越快。 4、数量较少的表，不适合添加索引。 索引介绍 用处： 几乎所有的索引都是添加到字段中的 作用： 使用索引，是为了加快查询速度，提高查询效率，约束数据的有效性 原理： 系统根据某种算法或者未来添加的数据，单独建立一个文件，实现快速匹配查找 索引的优点 通过唯一索引可以创建出每一行数据的唯一性 可大大提高数据库的检索速度，这是最主要的原因 加强表与表之间的联系，实现多表查询 在分组和排序中，同样可以少耗费很多时间 可以提高表的性能 索引的缺点 运行速度： 添加索引会延缓插入数据和修改数据的速度 耗费空间： 索引本身产生的文件就有可能比数据的文件还要大 消耗时间： 创建索引和维护索引要耗费时间，这种时间是根据数据量的增加而增加 ​ 索引的分类​ 1.主键索引​ 作用： 确定数据表中一条特定数据记录的位置​ 关键字： primary key​ 创建： 一般创建在建表时候 id int not null auto_increment primary key​ 注意： 主键不能为空，一个表中只能有一个主键索引​ 2.外键索引​ 概念： 外面的键，不是在自己的表中，如果一张表中的一个字段（非主键）指向另一张表中的主键，那么可以称该字段为外键​ 作用： 用来在多表查询的时候方便联系两表数据​ 关键字： foreign key​ 使用： foreign key（外键名） references 主表（主键）​ 约束​ 对子表： 在对子表进行增和改的时候，如果外键对应在父表中找不到，那么就会失败​ 对父表： 在对父表进行删和改的时候，如果在主表中已有数据被引用，那么也将失败​ 外键的形成条件​ 要求表类型必须是innodb​ 如果不是innodb，那么即使创表成功，也没有了约束的效果​ 外键的数据类型必须与主键的数据类型一致​ 在一张表中外键名不能重复​ 如果数据存在，那么必须保证外键中的数据和附表中的主键数据一致​ 3.唯一索引​ 作用： 唯一索引是为了避免出现重复的值，他的存在不是为了提高访问速度，而是避免出现重复数据​ 关键字： unique​ 使用： 一般在创建列的时候使用 name char（30） not null default ‘DB’ unique​ 注意： 只有确认某一列不能出现重复的值得时候才能使用​ 4.普通索引​ 概念： 普通索引依附在某一列上，提高查询速度​ 关键字： index​ 使用： create index 索引名 on 表名（列名）​ 索引的操作​ 查看索引： show index from 表名​ 删除索引： drop index 索引名 on 表名 二、索引的创建 使用alter table 语句创建索引 普通索引： alter table table_name add index index_name(字段); 唯一索引： alter table table_name add unique(字段); 主键索引： alter table table_name add primary key(字段); 使用create index 语句对表增加索引 create index index_name on table_name(username(length)); 如果是char或varchar类型，length可以小于字段实际长度；如果是text类型，必定要指定length create 只能创建两种索引：普通索引和唯一索引 create index index_name on table_name(字段); create unique index index_name on table_name(字段); 三、删除索引​ 删除索引可以使用alter table 或drop index 语句来实现，drop index 可以在alter table 内部作为一条语句来处理 ​ 格式：drop index index_name on table_name; ​ alter table table_name drop index index_name; ​ alter table table_name drop primary key; ​ 一个表只有一个primary key索引，如果没有primary key，有多个unique索引时，则MySQL将删除掉第一个unique索引。 ��unique索引时，则MySQL将删除掉第一个unique索引。","categories":[],"tags":[]},{"title":"视图","slug":"TreasureBox/数据库/mysql/7.视图","date":"2022-05-19T01:14:40.414Z","updated":"2023-04-28T09:25:47.202Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/7.shi-tu/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/7.shi-tu/","excerpt":"","text":"视图 概念： 视图是一张虚拟的表，不占用物理内存。 视图不存放数据，数据只存在基表中，但是他们发生变化都会互相影响。 视图会给我们带来更多方便。 优点 简单、方便，可以在查看数据的时候变得更清楚。 安全性：保护数据库中的重要数据，不让他展现在页面中 逻辑数据独立性：不占用物理空间，当去修改原表结构时，不会对视图造成影响（指添加字段）。 缺点 性能差：查询效率偏低，每次查询时都要转换 修改限制：对于复杂视图来说（多表查询）修改是非常麻烦的。 视图的使用 创建视图：create view 视图名 as select 语句; 查询视图： ​ show create view 视图名; 查看某个表有多少视图： ​ show table status where comment=”view”; 删除视图： ​ drop view 视图名; 在视图中对数据的增、删、改、查与在原表中都一样 查询视图的内容： ​ select * from 视图;lect * from 视图;","categories":[],"tags":[]},{"title":"pymysql的使用","slug":"TreasureBox/数据库/mysql/8.pymysql的使用","date":"2022-05-19T01:14:40.414Z","updated":"2023-04-28T09:25:47.204Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/8.pymysql-de-shi-yong/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/8.pymysql-de-shi-yong/","excerpt":"","text":"PyMySQL pymysql简介 PyMySQL：是一个使python连接到MySQL的库，是一个纯python的库。 环境要求： python2.7 python version&gt;=3.4 安装PyMYSQL pip install PyMySQL 导包 import pymysql 连接数据库 参数：host,user,password,database,port, cursorclass=pymysql.cursor.DictCursor不加该参数时表现形式为元组。 加参数时输出为字典格式。 1db = pymysql.connect(host=\"10.10.101.243\",user=\"root\",password=\"root\",database=\"test\",port=3306) 创建游标对象 游标：游标是处理数据的一种方法，为了查看或者处理结果集中的数据，在结果集中一次一行或者多行前进或向后浏览数据的能力。可以把游标当作一个指针，它可以指定结果中的任何位置，然后允许用户对指定位置的数据进行处理通俗来说，操作数据和获取数据库结果都要通过游标来操作。 1cursor = db.cursor() 定义sql语句 1sql = \"SELECT database()\" 执行sql语句，获取返回值 1cursor.execute(sql) 123456#获取返回值 fetchone() 获取一条数据print(cursor.fetchone())#获取返回值 fetchall() 获取所有数据print(cursor.fetchall())#获取返回值 fetchmany() 获取2条数据print(cursor.fetchmany(2)) 关闭数据库连接 12cursor.close()db.close() 封装MySql类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import pymysqlimport tracebackclass MySql(): def __init__(self, host, user, password, database): self.host = host self.user = user self.password = password self.database = database self.cursorclass = pymysql.cursors.DictCursor # self.port=3306 self.connect() def connect(self): self.db = pymysql.connect( self.host, self.user, self.password, self.database, cursorclass=self.cursorclass) self.cursor = self.db.cursor() def create(self, sql): self.db_edit(sql) def drop(self, sql): self.db_edit(sql) def db_edit(self,sql): try: self.cursor.execute(sql) except BaseException: raise traceback.format_stack() def get_one(self, sql): res = None try: self.cursor.execute(sql) res = self.cursor.fetchone() except BaseException as e: print(\"get_one\", e) return res def get_all(self, sql): res = () try: self.cursor.execute(sql) res = self.cursor.fetchall() except BaseException as e: print(\"get_all:\", e) return res def insert(self, sql): return self.__edit(sql) def update(self, sql): return self.__edit(sql) def delete(self, sql): return self.__edit(sql) def __edit(self, sql): count = 0 try: count = self.cursor.execute(sql) self.db.commit() except BaseException: print('事务提交失败。') self.db.rollback() return count def __del__(self): self.cursor.close() self.db.close() def del(self): self.cursor.close() self.db.close() ```","categories":[],"tags":[]},{"title":"orm操作数据库","slug":"TreasureBox/数据库/mysql/9.orm操作数据库","date":"2022-05-19T01:14:40.414Z","updated":"2023-04-28T09:25:47.202Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/9.orm-cao-zuo-shu-ju-ku/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/9.orm-cao-zuo-shu-ju-ku/","excerpt":"","text":"ORM操作数据库 orm介绍 对象关系映射 全称：Object Relational Mapping，对象关系映射 将python中的类映射为数据库中的表，一个类就是一张表，类的属性映射为表中的字段将python代码翻译为对应的数据库sql语句。 优点 1、降低耦合 2、开发人员只需要关注业务逻辑，降低开发人员的工作强度 缺点 1、降低查询效率。 2、受orm方法的限制，复杂查询不容易编写。 安装 python中的ORM,即sqlalchemy，仿照的是Django框架的ORM。flask中有ORM的插件即：flask-sqlalchemy 安装：在命令行执行：pip install sqlalchemy 使用 1、导包 2、创建连接 3、声明一个基类 4、创建类-数据模型 5、操作 orm操作数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import sqlalchemy#1、导包from sqlalchemy.ext.declarative import declarative_base#类似pymysql中的游标from sqlalchemy.orm import sessionmaker#2、创建连接#数据库类型+数据库的操作包://用户名:密码@IP地址/数据库#有mysqlclient包时，mysql+pymysql可改为mysqldb = sqlalchemy.create_engine(\"mysql://root:root@localhost/sqlorm\")#3、创建基类base = declarative_base(db)#4、创建表--数据类型class User(base): #表名 __tablename__=\"user\" #字段 id = sqlalchemy.Column(sqlalchemy.Integer,primary_key=True) name = sqlalchemy.Column(sqlalchemy.String(32)) age = sqlalchemy.Column(sqlalchemy.Integer)class UserInfo(base): __tablename__=\"userinfo\" id = sqlalchemy.Column(sqlalchemy.Integer,primary_key=True) phone = sqlalchemy.Column(sqlalchemy.String(20)) user = sqlalchemy.Column(sqlalchemy.Integer,sqlalchemy.ForeignKey(\"user.id\"),)if __name__==\"__main__\": #执行数据库迁移（创建表） base.metadata.create_all(db) #绑定一个session实例 s=sessionmaker(bind=db) #创建一个会话对象，类似于游标 session=s() #数据库操作 #添加 #1.1 单条插入 # user = User(name=\"hello\",age=16) # session.add(user) # session.commit() #1.2、多条插入 # session.add_all([ # User(name=\"world\",age=20), # User(name=\"python\",age=28), # User(name=\"PHP\",age=34) # ]) # session.commit() #2、查询 #2.1、查询所有的数据，返回一个存放对象的列表 # res = session.query(User).all() # for x in res: # print(x.name,x.age) #2.2、通过主键值查询一条数据，返回一个对象 # res = session.query(User).get(2) # print(res.name,res.age) #条件查询，返回的 是一个存放对象的列表 # res = session.query(User).filter_by(name=\"python\").all() # for x in res: # print(x.name,x.age) #3、修改 res = session.query(User).get(1) res.name='hh' session.commit() #4、删除 res =session.query(User).get(1) session.delete(res) session.commit()# pymysql与orm的对比#pymysql—sql—&gt;mysql#python—python—&gt;ORM—sql—&gt;mysql 与orm的对比#pymysql—sql—&gt;mysql #python—python—&gt;ORM—sql—&gt;mysql","categories":[],"tags":[]},{"title":"主从复制","slug":"TreasureBox/数据库/mysql/mysql高阶应用/1.主从复制","date":"2022-05-19T01:14:40.414Z","updated":"2023-04-28T09:25:47.205Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/mysql-gao-jie-ying-yong/1.zhu-cong-fu-zhi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/mysql-gao-jie-ying-yong/1.zhu-cong-fu-zhi/","excerpt":"","text":"MySQL主从复制最常见的集群方案： Replication：速度快，弱一致性，低价值，日志，新闻，帖子 PXC：速度慢，强一致性，高价值，订单，账户，财务。 一、MySQL Replication 主从复制（也称AB复制）允许将来自一个MySQL数据库服务器（主服务器）的数据复制到一个或多个MySQL数据库服务器（从服务器）。 复制是异步的，从站不需要永久连接以接收来自主站的更新。 根据配置，可以复制数据库中所有的数据库，所选数据库甚至是选定的表。 MySQL中赋值的优点包括： 横向扩展解决方案，再多个从站之间分配负载以提高性能。在此环境中，所有写入和更新都必须在主服务器上进行。但是，读取可以在一个或多个从设备上进行。该模型可以提高写入性能（因为主设备专用于更新），同时显著提高了越来越多的从设备的读取速度。 数据安全性，因为数据被复制到从站，并且从站可以暂停复制过程，所以可以在从站上运行备份服务而不会破坏相应的主数据。 分析，可以在主服务器上创建实时数据，而信息分析可以在从服务器上进行，而不会影响主服务器的性能。 远程数据分发，可以使用复制为远程站点创建数据的本地副本，而无需永久访问主服务器。 Replication的原理： 主服务器上面的任何修改都会通过自己的I/O thread(I/O线程)保存在二进制日志Binary log里面 从服务器上面也启动 一个I/O thread，通过配置好的用户名和密码，连接到主服务器上边请求读取二进制日志，然后把读取到的二进制日志写到本地的一个Realy log（中继日志）里面。 从服务器上面同时开启一个SQL thread定时检查Realy log（这个文件也是二进制的），如果发现有更新立即把更新的内容在本机数据库上执行一遍。 每个从服务器都会收到主服务器二进制日志的全部内容的副本。 从服务器设备负责决定应该执行二进制日志中的哪些语句。 除非另行制定，否则主从二进制日志中的所有时间都在从站上执行。 如果需要，您将从服务器配置为仅处理一些特定数据库或表的事件。 注意：无法将主服务器裴志伟仅记录特定时间。 每个从站（从服务器）都会记录二进制日志坐标： 文件名 文件中它已经从主站读取和处理的位置。 由于每个从服务器都分别记录了自己当前处理二进制日志中的位置，因此可以断开服务器的连接，重新连接然后恢复继续处理。 一主多从如果一主多从的话，这时主库既要负责写又要负责为几个从库提供二进制日志。此时可以稍作调整，将二进制日志只给一从，这一从再开启二进制日志并将自己的二进制日志再发给其他从。或者干脆这个从不记录只负责将二进制日志转发给其他从，这样架构起来性能要好很多，而且数据之间的延时也会好一点。工作原理如下： 关于二进制文件mysqld将数字扩展名附加到二进制日志基本名称以生成人禁止日志文件名。每次服务器创建新日志文件时，该数字都会增加，从而创建一系列有序的文件。每次启动或刷新日志时，服务器都会在系列中创建一个新文件。服务器还会在当前日志大小达到max_binlog_size参数设置的的大小后自动创建新的二进制日志文件。二进制日志文件可能会比max_binlog_size使用大型事务时更大，因为事务是以一个部分写入文件，而不是在文件之间分割。 为了跟踪已使用的二进制日志文件，mysqld还创建了一个二进制日志索引文件，其中包含所有使用的二进制日志文件的名称。 默认情况下，它具有与二进制日志文件相同的基本名称，并带有扩展名”.index“。在mysqld运行时，不要手动编辑此文件。 术语二进制日志文件通常表示包含数据库事件的单个编号文件。 术语二进制日志表示含编号的二进制日志文件集加上索引文件。 SUPER权限的用户可以试用SET sql_log_bin=0语句禁用其当前环境下自己的语句的二进制日志记录。 配置Replication配置步骤： 在主服务器上，必须启用二进制日志记录并配置唯一的服务器ID。需要重启服务器。 编辑主服务器上的配置文件my.cnf，添加如下内容： [mysqld] log-bin=/var/log/mysql/mysql-bin server-id=1 创建日志目录并赋予权限： shell&gt; mkdir /var/log/mysql shell&gt; chown mysql.mysql /var/log/mysql 重启服务 shell&gt; systemctl restart mysqld 注意： 如果省略server-id（或将其显式设置为默认值0），则主服务器拒绝来自从服务器的任何连接。 为了在使用带有事务的InnoDB进行赋值设置时尽可能提高持久性和一致性。 可以在master my.cnf文件中使用以下配置项： innodb_flush_log_at_trx_commit = 1 sync_binlog = 1 确保在主服务器上skip_networking选项处于OFF关闭状态，这是默认值。如果是启用的，则从站无法与主站通信，并且复制失败。 1234567mysql&gt; show variables like '%skip_networking%';+-----------------+-------+| Variable_name | Value |+-----------------+-------+| skip_networking | OFF |+-----------------+-------+1 row in set (0.00 sec) 应该创建一个专门用于复制数据的用户 每个从服务器需要使用MySQL主服务器上的用户名和密码连接到主站。 例如：计划使用用户rep1�务器上的用户名和密码连接到主站。 例如：计划使用用户rep1","categories":[],"tags":[]},{"title":"数据库基本操作","slug":"TreasureBox/数据库/mysql/1.数据库基本操作","date":"2022-05-19T01:14:40.413Z","updated":"2023-04-28T09:25:47.198Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/1.shu-ju-ku-ji-ben-cao-zuo/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/1.shu-ju-ku-ji-ben-cao-zuo/","excerpt":"","text":"数据库基本语句一、基本命令 启动服务 说明：以管理员身份运行cmd 格式：net start 服务名称 示例：net start mysql 停止服务 说明：以管理员身份运行cmd 格式：net stop 服务名称 示例：net stop mysql 连接数据 格式：mysql -hlocalhost -u用户名 -p -P3306 示例：mysql -u root -p 输入密码 退出登录（断开连接） 格式：quit 或 exit; 查看版本 示例：select version(); 显示当前时间（连接后可以执行） 示例：select now(); 远程连接 格式：mysql -h ip地址 -u 用户名 -p -P3306 输入密码 常见的字段约束 123456Unsigned 无符号 一般给数值型的字段添加，如果添加代表当前字段只能存正数Int(5) 5代表显示的宽度 如果是有符号默认是11 如果是无符号默认10Not null 不能为空 默认字段可以为空 如果添加了 那么此字段不能为空Default 默认值Primary key 主键约束(主键索引) 不能为空 且唯一 用于表示数据的唯一标识Unique 唯一约束(唯一索引) 可以为空 不能重复 具有唯一性Auto_increment 自动递增 一般配合主键去使用 常见的字段类型 整数类型 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 byte (-128，127) (0，255) 小整数值 SMALLINT 2 bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期和时间类型 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串类型 字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 二、库操作（数据库操作必须以英文分号（；）结束） 查看有哪些数据库：show databases; 创建数据库：create database 库名; 进入数据库：use 库名; 查看当前使用的数据库：select database() 删除数据库：drop database 库名; 三、表操作 查看库中所有的表：show tables； 创建表： 格式：create table 表名（字段及类型）; 注意：表名如果是关键字如show需要加反引号`` 删除表：drop table 表名; 查看表结构：desc 表名; 查看建表语句：show create table 表名; 重命名表名： 1、rename table 表名1 to 表名2; 2、alter table 表名1 rename as 表名2; 修改表 alter table 表名 add、drop、change、modify 字段名 类型; 添加字段：alter table users add gender int after name; ​ (可以使用after，不能使用before，first代表插入在第一个) 添加外键：alter table users add foreign key(c_id) references class(id); 删除字段：alter table user drop gender; 修改字段名称：alter table user change gender sex char(1); 修改字段类型：alter table user modify sex int(1); 修改表的编码格式 alter table students CHARSET=GBK; 修改自增值 修改自增值为20 alter table students AUTO_INCREMENT=20; 四、数据操作 增： a、全列插入：insert into 表名 values(); b、缺省插入：insert into 表名(字段1,字段2) values (值1，值2); c、同时插入多条数据：insert into 表名 values(……),(……),(……); d、将一张表查询结果插入另一张表，此时不需要加values： insert into shop(name,address) select name,address from sqlorm.shops; 删： a、删除某条数据 delete from 表名 where 条件;(不写条件时会删掉所有数据，条件一般用主键) 改 a、修改数据 update 表名 set name=’zhangsan’ where id =1; UPDATE 表名 SET text=REPLACE(text, ‘oldvalue’, ‘newValue’); 查 a、查询表中全部数据： select * from 表名 ​ d =1; UPDATE 表名 SET text=REPLACE(text, 'oldvalue', 'newValue'); 查 a、查询表中全部数据： select * from 表名 ​","categories":[],"tags":[]},{"title":"配置文件说明","slug":"TreasureBox/数据库/mysql/11.配置文件说明","date":"2022-05-19T01:14:40.413Z","updated":"2023-04-28T09:25:47.203Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/11.pei-zhi-wen-jian-shuo-ming/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/11.pei-zhi-wen-jian-shuo-ming/","excerpt":"","text":"mysql配置文件说明ubuntu中配置文件默认路径：/etc/mysql/my.cnf 可以通过配置文件对mysql进行一些基础配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103[client]port = 3306socket = /tmp/mysql.sock12[mysqld]#Mysql服务的唯一编号 每个mysql服务Id需唯一server-id = 1#服务端口号 默认3306port = 3306#mysql安装根目录basedir = /usr/local/mysql#mysql数据文件所在位置datadir = /usr/local/mysql/data#临时目录tmpdir = /tmp#设置socke文件所在目录socket = /tmp/mysql.sock#主要用于MyISAM存储引擎,如果多台服务器连接一个数据库则建议注释下面内容skip-external-locking#只能用IP地址检查客户端的登录，不用主机名skip_name_resolve = 1#事务隔离级别，默认为可重复读，mysql默认可重复读级别（此级别下可能参数很多间隙锁，影响性能）transaction_isolation = READ-COMMITTED#数据库默认字符集,主流字符集支持一些特殊表情符号（特殊表情符占用4个字节）character-set-server = utf8mb4#数据库字符集对应一些排序等规则，注意要和character-set-server对应collation-server = utf8mb4_general_ci#设置client连接mysql时的字符集,防止乱码init_connect='SET NAMES utf8mb4'#是否对sql语句大小写敏感，1表示不敏感lower_case_table_names = 1#最大连接数max_connections = 400#最大错误连接数max_connect_errors = 1000#TIMESTAMP如果没有显示声明NOT NULL，允许NULL值explicit_defaults_for_timestamp = true#SQL数据包发送的大小，如果有BLOB对象建议修改成1Gmax_allowed_packet = 128M#MySQL连接闲置超过一定时间后(单位：秒)将会被强行关闭#MySQL默认的wait_timeout 值为8个小时, interactive_timeout参数需要同时配置才能生效interactive_timeout = 1800wait_timeout = 1800#内部内存临时表的最大值 ，设置成128M。#比如大数据量的group by ,order by时可能用到临时表，#超过了这个值将写入磁盘，系统IO压力增大tmp_table_size = 134217728max_heap_table_size = 134217728#禁用mysql的缓存查询结果集功能#后期根据业务情况测试决定是否开启#大部分情况下关闭下面两项query_cache_size = 0query_cache_type = 0#数据库错误日志文件log_error = error.log#慢查询sql日志设置slow_query_log = 1slow_query_log_file = slow.log#检查未使用到索引的sqllog_queries_not_using_indexes = 1#针对log_queries_not_using_indexes开启后，记录慢sql的频次、每分钟记录的条数log_throttle_queries_not_using_indexes = 5#作为从库时生效,从库复制中如何有慢sql也将被记录log_slow_slave_statements = 1#慢查询执行的秒数，必须达到此值可被记录long_query_time = 8#检索的行数必须达到此值才可被记为慢查询min_examined_row_limit = 100#mysql binlog日志文件保存的过期时间，过期后自动删除expire_logs_days = 5```�保存的过期时间，过期后自动删除expire_logs_days = 5","categories":[],"tags":[]},{"title":"查询","slug":"TreasureBox/数据库/mysql/2.查询","date":"2022-05-19T01:14:40.413Z","updated":"2023-04-28T09:25:47.203Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/2.cha-xun/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/2.cha-xun/","excerpt":"","text":"数据库查询 基本语法 格式：select * from 表名; 说明：select 后跟要查询的内容(字段名)，*代表查询全部，from代表数据来源于哪张表 示例：select name,id from student; 消除重复行 在select跟字段之间使用distinct可以消除重复的行。 示例：select distinct name from student; 条件查询 a、语法：select * from 表名 where 条件; b、比较运算符：+，-，*，、，=，！=，&lt;,&gt;,% ​ 示例：select * from 表名 where id&lt;18； c、逻辑运算符 ​ and 并且 select * from student where id&gt;7 and gender=0; ​ or 或者 select * from student where id&gt;7 or gender=0; ​ 说明：只要满足任意条件都会匹配出来 ​ not 不是 select * from student where id&gt;7 not gender; d、模糊查询 ​ 示例：select * from student where name llike ‘%a%’;(只要包含a就会匹配出来) ​ 说明：%代表包括空白在内的任意字符，_代表一个字符 e、范围查询 ​ in 在 select * from student where id in (1,3,4); ​ not in 不在 select * from student where id not in (1,3,4); ​ between and select * from student where id between 6 and 8; f、空判断 ​ insert into student(name,age) values(‘小明’,70); ​ 说明：null 与’’不同 ​ select * from student where address is null;(或者is not) g、优先级 ​ 小括号,not 比较运算符，逻辑运算符 ​ and 比 or 优先级高，如果同时出现并希望先选or，需要结合()使用 聚合查询 a、count(*) 表示计算总行数，括号中可以写**和字段 b、max(字段) 表示求此列的最大值 c、min(字段) 表示求此列的最小值 d、sum(字段) 表示求此列的和 e、avg(字段) 表示求此列的和 select max(age) from student where gender=’0’; 分组查询 按照字段分组，表示此字段相同的数据会被放到一个集合中。 分组后，只能查询相同的数据列，对于有差异的数据列无法显示在结果集中，可以对分组数据进行统计，做聚合运算。 语法：select 列1,列2,聚合…… from 表 group by 列1,列2,…… 示例：查询男女生总数 select gender,count(*) from student group by gender; 分组后的数据筛选： select 列1,列2,聚合…… from 表 group by having 列1，列2，……,聚合…… having 条件 示例：select gender,count(*) from student group by gender having gender=0; where和having的区别： where是对from后面指定的表进行筛选，属于对原始表的筛选 having是对group by的结果进行筛选 示例：select id,name from teachers where name in (select name from teachers group by names having count(name)&gt;1); 排序 语法：select * from 表名 order by 列1 asc| desc,列2 asc|desc; 说明：将数据按照列1进行排序，如果某些列1的值相同，那么按照列2排序 ​ 默认按照升序排列，asc降序，desc降序 分页 语法：select * from 表名 limit x,y; 说明：从第x+1行开始，查询y行内容 lect * from 表名 limit x,y; 说明：从第x+1行开始，查询y行内容","categories":[],"tags":[]},{"title":"关联查询","slug":"TreasureBox/数据库/mysql/3.关联查询","date":"2022-05-19T01:14:40.413Z","updated":"2023-04-28T09:25:47.199Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/3.guan-lian-cha-xun/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/3.guan-lian-cha-xun/","excerpt":"","text":"关联查询一、外键：外键主要用来描述表和表的一对多关系 全称：外键约束，添加完外键会给字段默认添加普通索引 作用：保证数据的完整性和准确性。 逻辑外键：逻辑上存在的关系，并没有真实的关系，在插入和删除数据时没有影响。 物理外键：在建表时设置约束关系，在插入和删除数据时会相互影响。 二、建表语句： create table class(id int auto_increment primary key,name varchar(22) not null default ‘’,stuNum int not null); create table students(id int auto_increment primary key,name varchar(22) not null default ‘’,gender bit default 1,pid int not null,foreign key(pid) references class(id)); 示例：select students.name,class.name,class.id from class inner join students on class.id=student.pid; 分类： 1、表A inner join 表B：内连接 交集查询​ 表A与表B匹配的行会出现在结果集中 ​ select * from 表1 inner join 表2 on 表1.外键字段=表2. 主键字段; 2、表A left join 表B，左连接​ 表A与表B匹配的行会出现在结果集中，外加表A独有的数据，未对应的数据使用null填充 3、表A right join 表B：​ 表A与表B匹配的行会出现在结果集中，外加表B独有的数据，未对应的数据使用null填充 填充","categories":[],"tags":[]},{"title":"数据库备份","slug":"TreasureBox/数据库/mysql/4.数据库备份","date":"2022-05-19T01:14:40.413Z","updated":"2023-04-28T09:25:47.204Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/4.shu-ju-ku-bei-fen/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/4.shu-ju-ku-bei-fen/","excerpt":"","text":"数据库备份 1、先退出mysql环境 数据的导出：​ 备份表：默认导出在当前路径 ​ 注意：使用mysql可以导表，但是导库时必须使用mysqldump ​ 示例：mysqldump -uroot -proot test major&gt;./Desktop/major.sql ​ 备份库： ​ 格式：mysqldump -uroot -p 库名&gt;路径/name.sql ​ 示例：mysqldump -uroot -p 库名&gt;备份文件名.sql 数据的导入：​ mysql -uroot -p 库名 &lt; 备份文件地址.sql","categories":[],"tags":[]},{"title":"权限管理","slug":"TreasureBox/数据库/mysql/5.权限管理","date":"2022-05-19T01:14:40.413Z","updated":"2023-04-28T09:25:47.198Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/5.quan-xian-guan-li/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/5.quan-xian-guan-li/","excerpt":"","text":"权限管理用户：使用者 权限：用户的操作范围 组：权限集合 一个组里面有查询权限、删除权限等 1、修改密码​ 首先进入数据库：use mysql; ​ 修改密码： 1mysql&gt; update user set authentication_string=password('root') where host='localhost' and user='root'; ​ 忘记密码时，在配置文件中加：skip-grant-tables，即可跳过密码验证，登陆之后修改密码重启mysql服务。 ​ 修改完密码之后退出数据库环境，然后重启数据库服务即可更新密码。在5.n数据库版本的密码加密函数为password。8.0版本数据库加密方式有所改变。 2、创建用户​ 格式：create user ‘用户名‘@’来源地’ identified by ‘密码’; 1、创建只有本地能登录的用户​ create user ‘zhangsan‘@’localhost’ identified by ‘123456’; 2、创建只能指定ip登录的用户​ create user ‘lisi‘@’10.10.11.12’ identified by ‘123456’; 3、给用户授权允许远程连接格式：grant 权限 on 库名.表名 to 用户名@’地址’; 权限分类： select,insert,update,delete,create 示例：给wangwu用户添加查询权限 1grant select on test.major to wangwu@'localhost'; 创建不限ip访问的xiaoliu用户，添加所有权限 1create user 'xiaoliu'@'%' identified by '123456' grant all on *.* to xiaoliu@'%'; 4、删除用户​ drop user “用户名”@”来源地”; er “用户名”@”来源地”;","categories":[],"tags":[]},{"title":"NoSQL和关系型数据库","slug":"TreasureBox/数据库/NoSQL和关系型数据库","date":"2022-05-19T01:14:40.412Z","updated":"2023-04-28T09:25:47.186Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/nosql-he-guan-xi-xing-shu-ju-ku/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/nosql-he-guan-xi-xing-shu-ju-ku/","excerpt":"","text":"NoSQL和关系型数据区别[TOC] NoSQL(NoSQL=Not Only SQL)，意为不仅仅是SQL。 在现在计算机系统上每天都会产生庞大数据量，这些数据很大一部分是由关系型数据库管理系统(RDMBSs)来处理。1970年E.F.Codd’s提出关系模型论文，通过应用实践证明，关系型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。 NoSQL是一项全新的数据库革命性运动早期就有人提出，发展至 2009年趋势越发高涨。NoSQL维护者们提倡运用芬关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念是一种全新的思维注入。 一、关系型数据库遵循ACID规则事务在英文中是transaction，和现实世界中的交易类似，具有如下四个特性： 1、A(Atomicty)原子性原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。 2、C (Consistency) 一致性一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。 例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。 3、I (Isolation) 独立性所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。 4、D (Durability) 持久性持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。 二、分布式系统分布式系统(distributed system)由多台计算机和通信的软件组件通过计算机网络连接(本地网络或广域网)组成。 分布式系统是建立在网络智商的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。 因此，网络和分布式系统之间的区别更多在于高层软件（特别是操作系统），而不是硬件。 分布式系统可以应用在不同的平台上如：PC、工作站，局域网和广域网等。 三、分布式计算的优点1、可靠性（容错）：分布式计算系统中的一个重要的优点是可靠性，一台服务器的系统崩溃并不影响到其余服务器。 2、可扩展性：在分布式计算系统可以根据需要增加更多的机器。 3、资源共享：共享数据是必不可少的应用，如银行，预订系统等。 4、灵活性：由于系统是非常灵活的，很容易安装、实施和调试新的服务。 5、更快的速度：分布式计算系统可以有多个计算机的计算能力，使得它比其他系统有更快的处理速度。 6、开放系统：由于它是开放的系统，本地或者远程都可以访问到该服务。 7、更高的性能：相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。 四、分布式计算的缺点1、故障排除故障排除和诊断比较困难 2、软件更少的软件支持是分布式计算系统的主要缺点 3、网络网路基础设施的问题，包括：传输问题，高负载，信息丢失等。 4、安全性开发系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题 五、什么是NoSQL？NoSQL值得是非关系型数据库。NoSQL有时也被称作Not Only SQL的缩写，是对不同于传统的关系数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如谷歌或者Facebook每天为他们的用户手机万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 六、为什么使用NoSQL？当今我们可以通过第三方平台（如google，facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，NOSQL数据库的发展也能很好的处理这些大的数据。 七、RDBMS vs NoSQLRDBMS（Relational Database Management System）指关系型数据库管理系统。 高度组织化结构化数据 结构化查询语言（SQL）（SQL） 数据和关系都存储在单独的表中 数据操纵语言，数据定义语言 严格的一致性 基础事务 NoSQL 代表着不仅仅是SQL 没有声明性查询语言 没有预定义的模式 键—值对存储，列存储，文档存储，图形数据库 最终一致性，而非ACID属性 非结构化和不可预知的数据 CAP定理 高性能，高可用性和可伸缩性 八、NoSQL简史NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。 2009年，Last.fm的Johan Oskarsson发起了一次关于分布式开源数据库的讨论[2]，来自Rackspace的Eric Evans再次提出了NoSQL的概念，这时的NoSQL主要指非关系型、分布式、不提供ACID的数据库设计模式。 2009年在亚特兰大举行的”no:sql(east)”讨论会是一个里程碑，其口号是”select fun, profit from real_world where relational=false”。因此，对NoSQL最普遍的解释是“非关联型的”，强调Key-Value Stores和文档数据库的优点，而不是单纯的反对RDBMS。 九、CAP定理(CAP theorem)在计算机科学中，CAP定理（CAP theorem），又被称为布鲁尔定理（Brewer’stheorem），它支出对于一个分布式计算机系统来说，不可能同时满足以下三点： **一致性(Consistency)**：所有节点在相同时间具有相同的数据。 **可用性(Availability)**：保证每个轻取不管成功或者失败都有响应。 **分隔容忍(Partition tolerance)**：系统中任意信息的丢失或失败不会影响系统的继续运作。 十、NoSQL的优点/缺点优点： 高可扩展性 分布式计算 低成本 架构的灵活性，半结构化数据 没有复杂的关系 缺点： 没有标准化 有限的查询功能(到目前为止) 最终一致是不直观的程序 十一、BASEBASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 BASE是NoSQL数据库通常对可用性及一致性的弱要求原则： Basically Avaible——基本可用 Soft-state——软状态/柔性事务。”Soft state”可以理解为无连接的。而”Hard state”是面向连接的 Eventual Consistency——最终一致性，也是ACID的最终目的。 十二、ACID vs BASE ACID BASE 原子性(Atomicity) 基本可用(Basically Available) 一致性(Consistency) 软状态/柔性事务(Soft state) 隔离性(Isolation) 最终一致性(Eventual consistency) 持久性(Durable) 十三、NoSQL数据库分类 类型 部分代表 特点 列存储 HbaseCassandraHypertable 按列存储数据。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。 文档存储 MongoDBCouchDB 文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有机会 key-value存储 Tokyo Cabinet/TyrantBerkeley DBMemcacheDBRedis 可以通过key快速查询到其value。一般来说，存储不管value格式，照单全收。（Redis包含了其他功能） 图存储 Neo4JFlockDB 图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。 对象存储 db4oVersant 通过类似面向对象的语言的语法操作数据库，通过对象的方式存取数据。 xml数据库 Berkeley DB XMLBaseX 高效的存储XML数据，并支持XML的内部查询语法，比如XQuery，Xpath。 | 高效的存储XML数据，并支持XML的内部查询语法，比如XQuery，Xpath。 |","categories":[],"tags":[]},{"title":"MySQL高阶","slug":"TreasureBox/数据库/mysql/10.MySQL高阶","date":"2022-05-19T01:14:40.412Z","updated":"2023-04-28T09:25:47.198Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mysql/10.mysql-gao-jie/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mysql/10.mysql-gao-jie/","excerpt":"","text":"MySQL高阶—事务、触发器、存储过程一、数据库事务（1）数据库中的事务有四大特性：ACID 原子性：每个事务都是不可分割的执行，要么全部成功，要么全部失败。 一致性：事务执行之前和执行之后的状态保持一致。比如A有1000元，B有1000元，A给B转账500元之后，A与B的钱数之和应该还是2000元。 隔离性：多个事务同时操作，每个事务之间相互独立，互不影响。 持久性：事务提交成功后对数据库的改变是永久的。 （2）数据库三范式​ 数据库的范式(规范的数据表示公式)：按照什么方式在数据库中表示（存储）是完全合理是做不到的，只能在数据库设计过程中尽量靠近三范式约束。 1NF：字段不可分割 数据库中的每一列数据，是不能再拆分的。 2NF：有主键，非主键字段依赖主键。 数据库中的每一条数据都是唯一的，主键作为数据唯一的描述符。 3NF：非关键字的任何字段属性，不能产生相互的依赖条件 不是主键的任何其他字段，不能产生相互的依赖关系。 （3）事务的隔离级别​ 事务的隔离级别，指多个事务同时操作数据库时，不同事务之间应该怎么定义他们的操作。 读未提交：read uncommitted 一个事务中，读取了另一个事务中没有提交的数据，两个事务之间造成了影响。 读已提交：read committed 一个事务中，读取了另一个事务中提交的数据。 可重复读：repeat read 在一次完整的事务中，每次读取的数据都是一致的，不会发生变化，所有提交的更新的数据都会在下一个事务中读取到。数据库默认的隔离级别 串行化/序列化：serializerable 所有的事务操作全部排队，依次执行 二、触发器数据库中提供了特殊的处理方法：自动化操作，本质上是当数据库中发生了一些行为之后，导致一些其他的行为自动触发，类似python开发中的事件驱动开发。 数据库中提供了一种数据库高级对象：触发器；描述的是数据表上一个条件被触发执行的后续行为操作。 ① 触发器语法：create trigger trigger_name trigger_time trigger_event on table_name for each row trigger_stmt end; 描述：在某张表上，发生了一个触发事件，在触发事件发生之前|之后(触发时机)，执行触发器中定义的要执行的程序。 trigger_time：触发时机，before|after trigger_event：触发事件,insert|update|delete ②触发器案例：自动下单功能 创建测试数据表 12345678910111213141516create table goods( gid int auto_increment primary key comment '商品主键', gname varchar(20) not null comment '商品名称', gprice double not null comment '商品单价', gstock int not null comment '商品库存',);create table goods_order( goid int auto_increment primary key comment '订单编号', goname varchar(20) comment '购买商品名称', goprice double comment '成交单价', gocount int comment '购买数量', subtotal double comment '小计金额'); 创建触发器 12345678910111213141516171819202122delimiter $$-- 创建一个触发器create trigger goods_sale_auto -- 在goods表格修改之后执行触发器 after update on goods for each row -- 要执行的程序开始操作 begin -- 声明两个变量 declare buycount int; declare subtotal double; -- 判断库存是否更新：更新前old，更新后new if new.gstock&lt;old.gstock then --获取购买的数量 set buycount = old.gstock - new.gstock; set subtotal = buycount * old,gprice; insert into goods_order(gname,goprice,gcount,subtotal) values(old.gname,old,gprice,buycount,subtotal); end if; -- 要执行的程序完结操作 end; $$ delimiter; --触发器创建完成后，修改结束符为默认的分号 三、存储过程​ 触发器是数据库中根据发生的条件(某张表上发生了INSERT/UPDATE/DELETE操作)自动执行的数据库程序，当我们需要自定义程序，并且手工调用时要怎么去做？ ​ 数据库提供了另外一种高级对象：存储程序，一般称为存储过程，就是一个用户按照规范语法编写的程序代码，可以将项目中的业务逻辑封装在程序中，通过固定的语法方式直接调用执行，类似python中的函数。 （1）基本语法结构​ 创建存储过程 1CREATE PROCEDURE proc_name ([proc_parameters]) routing_body create procedure 固定语法：创建存储过程 proc_name：自定义存储过程名称 proc_parameters：存储过程执行需要的参数 routing_body：存储程序要执行的程序代码 （2）案例123456789delimiter $$create procedure employee_avg()begin -- 模拟一行或多行代码 select AVG(salary) from ex01.employeeend;$$-- 调用存储过程call employee_avg(); （3）带有返回值的存储过程1234567891011delimiter $$create procedure my_employee2(out res double)begin -- 查询数据，并将数据保存到变量中 select AVG(salary) into res from ex01.employeeend;$$-- 调用存储过程call my_employee2(@res);--查看返回值的数据select @res; 返回值声明在存储过程名称后面的括号： out：返回数据 in：输入数据 input：既是输入数据，同时也能返回数据 调用时，需要使用变量接受数据，为了跟其他变量区分，添加@符号：call mey_employee(@res);�，同时也能返回数据 调用时，需要使用变量接受数据，为了跟其他变量区分，添加@符号：call mey_employee(@res);","categories":[],"tags":[]},{"title":"查询操作符","slug":"TreasureBox/数据库/MongoDB/4.查询操作符","date":"2022-05-19T01:14:40.404Z","updated":"2023-04-28T09:25:47.195Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/4.cha-xun-cao-zuo-fu/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/4.cha-xun-cao-zuo-fu/","excerpt":"","text":"查询和计划操作符[TOC] 一、评价查询操作符 方法名 描述 $mod 取模计算 $regex 模糊查询，查询该字段包含某个字符串 $text 对有text索引的字段进行模糊查询 $where 使用js代码查询数据 1、使用$mod进行模运算查询c1的数据集如下： 12345&gt; db.c1.find(){ \"_id\" : ObjectId(\"5f97bb1a0436fe0f6dbb0526\"), \"age\" : 1, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb200436fe0f6dbb0527\"), \"age\" : 7, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb260436fe0f6dbb0528\"), \"age\" : 8, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb860436fe0f6dbb052a\"), \"age\" : 13, \"length\" : 30 } 取年龄模6结果为1的数据 1234&gt; db.c1.find({age:{$mod:[6,1]}}){ \"_id\" : ObjectId(\"5f97bb1a0436fe0f6dbb0526\"), \"age\" : 1, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb200436fe0f6dbb0527\"), \"age\" : 7, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb860436fe0f6dbb052a\"), \"age\" : 13, \"length\" : 30 } 2、使用$regex进行模糊查询c2的数据集如下： 12345&gt; db.c2.find() { \"_id\" : ObjectId(\"5f97bc460436fe0f6dbb052b\"), \"name\" : \"小明\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc4c0436fe0f6dbb052c\"), \"name\" : \"小刚\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc570436fe0f6dbb052d\"), \"name\" : \"小明明\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc5f0436fe0f6dbb052e\"), \"name\" : \"大明\", \"age\" : 20 } 查name中包含“明”的数据： 1234&gt; db.c2.find({name:{\"$regex\":\"明\"}})){ \"_id\" : ObjectId(\"5f97bc460436fe0f6dbb052b\"), \"name\" : \"小明\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc570436fe0f6dbb052d\"), \"name\" : \"小明明\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc5f0436fe0f6dbb052e\"), \"name\" : \"大明\", \"age\" : 20 } 3、使用$text对有text索引的字段进行模糊查询先对c4添加索引： 1&gt; db.c4.createIndex( { subject: \"text\" } ) c4的数据集如下： 123456&gt; db.c4.find( ){ \"_id\" : 1, \"subject\" : \"hello world\", \"title\" : \"hello\" }{ \"_id\" : 2, \"subject\" : \"hello python\", \"title\" : \"python\" }{ \"_id\" : 3, \"subject\" : \"hello java\", \"title\" : \"java\" }{ \"_id\" : 4, \"subject\" : \"hello mongodb\", \"title\" : \"mongodb\" }{ \"_id\" : 5, \"subject\" : \"中文\", \"title\" : \"mongodb\" } 使用”$text“进行查询 12&gt; db.c4.find({\"$text\":{\"$search\":\"world\"}}){ \"_id\" : 1, \"subject\" : \"hello world\", \"title\" : \"hello\" } 4、使用$where进行查询c5的数据集如下： 1234&gt; db.c5.find(){ \"_id\" : ObjectId(\"5f98df8e4262ff84adb202d5\"), \"a\" : { \"a\" : 1 }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98df9c4262ff84adb202d6\"), \"a\" : { \"a\" : 1, \"b\" : \"1\" }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98df9f4262ff84adb202d7\"), \"a\" : { \"a\" : 1, \"b\" : \"2\" }, \"b\" : 2, \"c\" : 3 } 查询某条内嵌文档中a的值跟b的值相等的数据： 12&gt; db.c5.find({$where:\"this.a.a==this.a.b\"}){ \"_id\" : ObjectId(\"5f98df9c4262ff84adb202d6\"), \"a\" : { \"a\" : 1, \"b\" : \"1\" }, \"b\" : 2, \"c\" : 3 } 二、逻辑查询操作符 方法 描述 $and 并且，两个条件同时成立 $nor 两个条件同时不成立 $not 不是某个值 $or 或者，两个条件只成立一个 c6的数据集如下： 1234&gt; db.c6.find(){ \"_id\" : ObjectId(\"5f98e4217c6aa7043a43d2f8\"), \"subject\" : \"hello world\", \"title\" : \"hello\" }{ \"_id\" : ObjectId(\"5f98e4297c6aa7043a43d2f9\"), \"subject\" : \"hello python\", \"title\" : \"hello\" }{ \"_id\" : ObjectId(\"5f98e42e7c6aa7043a43d2fa\"), \"subject\" : \"hello java\", \"title\" : \"hello\" } 1、使用$and进行查询查询subject为hello java,title为hello的文档 12&gt; db.c6.find({$and:[{\"subject\":\"hello java\"},{\"title\":\"hello\"}]}){ \"_id\" : ObjectId(\"5f98e42e7c6aa7043a43d2fa\"), \"subject\" : \"hello java\", \"title\" : \"hello\" } 2、使用$nor进行查询查询subject不为hello java并且title不为hel的文档 123&gt; db.c6.find({$nor:[{\"subject\":\"hello java\"},{\"title\":\"hel\"}]}){ \"_id\" : ObjectId(\"5f98e4217c6aa7043a43d2f8\"), \"subject\" : \"hello world\", \"title\" : \"hello\" }{ \"_id\" : ObjectId(\"5f98e4297c6aa7043a43d2f9\"), \"subject\" : \"hello python\", \"title\" : \"hello\" } 3、使用$not进行查询查询b不小于2的值 12345&gt; db.c5.find({b:{$not:{$lt:2}}}){ \"_id\" : ObjectId(\"5f98df8e4262ff84adb202d5\"), \"a\" : { \"a\" : 1 }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98df9c4262ff84adb202d6\"), \"a\" : { \"a\" : 1, \"b\" : \"1\" }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98df9f4262ff84adb202d7\"), \"a\" : { \"a\" : 1, \"b\" : \"2\" }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98e0674262ff84adb202d8\"), \"a\" : { \"a\" : 1, \"b\" : 1 }, \"b\" : 2, \"c\" : 3 } 4、使用$or进行查询查询b为2或者c为4的值 12345&gt; db.c5.find({$or:[{b:2},{c:4}]}){ \"_id\" : ObjectId(\"5f98df8e4262ff84adb202d5\"), \"a\" : { \"a\" : 1 }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98df9c4262ff84adb202d6\"), \"a\" : { \"a\" : 1, \"b\" : \"1\" }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98df9f4262ff84adb202d7\"), \"a\" : { \"a\" : 1, \"b\" : \"2\" }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98e0674262ff84adb202d8\"), \"a\" : { \"a\" : 1, \"b\" : 1 }, \"b\" : 2, \"c\" : 3 } 三、比较查询操作符 方法 描述 $gt 大于 $gte 大于等于 $lt 小于 $lte 小于等于 $in 在…之中 $nin 不在….之中 $ne 不等于 $eq 等于 c7的数据集如下 12345&gt; db.c7.find(){ \"_id\" : 1, \"age\" : 20, \"length\" : 17 }{ \"_id\" : 2, \"age\" : 23, \"length\" : 17 }{ \"_id\" : 3, \"age\" : 24, \"length\" : 17 }{ \"_id\" : 4, \"age\" : 19, \"length\" : 17 } 1、$gt查询年龄大于20的123&gt; db.c7.find({age:{$gt:20}}){ \"_id\" : 2, \"age\" : 23, \"length\" : 17 }{ \"_id\" : 3, \"age\" : 24, \"length\" : 17 } 2、$gte查询年龄大于等于20的1234&gt; db.c7.find({age:{$gte:20}}){ \"_id\" : 1, \"age\" : 20, \"length\" : 17 }{ \"_id\" : 2, \"age\" : 23, \"length\" : 17 }{ \"_id\" : 3, \"age\" : 24, \"length\" : 17 } 3、$lt查询年龄小于20的12&gt; db.c7.find({age:{$lt:20}}){ \"_id\" : 4, \"age\" : 19, \"length\" : 17 } 4、$lte查询年龄小于等于20的123&gt; db.c7.find({age:{$lte:20}}){ \"_id\" : 1, \"age\" : 20, \"length\" : 17 }{ \"_id\" : 4, \"age\" : 19, \"length\" : 17 } 5、$in查询年龄在20,21,22之中的12&gt; db.c7.find({age:{$in:[20,21,22]}}){ \"_id\" : 1, \"age\" : 20, \"length\" : 17 } 6、$nin查询年龄不在20,21,22之中的1234&gt; db.c7.find({age:{$nin:[20,21,22]}}){ \"_id\" : 2, \"age\" : 23, \"length\" : 17 }{ \"_id\" : 3, \"age\" : 24, \"length\" : 17 }{ \"_id\" : 4, \"age\" : 19, \"length\" : 17 } 7、$ne查询年龄不等于20的1234&gt; db.c7.find({age:{$ne:20}}){ \"_id\" : 2, \"age\" : 23, \"length\" : 17 }{ \"_id\" : 3, \"age\" : 24, \"length\" : 17 }{ \"_id\" : 4, \"age\" : 19, \"length\" : 17 } 8、$eq查询年龄等于20的12&gt; db.c7.find({age:{$eq:20}}){ \"_id\" : 1, \"age\" : 20, \"length\" : 17 } 四、数组查询操作符 方法 描述 $all 匹配数组中包含某个数组的所有数据 $size 匹配数组长度为某个数的数据 $elemMatch 查询数组中至少有一个元素满足所有指定条件的文档 $slice 对数组返回的值切片 c8的数据集如下： 123456&gt; db.c8.find(){ \"_id\" : ObjectId(\"5f992b2b7c6aa7043a43d2fb\"), \"name\" : \"zs\", \"score\" : [ 10, 80, 90 ] }{ \"_id\" : ObjectId(\"5f992b347c6aa7043a43d2fc\"), \"name\" : \"yz\", \"score\" : [ 70, 80, 90 ] }{ \"_id\" : ObjectId(\"5f992b407c6aa7043a43d2fd\"), \"name\" : \"lh\", \"score\" : [ 70, 85, 92 ] }{ \"_id\" : ObjectId(\"5f992b497c6aa7043a43d2fe\"), \"name\" : \"llx\", \"score\" : [ 79, 85, 92 ] }{ \"_id\" : ObjectId(\"5f992e637c6aa7043a43d2ff\"), \"name\" : \"xm\", \"score\" : [ 79, 85 ] } 1、$all查询score包含[70,80]的数据12&gt; db.c8.find({score:{$all:[70,80]}}){ \"_id\" : ObjectId(\"5f992b347c6aa7043a43d2fc\"), \"name\" : \"yz\", \"score\" : [ 70, 80, 90 ] } 2、$size查询score长度为3数据12&gt; db.c8.find({score:{$size:2}}){ \"_id\" : ObjectId(\"5f992e637c6aa7043a43d2ff\"), \"name\" : \"xm\", \"score\" : [ 79, 85 ] } 3、$elemMatch查询数组中至少有一个元素满足所有指定条件的文档查询score中至少有一个介于80和60之间 12345&gt; db.c8.find({score:{$elemMatch:{$lt:80,$gt:60}}}){ \"_id\" : ObjectId(\"5f992b347c6aa7043a43d2fc\"), \"name\" : \"yz\", \"score\" : [ 70, 80, 90 ] }{ \"_id\" : ObjectId(\"5f992b407c6aa7043a43d2fd\"), \"name\" : \"lh\", \"score\" : [ 70, 85, 92 ] }{ \"_id\" : ObjectId(\"5f992b497c6aa7043a43d2fe\"), \"name\" : \"llx\", \"score\" : [ 79, 85, 92 ] }{ \"_id\" : ObjectId(\"5f992e637c6aa7043a43d2ff\"), \"name\" : \"xm\", \"score\" : [ 79, 85 ] } 4、查询数组第一个值为70的数据123&gt; db.c8.find({\"score.0\":70}){ \"_id\" : ObjectId(\"5f992b347c6aa7043a43d2fc\"), \"name\" : \"yz\", \"score\" : [ 70, 80, 90 ] }{ \"_id\" : ObjectId(\"5f992b407c6aa7043a43d2fd\"), \"name\" : \"lh\", \"score\" : [ 70, 85, 92 ] } 五、元查询操作符 方法名 描述 $type 数据类型操作符 $exists 判断字段是否存在，1为存在，0为不存在 1、$type查询数据为某个类型的数据 类型 数字 备注 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1。 Max key 127 c9的数据集为： 1234&gt; db.c9.find(){ \"_id\" : ObjectId(\"5f993d7b7c6aa7043a43d300\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f993d847c6aa7043a43d301\"), \"name\" : \"ls\", \"age\" : \"20\" }{ \"_id\" : ObjectId(\"5f993e247c6aa7043a43d302\"), \"name\" : \"ww\", \"age\" : 20, \"score\" : 95 } 查询age为字符串类型的数据 12&gt; db.c9.find({age:{\"$type\":2}}){ \"_id\" : ObjectId(\"5f993d847c6aa7043a43d301\"), \"name\" : \"ls\", \"age\" : \"20\" } 2、$exists查询某个字段存在的数据12345&gt; db.c9.find({score:{$exists:1}}){ \"_id\" : ObjectId(\"5f993e247c6aa7043a43d302\"), \"name\" : \"ww\", \"age\" : 20, \"score\" : 95 }&gt; db.c9.find({score:{$exists:0}}){ \"_id\" : ObjectId(\"5f993d7b7c6aa7043a43d300\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f993d847c6aa7043a43d301\"), \"name\" : \"ls\", \"age\" : \"20\" } db.c9.find({score:{$exists:1}}){ “_id” : ObjectId(“5f993e247c6aa7043a43d302”), “name” : “ww”, “age” : 20, “score” : 95 }db.c9.find({score:{$exists:0}}){ “_id” : ObjectId(“5f993d7b7c6aa7043a43d300”), “name” : “zs”, “age” : 20 }{ “_id” : ObjectId(“5f993d847c6aa7043a43d301”), “name” : “ls”, “age” : “20” }","categories":[],"tags":[]},{"title":"更新操作符","slug":"TreasureBox/数据库/MongoDB/5.更新操作符","date":"2022-05-19T01:14:40.404Z","updated":"2023-04-28T09:25:47.194Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/5.geng-xin-cao-zuo-fu/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/5.geng-xin-cao-zuo-fu/","excerpt":"","text":"更新操作符[TOC] 一、字段更新操作符 方法 描述 $mul { $mul: { field: } } 把某个数字字段的值更新为n倍 $max 当要设置的值比原值大时才更新数据 $min 当要设置的值比原值小时才更新数据 $set 修改某几个字段的值 $inc 对一个数字字段的某个field增加value $rename 字段重命名 $unset 删除字段 $setOnInsert 更新操作插入新的数据时setOnInsert的值才会插入 $currentDate 修改数据时，将时间字段的值赋值为当前时间 c10的数据集为： 123&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\", \"age\" : 20 } 1、$mul 将name为zs的年龄乘以212345&gt; db.c10.update({name:\"zs\"},{$mul:{age:2}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 20 }&gt; db.c10.insert({\"name\":\"lisi\",age:20}) 2、$max当要设置的值比原来数据大时才更新数据12345678910&gt; db.c10.update({name:\"zs\"},{$max:{age:30}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 30 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\", \"age\" : 20 }&gt; db.c10.update({name:\"zs\"},{$max:{age:10}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 0 })&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 30 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\", \"age\" : 20 } 3、$min当要设置的值比原来的数据小时才更新数据12345&gt; db.c10.update({name:\"lisi\"},{$min:{age:10}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 30 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\", \"age\" : 10 } 4、$set设置某一个字段的值12345&gt; db.c10.update({name:\"lisi\"},{$set:{age:20,gender:1}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 30 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\", \"age\" : 20, \"gender\" : 1 } 5、$inc将某个数字字段增加某个值12345&gt; db.c10.update({name:\"lisi\"},{$inc:{age:1}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 30 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\", \"age\" : 21, \"gender\" : 1 } 6、$rename将字段重命名12345&gt; db.c10.update({name:\"lisi\"},{$rename:{gender:\"sex\"}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 30 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\", \"age\" : 21, \"sex\" : 1 } 7、$unset删除字段12345&gt; db.c10.update({name:\"lisi\"},{$unset:{age:0}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 30 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\"} 8、$setOnInsert当更新操作插入数据时才会插入$setOnInsert的值12345678910111213141516&gt; db.c10.update({name:\"lisi\"},{$set:{item:0},$setOnInsert:{default:10}},{upsert:true})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 30 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\", \"item\" : 0 }&gt; db.c10.update({name:\"wangwu\"},{$set:{item:0},$setOnInsert:{default:10}},{upsert:true})WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : ObjectId(\"5f9a2725a17f7147cf7941cd\")})&gt; db.c10.find(){ \"_id\" : ObjectId(\"5f99425f7c6aa7043a43d303\"), \"name\" : \"zs\", \"age\" : 30 }{ \"_id\" : ObjectId(\"5f99431b7c6aa7043a43d304\"), \"name\" : \"lisi\", \"item\" : 0 }{ \"_id\" : ObjectId(\"5f9a2725a17f7147cf7941cd\"), \"name\" : \"wangwu\", \"item\" : 0, \"default\" : 10 } 9、$currentDate当更新数据时把某个时间字段赋值为当前时间12345678910111213141516171819202122&gt; db.customers.insertOne(... { _id: 1, status: \"a\", lastModified: ISODate(\"2013-10-02T01:11:18.965Z\") }... ){ \"acknowledged\" : true, \"insertedId\" : 1 }&gt; db.customers.find(){ \"_id\" : 1, \"status\" : \"a\", \"lastModified\" : ISODate(\"2013-10-02T01:11:18.965Z\") }&gt; db.customers.updateOne(... { _id: 1 },... {... $currentDate: {... lastModified: true,... \"cancellation.date\": { $type: \"timestamp\" }... },... $set: {... \"cancellation.reason\": \"user request\",... status: \"D\"... }... }... ){ \"acknowledged\" : true, \"matchedCount\" : 1, \"modifiedCount\" : 1 }&gt; db.customers.find(){ \"_id\" : 1, \"status\" : \"D\", \"lastModified\" : ISODate(\"2020-10-29T02:28:09.052Z\"), \"cancellation\" : { \"date\" : Timestamp(1603938489, 1), \"reason\" : \"user request\" } } 二、数组更新操作符 方法名 描述 $each $sort $position $pull 从数组中删除一个等于value的值 $push 把value追加到field里 $pushAll 用法同$push一样，只是一次可以追加多个值到同一个数组中 $addToSet 加一个值到数组中，而且只有当这个值不在数组内才增加 $pullAll 用法同$pull一样，可以一次删除多个值 $pop 删除数组中的一个值 ll一样，可以一次删除多个值 || $pop | 删除数组中的一个值 |","categories":[],"tags":[]},{"title":"集合方法","slug":"TreasureBox/数据库/MongoDB/6.集合方法","date":"2022-05-19T01:14:40.404Z","updated":"2023-04-28T09:25:47.192Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/6.ji-he-fang-fa/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/6.ji-he-fang-fa/","excerpt":"","text":"集合方法 方法名 描述 db.collection.aggregate() 聚合，主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果 db.collection.bulkWrite() 批量写入 db.collection.createIndex() 创建一个集合索引 db.collection.count() 返回集合总数或匹配查询的结果集总数 db.collection.deleteOne() 删除集合中的一个文档 db.collection.deleteMany() 删除集合中的多个文档 db.collection.dataSize() 返回集合的大小 db.collection.distinct() 返回具有指定字段不同值的文档（去除指定字段的重复数据） db.collection.dropIndex() 删除一个集合中的指定索引 db.collection.dropIndexes() 删除一个集合中的所有索引 db.collection.drop() 删除当前数据库中的collection集合 db.collection.explain() 返回各种方法的查询执行信息 db.collection.ensureIndex() 已过时，现使用db.collection.createIndex() db.collection.findOne() 查询单条数据 db.collection.findOneAndReplace() 查询单条数据并替换 db.collection.findOneAndDelete() 查询单条数据并删除 db.collection.findOneAndUpdate() 查询单条数据并更新 db.collection.find() 查询集合，无参数则查询所有，并返回一个游标对象 db.collection.findAndModify() 查询并修改 db.collection.getIndexes() 返回当前集合的所有索引数组 db.collection.group() 提供简单的数据聚合功能 db.collection.isCapped() 判断集合是否为定容量 db.collection.insert() 在当前集合插入一条或多条数据（或叫文档） db.collection.insertMany() 在当前集合插入多条数据 db.collection.insertOne() 在当前集合插入一条数据 db.collection.reIndex() 重建当前集合的所有索引 db.collection.renameCollection() 重命名集合名称 db.collection.replaceOne() 替换集合中的一个文档（一条数据） db.collection.remove() 从当前集合删除数据 db.collection.save() 已插入数据更新 db.collection.stats() 返回当前集合的状态 db.collection.storageSize() 返回当前集合已使用的空间大小 db.collection.totalSize() 返回当前集合的总占用空间，包括所有文件和所有索引 db.collection.totalIndexSize() 返回当前集合所有的索引所占用的空间大小 db.collection.updateMany() 修改集合中的多条数据 db.collection.update() 修改集合中的数据 db.collection.updateOne() 修改集合中的一条数据 db.collection.validate() 执行对集合验证操作","categories":[],"tags":[]},{"title":"数据库方法","slug":"TreasureBox/数据库/MongoDB/7.数据库方法","date":"2022-05-19T01:14:40.404Z","updated":"2023-04-28T09:25:47.194Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/7.shu-ju-ku-fang-fa/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/7.shu-ju-ku-fang-fa/","excerpt":"","text":"数据库方法 方法名 描述 db.cloneDatabase(） 从指定主机上克隆数据库 db.currentOp() 显示当前正在进行的操作 db.commandHelp() 返回数据库命令的帮助信息 db.createCollection() 创建一个聚集集合（table） db.cloneCollection() 在MongoDB实例之间复制集合数据 db.copyDatabase(） 从指定的机器上复制指定数据库数据到某个数据库 db.dropDatabase(); 删除当前使用数据库 db.fsyncLock() 刷新写入磁盘并锁定该数据库，以防止写入操作，并协助备份操作 db.fsyncUnlock() 允许继续进行写入锁住的数据库（解锁） db.getLogComponents() 返回日志消息详细级别 db.getLastErrorObj() 查看完整的错误结果 db.getMongo() 查看当前db的链接机器地址 db.getCollection(） 得到指定名称的聚集集合（table） db.getName() 查看当前使用的数据库 db.getPrevError() 返回包含自上次错误复位所有的错误状态文件 db.getCollectionNames() 得到当前db的所有聚集集合 db.getCollectionInfos() 返回当前数据库中的所有集合信息 db.getLastError() 返回上一次错误，如果没有错误则为空 db.hostInfo() 返回当前数据库主机系统的相关信息 db.killOp() 终止指定的操作 db.listCommands() 显示公共数据库的命令列表 db.logout() 注销登录 db.printCollectionStats() 显示当前db所有聚集索引的状态 db.resetError() 重置db.getPrevError()和getPrevError返回的错误信息 db.repairDatabase() 修复当前数据库 db.repairDatabase() 修复当前数据库 db.runCommand() 运行一个数据库命令 db.serverStatus() 返回当前数据库状态的概要 db.setProfilingLevel() 修改当前数据库的分析级别 db.stats() 显示当前db状态 db.shutdownServer() 关闭当前数据库运行实例或安全停止有关操作进程 db.setLogLevel() 设置一个单独的日志信息级别 db.version() 查看当前db版本","categories":[],"tags":[]},{"title":"用户管理方法","slug":"TreasureBox/数据库/MongoDB/8.用户管理方法","date":"2022-05-19T01:14:40.404Z","updated":"2023-04-28T09:25:47.195Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/8.yong-hu-guan-li-fang-fa/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/8.yong-hu-guan-li-fang-fa/","excerpt":"","text":"用户管理方法 方法名 描述 db.getUsers() db.dropAllUsers() db.updateUser() db.createUser() db.revokeRolesFromUser() db.removeUser() 删除用户 db.grantRolesToUser() db.getUser() db.changeUserPassword() db.auth() 数据库认证、安全模式","categories":[],"tags":[]},{"title":"连接方法","slug":"TreasureBox/数据库/MongoDB/9.连接方法","date":"2022-05-19T01:14:40.404Z","updated":"2023-04-28T09:25:47.194Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/9.lian-jie-fang-fa/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/9.lian-jie-fang-fa/","excerpt":"","text":"连接方法 方法名 描述 Mongo.setSlaveOk() 设置从库可以进行数据查询操作 Mongo.setReadPref() Mongo.getReadPrefTagSet() Mongo.getReadPrefMode() Mongo.getDB()","categories":[],"tags":[]},{"title":"mongoDB工具","slug":"TreasureBox/数据库/MongoDB/0.mongoDB工具","date":"2022-05-19T01:14:40.403Z","updated":"2023-04-28T09:25:47.193Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/0.mongodb-gong-ju/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/0.mongodb-gong-ju/","excerpt":"","text":"MongoDB工具MongoDB在bin目录中提供了一系列有用的工具这些工具提供了MongoDB在运维管理上的方便。 工具 描述 mongosniff mongodb监测工具，作用等同于tcpdump mongodump mongo数据备份工具mongodump -h dbhost -d dbname -o dbdirectory-h：MongoDB所在的服务器地址-d：需要备份的数据库实例-o：备份的数据存放位置 mongoimport mongodb数据导入工具 mongoexport mongo数据导出工具 bsondump 将bson格式数据转出为json格式数据 mongoperf mongorestore mongodb数据恢复工具 mongod.exe MongoDB服务启动工具 mongofiles GridFS管理工具，可实现二进制文件的存取 mongooplog mongotop 跟踪一个MongoDB实例，查看哪些大量的时间花费在读取和写入数据。 mongos 分片路由。如果使用了sharding功能，则应用程序连接的是mongos而不会mongod mongo 客户端命令行工具，支持js语法 配置数据库用户名和密码： 要为数据库创建用户，必须先切换到相应的数据库 12345#先切换use 数据库名；#再创建db.createUser({}) 设置 admin（给admin这个库在设置密码）123456789use.admin db.createUser({ user: 'admin', // 用户名 pwd: '123456', // 密码 roles:[{ role: 'root', // 角色 db: 'admin' // 数据库 }]}) 查看用户是否设置成功： 12345678910111213&gt; show users{ \"_id\" : \"admin.admin\", \"user\" : \"admin\", \"db\" : \"admin\", \"roles\" : [ { \"role\" : \"root\", \"db\" : \"admin\" } ]}&gt; 1234567show users // 查看当前库下的用户db.dropUser('testadmin') // 删除用户db.updateUser('admin', {pwd: '654321'}) // 修改用户密码db.auth('admin', '654321') // 密码认证 h(‘admin’, ‘654321’) // 密码认证","categories":[],"tags":[]},{"title":"基本命令","slug":"TreasureBox/数据库/MongoDB/1.基本命令","date":"2022-05-19T01:14:40.403Z","updated":"2023-04-28T09:25:47.192Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/1.ji-ben-ming-ling/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/1.ji-ben-ming-ling/","excerpt":"","text":"Mongo简介和基本使用[TOC] 一、MongoDB简介1、什么是MongoDBMongoDB是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB旨在为web应用提供可扩展的高性能数据存储解决方案。 MongoDB将数据存储为一个文档，数据结构由键值（key=&gt;value）对组成。MongoDB文档类似于JSON对象，字段值可以包含其他文档，数组及文档数组。 2、主要特点 MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。 你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。 你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。 Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。 MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。 Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。 Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。 Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。 GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。 MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。 MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。 MongoDB安装简单。 3、非关系型数据库介绍 二、基本操作1、连接数据库: mongo 新建的默认有两个数据库： admin–配置权限local–固定的重要数据 2、查看数据库 show dbs show databases 3、创建数据库 直接进行数据库切换就可以创建：use school 12345678&gt; show databasesadmin 0.000GBlocal 0.000GB&gt; use schoolswitched to db school&gt; show databasesadmin 0.000GBlocal 0.000GB ① 这个时候并没有显示，是因为数据库中没有集合，插入集合之后即可以显示： 123456&gt; db.stu.insert({\"name\":\"youzi\",\"age\":24})WriteResult({ \"nInserted\" : 1 })&gt; show dbsadmin 0.000GBlocal 0.000GBschool 0.000GB ② 还可以使用db.createCollection(‘colloection_name’)直接创建一个集合： 1234567891011121314151617&gt; show databases;admin 0.000GBlocal 0.000GBschool 0.000GB&gt; use poppleswitched to db people&gt; show dbsadmin 0.000GBlocal 0.000GBschool 0.000GB&gt; db.createCollection('man'){ \"ok\" : 1 }&gt; show dbsadmin 0.000GBlocal 0.000GBpeople 0.000GBschool 0.000GB 4、查看当前所在库12&gt; dbstudent 5、查看集合show tables或show collections 123456&gt; show tables; peoplestu&gt; show collectionspeoplestu 6、删除库和集合① 删除集合db.collectionName.drop() 1234567&gt; show collectionspeoplestu&gt; db.stu.drop()true&gt; show tablespeople ② 删除数据库：切换到要删除的数据库，然后执行：db.dropDatabase() 12345678&gt; db.dropDatabase(){ \"dropped\" : \"school\", \"ok\" : 1 }&gt; db.dropDatabase(){ \"ok\" : 1 }&gt; show dbsadmin 0.000GBlocal 0.000GBpeople 0.000GB 当库中没有集合时，库也会自动删除。 12345678910111213&gt; db.createCollection(\"man\"){ \"ok\" : 1 }&gt; show tables;man&gt; show dbsadmin 0.000GBlocal 0.000GBpeople 0.000GB&gt; db.man.drop()true&gt; show dbsadmin 0.000GBlocal 0.000GB show dbsadmin 0.000GBlocal 0.000GBpeople 0.000GBdb.man.drop()trueshow dbsadmin 0.000GBlocal 0.000GB","categories":[],"tags":[]},{"title":"MONGO集群","slug":"TreasureBox/数据库/MongoDB/10.MONGO集群","date":"2022-05-19T01:14:40.403Z","updated":"2023-04-28T09:25:47.197Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/10.mongo-ji-qun/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/10.mongo-ji-qun/","excerpt":"","text":"MONGO集群MONGO的三种集群：Replica Set / Sharding / Master-Slaver， Replica Set： Mongodb(M)表示主节点，Mongodb(s)表示备节点，Mongodb(A)","categories":[],"tags":[]},{"title":"增删改查","slug":"TreasureBox/数据库/MongoDB/2.增删改查","date":"2022-05-19T01:14:40.403Z","updated":"2023-04-28T09:25:47.196Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/2.zeng-shan-gai-cha/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/2.zeng-shan-gai-cha/","excerpt":"","text":"CRUD操作[TOC] 一、插入文档插入文档的方式共有三种，每一种的返回值不同： db.collection.insert() db.collection.insertOne() 3.2新增功能 db.collection.insertMany() 3.2新增功能 MongoDB存储的是文档，文档其实就是json对象。存储于集合中的每一个文档都需要一个唯一的_id字段作为primary_key。如果一个插入的文档操作遗漏了_id字段，MongoDB驱动会自动为_id字段生成一个ObjectId。 1、insert增加单条数据12&gt; db.man.insert({name:'youzi'})WriteResult({ \"nInserted\" : 1 }) 2、insert增加多条数据1234567891011&gt; db.man.insert([{name:'zhangsan'},{name:'dachang'}])BulkWriteResult({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ ], \"nInserted\" : 2, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ]}) 3、insertOne插入一条数据12345&gt; db.man.insertOne({name:'xiaxia'}){ \"acknowledged\" : true, \"insertedId\" : ObjectId(\"5f0589da25bd42dbbb1469b4\")} 4、InsertMany插入多条数据1234567&gt; db.man.insertMany([{name:'liuhuan'}]){ \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"5f0589fe25bd42dbbb1469b5\") ]} 二、查询文档1、判断符MongoDB中提供了db.collection.find()方法从集合中读取文档。返回指向匹配文档的：doc:cursor&lt;/tutorial/iterate-a-cursor&gt;。 1db.collection.find( &lt;query filter&gt; , &lt;projection&gt; ) 判断符 含义 name:‘zhangsan’ 相等 $gt:10 大于 $lt:10 小于 $gte:10 大于等于 $lte:10 小于等于 $ne:10 不等于 $nin:[1,2] 不在某个范围内 $in:[1,2] 在 $and:[条件1,条件2] 并且 $or:[条件1,条件2] 或 $all:[20,30] 指定的数据都要有db.collection.find({age:{$all:[‘lisi’]}}) $exists name:{$exists:1}，是否存在某一列，1代表存在，0代表不存在。&lt;br db.collection.find({name:{$exists:1}}) count() 统计数量db.stu.find().count() limit() 查看指定数量的结果db.collection.find().limit(4) skip() db.collection.find().skip(4) $mod 取模计算 $regex 模糊查询，查询该字段包含某个字符串 $text 对有text索引的字段进行模糊查询 $where 使用js代码查询数据 在相同字段执行等于查询时，建议使用$in而不使用$or。 首先插入数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687db.users.insertMany( [ { _id: 1, name: \"sue\", age: 19, type: 1, status: \"P\", favorites: { artist: \"Picasso\", food: \"pizza\" }, finished: [ 17, 3 ], badges: [ \"blue\", \"black\" ], points: [ { points: 85, bonus: 20 }, { points: 85, bonus: 10 } ] }, { _id: 2, name: \"bob\", age: 42, type: 1, status: \"A\", favorites: { artist: \"Miro\", food: \"meringue\" }, finished: [ 11, 25 ], badges: [ \"green\" ], points: [ { points: 85, bonus: 20 }, { points: 64, bonus: 12 } ] }, { _id: 3, name: \"ahn\", age: 22, type: 2, status: \"A\", favorites: { artist: \"Cassatt\", food: \"cake\" }, finished: [ 6 ], badges: [ \"blue\", \"red\" ], points: [ { points: 81, bonus: 8 }, { points: 55, bonus: 20 } ] }, { _id: 4, name: \"xi\", age: 34, type: 2, status: \"D\", favorites: { artist: \"Chagall\", food: \"chocolate\" }, finished: [ 5, 11 ], badges: [ \"red\", \"black\" ], points: [ { points: 53, bonus: 15 }, { points: 51, bonus: 15 } ] }, { _id: 5, name: \"xyz\", age: 23, type: 2, status: \"D\", favorites: { artist: \"Noguchi\", food: \"nougat\" }, finished: [ 14, 6 ], badges: [ \"orange\" ], points: [ { points: 71, bonus: 20 } ] }, { _id: 6, name: \"abc\", age: 43, type: 1, status: \"A\", favorites: { food: \"pizza\", artist: \"Picasso\" }, finished: [ 18, 12 ], badges: [ \"black\", \"blue\" ], points: [ { points: 78, bonus: 8 }, { points: 57, bonus: 7 } ] } ]) 2、练习1、查询status为A的文档12345&gt; db.users.find({status:\"A\"}){ \"_id\" : 2, \"name\" : \"bob\", \"age\" : 42, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Miro\", \"food\" : \"meringue\" }, \"finished\" : [ 11, 25 ], \"badges\" : [ \"green\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 64, \"bonus\" : 12 } ] }{ \"_id\" : 3, \"name\" : \"ahn\", \"age\" : 22, \"type\" : 2, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Cassatt\", \"food\" : \"cake\" }, \"finished\" : [ 6 ], \"badges\" : [ \"blue\", \"red\" ], \"points\" : [ { \"points\" : 81, \"bonus\" : 8 }, { \"points\" : 55, \"bonus\" : 20 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"food\" : \"pizza\", \"artist\" : \"Picasso\" }, \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ], \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] }&gt; 2、查询status为P或D的文档1234&gt; db.users.find({status:{$in:[\"P\",\"D\"]}}){ \"_id\" : 1, \"name\" : \"sue\", \"age\" : 19, \"type\" : 1, \"status\" : \"P\", \"favorites\" : { \"artist\" : \"Picasso\", \"food\" : \"pizza\" }, \"finished\" : [ 17, 3 ], \"badges\" : [ \"blue\", \"black\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 85, \"bonus\" : 10 } ] }{ \"_id\" : 4, \"name\" : \"xi\", \"age\" : 34, \"type\" : 2, \"status\" : \"D\", \"favorites\" : { \"artist\" : \"Chagall\", \"food\" : \"chocolate\" }, \"finished\" : [ 5, 11 ], \"badges\" : [ \"red\", \"black\" ], \"points\" : [ { \"points\" : 53, \"bonus\" : 15 }, { \"points\" : 51, \"bonus\" : 15 } ] }{ \"_id\" : 5, \"name\" : \"xyz\", \"age\" : 23, \"type\" : 2, \"status\" : \"D\", \"favorites\" : { \"artist\" : \"Noguchi\", \"food\" : \"nougat\" }, \"finished\" : [ 14, 6 ], \"badges\" : [ \"orange\" ], \"points\" : [ { \"points\" : 71, \"bonus\" : 20 } ] } 3、查询status为A并且age小于30的文档12&gt; db.users.find({status:\"A\",age:{$lt:30}}){ \"_id\" : 3, \"name\" : \"ahn\", \"age\" : 22, \"type\" : 2, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Cassatt\", \"food\" : \"cake\" }, \"finished\" : [ 6 ], \"badges\" : [ \"blue\", \"red\" ], \"points\" : [ { \"points\" : 81, \"bonus\" : 8 }, { \"points\" : 55, \"bonus\" : 20 } ] } 4、查询status为A或者age小于30的文档123456&gt; db.users.find({$or:[{status:\"A\"},{age:{$lt:30}}]}){ \"_id\" : 1, \"name\" : \"sue\", \"age\" : 19, \"type\" : 1, \"status\" : \"P\", \"favorites\" : { \"artist\" : \"Picasso\", \"food\" : \"pizza\" }, \"finished\" : [ 17, 3 ], \"badges\" : [ \"blue\", \"black\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 85, \"bonus\" : 10 } ] }{ \"_id\" : 2, \"name\" : \"bob\", \"age\" : 42, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Miro\", \"food\" : \"meringue\" }, \"finished\" : [ 11, 25 ], \"badges\" : [ \"green\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 64, \"bonus\" : 12 } ] }{ \"_id\" : 3, \"name\" : \"ahn\", \"age\" : 22, \"type\" : 2, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Cassatt\", \"food\" : \"cake\" }, \"finished\" : [ 6 ], \"badges\" : [ \"blue\", \"red\" ], \"points\" : [ { \"points\" : 81, \"bonus\" : 8 }, { \"points\" : 55, \"bonus\" : 20 } ] }{ \"_id\" : 5, \"name\" : \"xyz\", \"age\" : 23, \"type\" : 2, \"status\" : \"D\", \"favorites\" : { \"artist\" : \"Noguchi\", \"food\" : \"nougat\" }, \"finished\" : [ 14, 6 ], \"badges\" : [ \"orange\" ], \"points\" : [ { \"points\" : 71, \"bonus\" : 20 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"food\" : \"pizza\", \"artist\" : \"Picasso\" }, \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ], \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] } 5、查询status为A并且要么age小于30要么type为1的文档1234&gt; db.users.find({status:\"A\",$or:[{age:{$lt:30}},{type:1}]}){ \"_id\" : 2, \"name\" : \"bob\", \"age\" : 42, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Miro\", \"food\" : \"meringue\" }, \"finished\" : [ 11, 25 ], \"badges\" : [ \"green\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 64, \"bonus\" : 12 } ] }{ \"_id\" : 3, \"name\" : \"ahn\", \"age\" : 22, \"type\" : 2, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Cassatt\", \"food\" : \"cake\" }, \"finished\" : [ 6 ], \"badges\" : [ \"blue\", \"red\" ], \"points\" : [ { \"points\" : 81, \"bonus\" : 8 }, { \"points\" : 55, \"bonus\" : 20 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"food\" : \"pizza\", \"artist\" : \"Picasso\" }, \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ], \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] } 6、嵌套文档的精确查询12&gt; db.users.find( { favorites: { artist: \"Picasso\", food: \"pizza\" } } ){ \"_id\" : 1, \"name\" : \"sue\", \"age\" : 19, \"type\" : 1, \"status\" : \"P\", \"favorites\" : { \"artist\" : \"Picasso\", \"food\" : \"pizza\" }, \"finished\" : [ 17, 3 ], \"badges\" : [ \"blue\", \"black\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 85, \"bonus\" : 10 } ] } 7、嵌套文档中字段的等于匹配123&gt; db.users.find( { \"favorites.artist\": \"Picasso\" } ){ \"_id\" : 1, \"name\" : \"sue\", \"age\" : 19, \"type\" : 1, \"status\" : \"P\", \"favorites\" : { \"artist\" : \"Picasso\", \"food\" : \"pizza\" }, \"finished\" : [ 17, 3 ], \"badges\" : [ \"blue\", \"black\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 85, \"bonus\" : 10 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"food\" : \"pizza\", \"artist\" : \"Picasso\" }, \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ], \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] } 8、数组中的精确匹配12&gt; db.users.find( { badges: [ \"blue\", \"black\" ] } ){ \"_id\" : 1, \"name\" : \"sue\", \"age\" : 19, \"type\" : 1, \"status\" : \"P\", \"favorites\" : { \"artist\" : \"Picasso\", \"food\" : \"pizza\" }, \"finished\" : [ 17, 3 ], \"badges\" : [ \"blue\", \"black\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 85, \"bonus\" : 10 } ] } 9、匹配数组中包含某个元素的文档1234&gt; db.users.find( { badges: \"black\" } ){ \"_id\" : 1, \"name\" : \"sue\", \"age\" : 19, \"type\" : 1, \"status\" : \"P\", \"favorites\" : { \"artist\" : \"Picasso\", \"food\" : \"pizza\" }, \"finished\" : [ 17, 3 ], \"badges\" : [ \"blue\", \"black\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 85, \"bonus\" : 10 } ] }{ \"_id\" : 4, \"name\" : \"xi\", \"age\" : 34, \"type\" : 2, \"status\" : \"D\", \"favorites\" : { \"artist\" : \"Chagall\", \"food\" : \"chocolate\" }, \"finished\" : [ 5, 11 ], \"badges\" : [ \"red\", \"black\" ], \"points\" : [ { \"points\" : 53, \"bonus\" : 15 }, { \"points\" : 51, \"bonus\" : 15 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"food\" : \"pizza\", \"artist\" : \"Picasso\" }, \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ], \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] } 10、匹配数组指定位置为某个值的元素12&gt; db.users.find( { \"badges.0\": \"black\" } ){ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"food\" : \"pizza\", \"artist\" : \"Picasso\" }, \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ], \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] } 11、$elemMatch查询数组中至少有一个元素满足所有指定条件的文档至少有一个元素满足小于20并且大于15。 123&gt; db.users.find( { finished: { $elemMatch: { $gt: 15, $lt: 20 } } } ){ \"_id\" : 1, \"name\" : \"sue\", \"age\" : 19, \"type\" : 1, \"status\" : \"P\", \"favorites\" : { \"artist\" : \"Picasso\", \"food\" : \"pizza\" }, \"finished\" : [ 17, 3 ], \"badges\" : [ \"blue\", \"black\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 85, \"bonus\" : 10 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"food\" : \"pizza\", \"artist\" : \"Picasso\" }, \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ], \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] } 11、元素组合满足查询条件查询一个元素小于15另一个元素大于20或者某一个元素同时满足这两个条件 1234&gt; db.users.find( { finished: { $gt: 15, $lt: 20 } } ){ \"_id\" : 1, \"name\" : \"sue\", \"age\" : 19, \"type\" : 1, \"status\" : \"P\", \"favorites\" : { \"artist\" : \"Picasso\", \"food\" : \"pizza\" }, \"finished\" : [ 17, 3 ], \"badges\" : [ \"blue\", \"black\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 85, \"bonus\" : 10 } ] }{ \"_id\" : 2, \"name\" : \"bob\", \"age\" : 42, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Miro\", \"food\" : \"meringue\" }, \"finished\" : [ 11, 25 ], \"badges\" : [ \"green\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 64, \"bonus\" : 12 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"food\" : \"pizza\", \"artist\" : \"Picasso\" }, \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ], \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] } 12、使用数组指定索引匹配嵌入文档中的字段12&gt; db.users.find( { 'points.0.points': { $lte: 55 } } ){ \"_id\" : 4, \"name\" : \"xi\", \"age\" : 34, \"type\" : 2, \"status\" : \"D\", \"favorites\" : { \"artist\" : \"Chagall\", \"food\" : \"chocolate\" }, \"finished\" : [ 5, 11 ], \"badges\" : [ \"red\", \"black\" ], \"points\" : [ { \"points\" : 53, \"bonus\" : 15 }, { \"points\" : 51, \"bonus\" : 15 } ] } 13、使用数组不指定索引匹配嵌入文档中的字段123&gt; db.users.find( { 'points.points': { $lte: 55 } } ){ \"_id\" : 3, \"name\" : \"ahn\", \"age\" : 22, \"type\" : 2, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Cassatt\", \"food\" : \"cake\" }, \"finished\" : [ 6 ], \"badges\" : [ \"blue\", \"red\" ], \"points\" : [ { \"points\" : 81, \"bonus\" : 8 }, { \"points\" : 55, \"bonus\" : 20 } ] }{ \"_id\" : 4, \"name\" : \"xi\", \"age\" : 34, \"type\" : 2, \"status\" : \"D\", \"favorites\" : { \"artist\" : \"Chagall\", \"food\" : \"chocolate\" }, \"finished\" : [ 5, 11 ], \"badges\" : [ \"red\", \"black\" ], \"points\" : [ { \"points\" : 53, \"bonus\" : 15 }, { \"points\" : 51, \"bonus\" : 15 } ] } 14、单个元素满足条件使用 $elemMatch操作符为数组元素指定符合条件，以查询数组中至少一个元素满足所有指定条件的文档。 下面的例子查询 points 数组有至少一个包含 points 小于等于 70 并且字段 bonus 等于 20 的内嵌文档的文档。 12&gt; db.users.find( { points: { $elemMatch: { points: { $lte: 70 }, bonus: 20 } } } ){ \"_id\" : 3, \"name\" : \"ahn\", \"age\" : 22, \"type\" : 2, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Cassatt\", \"food\" : \"cake\" }, \"finished\" : [ 6 ], \"badges\" : [ \"blue\", \"red\" ], \"points\" : [ { \"points\" : 81, \"bonus\" : 8 }, { \"points\" : 55, \"bonus\" : 20 } ] } 15、元素组合满足某个条件123&gt; db.users.find( { \"points.points\": { $lte: 70 }, \"points.bonus\": 20 } ){ \"_id\" : 2, \"name\" : \"bob\", \"age\" : 42, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Miro\", \"food\" : \"meringue\" }, \"finished\" : [ 11, 25 ], \"badges\" : [ \"green\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 64, \"bonus\" : 12 } ] }{ \"_id\" : 3, \"name\" : \"ahn\", \"age\" : 22, \"type\" : 2, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Cassatt\", \"food\" : \"cake\" }, \"finished\" : [ 6 ], \"badges\" : [ \"blue\", \"red\" ], \"points\" : [ { \"points\" : 81, \"bonus\" : 8 }, { \"points\" : 55, \"bonus\" : 20 } ] } 16、使用$mod进行模运算查询c1的数据集如下： 12345&gt; db.c1.find(){ \"_id\" : ObjectId(\"5f97bb1a0436fe0f6dbb0526\"), \"age\" : 1, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb200436fe0f6dbb0527\"), \"age\" : 7, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb260436fe0f6dbb0528\"), \"age\" : 8, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb860436fe0f6dbb052a\"), \"age\" : 13, \"length\" : 30 } 取年龄模6结果为1的数据 1234&gt; db.c1.find({age:{$mod:[6,1]}}){ \"_id\" : ObjectId(\"5f97bb1a0436fe0f6dbb0526\"), \"age\" : 1, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb200436fe0f6dbb0527\"), \"age\" : 7, \"length\" : 30 }{ \"_id\" : ObjectId(\"5f97bb860436fe0f6dbb052a\"), \"age\" : 13, \"length\" : 30 } 17、使用$regex进行模糊查询c2的数据集如下： 12345&gt; db.c2.find() { \"_id\" : ObjectId(\"5f97bc460436fe0f6dbb052b\"), \"name\" : \"小明\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc4c0436fe0f6dbb052c\"), \"name\" : \"小刚\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc570436fe0f6dbb052d\"), \"name\" : \"小明明\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc5f0436fe0f6dbb052e\"), \"name\" : \"大明\", \"age\" : 20 } 查name中包含“明”的数据： 1234&gt; db.c2.find({name:{\"$regex\":\"明\"}})){ \"_id\" : ObjectId(\"5f97bc460436fe0f6dbb052b\"), \"name\" : \"小明\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc570436fe0f6dbb052d\"), \"name\" : \"小明明\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5f97bc5f0436fe0f6dbb052e\"), \"name\" : \"大明\", \"age\" : 20 } 18、使用$text对有text索引的字段进行模糊查询先对c4添加索引： 1&gt; db.c4.createIndex( { subject: \"text\" } ) c4的数据集如下： 123456&gt; db.c4.find( ){ \"_id\" : 1, \"subject\" : \"hello world\", \"title\" : \"hello\" }{ \"_id\" : 2, \"subject\" : \"hello python\", \"title\" : \"python\" }{ \"_id\" : 3, \"subject\" : \"hello java\", \"title\" : \"java\" }{ \"_id\" : 4, \"subject\" : \"hello mongodb\", \"title\" : \"mongodb\" }{ \"_id\" : 5, \"subject\" : \"中文\", \"title\" : \"mongodb\" } 使用”$text”进行查询 12&gt; db.c4.find({\"$text\":{\"$search\":\"world\"}}){ \"_id\" : 1, \"subject\" : \"hello world\", \"title\" : \"hello\" } 19、使用$where进行查询c5的数据集如下： 1234&gt; db.c5.find(){ \"_id\" : ObjectId(\"5f98df8e4262ff84adb202d5\"), \"a\" : { \"a\" : 1 }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98df9c4262ff84adb202d6\"), \"a\" : { \"a\" : 1, \"b\" : \"1\" }, \"b\" : 2, \"c\" : 3 }{ \"_id\" : ObjectId(\"5f98df9f4262ff84adb202d7\"), \"a\" : { \"a\" : 1, \"b\" : \"2\" }, \"b\" : 2, \"c\" : 3 } 查询某条内嵌文档中a的值跟b的值相等的数据： 12&gt; db.c5.find({$where:\"this.a.a==this.a.b\"}){ \"_id\" : ObjectId(\"5f98df9c4262ff84adb202d6\"), \"a\" : { \"a\" : 1, \"b\" : \"1\" }, \"b\" : 2, \"c\" : 3 } 3、返回查询的映射字段插入数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687db.users.insertMany( [ { _id: 1, name: \"sue\", age: 19, type: 1, status: \"P\", favorites: { artist: \"Picasso\", food: \"pizza\" }, finished: [ 17, 3 ], badges: [ \"blue\", \"black\" ], points: [ { points: 85, bonus: 20 }, { points: 85, bonus: 10 } ] }, { _id: 2, name: \"bob\", age: 42, type: 1, status: \"A\", favorites: { artist: \"Miro\", food: \"meringue\" }, finished: [ 11, 25 ], badges: [ \"green\" ], points: [ { points: 85, bonus: 20 }, { points: 64, bonus: 12 } ] }, { _id: 3, name: \"ahn\", age: 22, type: 2, status: \"A\", favorites: { artist: \"Cassatt\", food: \"cake\" }, finished: [ 6 ], badges: [ \"blue\", \"red\" ], points: [ { points: 81, bonus: 8 }, { points: 55, bonus: 20 } ] }, { _id: 4, name: \"xi\", age: 34, type: 2, status: \"D\", favorites: { artist: \"Chagall\", food: \"chocolate\" }, finished: [ 5, 11 ], badges: [ \"red\", \"black\" ], points: [ { points: 53, bonus: 15 }, { points: 51, bonus: 15 } ] }, { _id: 5, name: \"xyz\", age: 23, type: 2, status: \"D\", favorites: { artist: \"Noguchi\", food: \"nougat\" }, finished: [ 14, 6 ], badges: [ \"orange\" ], points: [ { points: 71, bonus: 20 } ] }, { _id: 6, name: \"abc\", age: 43, type: 1, status: \"A\", favorites: { food: \"pizza\", artist: \"Picasso\" }, finished: [ 18, 12 ], badges: [ \"black\", \"blue\" ], points: [ { points: 78, bonus: 8 }, { points: 57, bonus: 7 } ] } ]) 1、映射文档映射文档限制返回匹配文档的所有字段，映射文档可以指明包括哪些字段或者排除哪些字段，格式为： { field1: , field2: } 1或true在返回的文档中包含字段 0或者false排除该字段 使用Projection Operators表达式 其中_id字段为默认显示的，当不想显示时必须设置为0。并且在指定时要么都设置为1，要么都设置为0，不能部分设置为1，部分设置为0. 返回匹配文档的所有字段如果没有指定映射，db.collection.find()方法将会返回满足查询的所有文档的所有字段。 12&gt; db.users.find({status:\"P\"}){ \"_id\" : 1, \"name\" : \"sue\", \"age\" : 19, \"type\" : 1, \"status\" : \"P\", \"favorites\" : { \"artist\" : \"Picasso\", \"food\" : \"pizza\" }, \"finished\" : [ 17, 3 ], \"badges\" : [ \"blue\", \"black\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 85, \"bonus\" : 10 } ] } 只返回指定字段和_id字段1234&gt; db.users.find({status:\"A\"},{name:1,status:1}){ \"_id\" : 2, \"name\" : \"bob\", \"status\" : \"A\" }{ \"_id\" : 3, \"name\" : \"ahn\", \"status\" : \"A\" }{ \"_id\" : 6, \"name\" : \"abc\", \"status\" : \"A\" } 只返回指定字段1234&gt; db.users.find({status:\"A\"},{name:1,status:1,_id:0}){ \"name\" : \"bob\", \"status\" : \"A\" }{ \"name\" : \"ahn\", \"status\" : \"A\" }{ \"name\" : \"abc\", \"status\" : \"A\" } 返回排除字段之外的所有字段1234&gt; db.users.find({status:\"A\"},{favorites:0,points:0}){ \"_id\" : 2, \"name\" : \"bob\", \"age\" : 42, \"type\" : 1, \"status\" : \"A\", \"finished\" : [ 11, 25 ], \"badges\" : [ \"green\" ] }{ \"_id\" : 3, \"name\" : \"ahn\", \"age\" : 22, \"type\" : 2, \"status\" : \"A\", \"finished\" : [ 6 ], \"badges\" : [ \"blue\", \"red\" ] }{ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ] } 返回嵌入文档中的指定字段使用dot notation返回嵌入文档中的特定字段 返回favorites文档中的food字段，food字段仍然保持嵌入在favorites文档中。 1234&gt; db.users.find({status:\"A\"},{name:1,status:1,'favorites.food':1}){ \"_id\" : 2, \"name\" : \"bob\", \"status\" : \"A\", \"favorites\" : { \"food\" : \"meringue\" } }{ \"_id\" : 3, \"name\" : \"ahn\", \"status\" : \"A\", \"favorites\" : { \"food\" : \"cake\" } }{ \"_id\" : 6, \"name\" : \"abc\", \"status\" : \"A\", \"favorites\" : { \"food\" : \"pizza\" } } 排除嵌入文档中的特定字段排除favorites中的food，其他的仍然嵌套显示。 1234&gt; db.users.find({status:\"A\"},{'favorites.food':0}){ \"_id\" : 2, \"name\" : \"bob\", \"age\" : 42, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Miro\" }, \"finished\" : [ 11, 25 ], \"badges\" : [ \"green\" ], \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 64, \"bonus\" : 12 } ] }{ \"_id\" : 3, \"name\" : \"ahn\", \"age\" : 22, \"type\" : 2, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Cassatt\" }, \"finished\" : [ 6 ], \"badges\" : [ \"blue\", \"red\" ], \"points\" : [ { \"points\" : 81, \"bonus\" : 8 }, { \"points\" : 55, \"bonus\" : 20 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"age\" : 43, \"type\" : 1, \"status\" : \"A\", \"favorites\" : { \"artist\" : \"Picasso\" }, \"finished\" : [ 18, 12 ], \"badges\" : [ \"black\", \"blue\" ], \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] } 映射数组中的嵌入文档使用dot notation映射嵌入数组中文档的特定字段。dot notation映射代表&lt;array&gt;.&lt;index&gt;格式的数据。 1234&gt; db.users.find({status:\"A\"},{name:1,status:1,\"points.bonus\":1}){ \"_id\" : 2, \"name\" : \"bob\", \"status\" : \"A\", \"points\" : [ { \"bonus\" : 20 }, { \"bonus\" : 12 } ] }{ \"_id\" : 3, \"name\" : \"ahn\", \"status\" : \"A\", \"points\" : [ { \"bonus\" : 8 }, { \"bonus\" : 20 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"status\" : \"A\", \"points\" : [ { \"bonus\" : 8 }, { \"bonus\" : 7 } ] } 映射返回数组中特定的数组元素（切片）对于包含数组的字段，MongoDB提供了以下的映射操作符：$elemMatch,$slice,以及$。 示例：返回数组中的最后一个元素 1234&gt; db.users.find({status:\"A\"},{name:1,status:1,\"points\":{$slice:-1}}){ \"_id\" : 2, \"name\" : \"bob\", \"status\" : \"A\", \"points\" : [ { \"points\" : 64, \"bonus\" : 12 } ] }{ \"_id\" : 3, \"name\" : \"ahn\", \"status\" : \"A\", \"points\" : [ { \"points\" : 55, \"bonus\" : 20 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"status\" : \"A\", \"points\" : [ { \"points\" : 57, \"bonus\" : 7 } ] } 示例：返回数组中的第1,2个元素 1234&gt; db.users.find({status:\"A\"},{name:1,status:1,\"points\":{$slice:[0,2]}}){ \"_id\" : 2, \"name\" : \"bob\", \"status\" : \"A\", \"points\" : [ { \"points\" : 85, \"bonus\" : 20 }, { \"points\" : 64, \"bonus\" : 12 } ] }{ \"_id\" : 3, \"name\" : \"ahn\", \"status\" : \"A\", \"points\" : [ { \"points\" : 81, \"bonus\" : 8 }, { \"points\" : 55, \"bonus\" : 20 } ] }{ \"_id\" : 6, \"name\" : \"abc\", \"status\" : \"A\", \"points\" : [ { \"points\" : 78, \"bonus\" : 8 }, { \"points\" : 57, \"bonus\" : 7 } ] } 4、查询值为Null或不存在的字段首先插入数据： 123456db.users.insert( [ { \"_id\" : 900, \"name\" : null }, { \"_id\" : 901 } ]) 相等过滤器使用相等查询，会返回结果为null的或不存在该字段的数据。 123&gt; db.users.find({name:null}){ \"_id\" : 900, \"name\" : null }{ \"_id\" : 901 } 注意： 如果在查询中使用了sparse（稀疏索引），那么查询将仅仅匹配null值，而不匹配不存在的字段。 稀疏索引： 稀疏索引指存储那些有被索引键的文档的索引项，即使被索引键的值是null也会被索引(译者注：请注意，这里对null的处理和那些特殊索引的默认稀疏特性有细微差别，比如文本索引，2d索引等)。索引会跳过所有不包含被索引键的文档。这个索引之所以称为 “稀疏” 是因为它并不包括集合中的所有文档。与之相反，非稀疏的索引会索引每一篇文档，如果一篇文档不含被索引键则为它存储一个null值。 类型筛选在BSON类型中null的值为10，所以可以使用以下方式查询Null： 12&gt; db.users.find({name:{$type:10}}){ \"_id\" : 900, \"name\" : null } 存在性筛选存在性筛选可以筛选出那些不存在该字段的数据，1代表存在，0代表不存在。 12&gt; db.users.find({name:{$exists:0}}){ \"_id\" : 901 } 5、在mongo命令行中迭代游标首先插入数据： 1db.goods.insertMany([{_id:1,type:1},{_id:2,type:2},{_id:3,type:3}]) 手动迭代游标在mongo命令中，当使用var关键字把find()返回的游标赋值给一个变量时，它将不会自动迭代。 在命令行中，可以调用游标变量迭代最多20次并且打印匹配的文档。 123&gt; var myCursor = db.goods.find({type:2})&gt; myCursor{ \"_id\" : 2, \"type\" : 2 } 可以使用游标的next()方法来访问文档： 12345678&gt; var myCursor = db.goods.find( { type: 2 } )&gt; while(myCursor.hasNext){print(tojson(myCursor.next()))}{ \"_id\" : 2, \"type\" : 2 }{ \"_id\" : 4, \"type\" : 2 }{ \"_id\" : 5, \"type\" : 2 }2020-07-09T14:52:14.975+0800 E QUERY [thread1] Error: error hasNext: false :DBQuery.prototype.next@src/mongo/shell/query.js:305:1@(shell):1:38 也可以使用printjson()方法替代print(tojson())： 12345678&gt; var myCursor = db.goods.find( { type: 2 } )&gt; while(myCursor.hasNext){printjson(myCursor.next())}{ \"_id\" : 2, \"type\" : 2 }{ \"_id\" : 4, \"type\" : 2 }{ \"_id\" : 5, \"type\" : 2 }2020-07-09T14:54:01.521+0800 E QUERY [thread1] Error: error hasNext: false :DBQuery.prototype.next@src/mongo/shell/query.js:305:1@(shell):1:35 也可以使用游标方法forEach()来迭代游标并且访问文档。 12345&gt; var myCursor = db.goods.find( { type: 2 } )&gt; myCursor.forEach(printjson){ \"_id\" : 2, \"type\" : 2 }{ \"_id\" : 4, \"type\" : 2 }{ \"_id\" : 5, \"type\" : 2 } 迭代器索引在mongo命令行中，可以使用：method:’~cursor.toArray()’方法来迭代游标，并且以数组的形式来返回文档。 12345678&gt; var myCursor = db.goods.find({type:2})&gt; var documentArray = myCursor.toArray()&gt; var myDocument = documentArray[0]&gt; myDocument{ \"_id\" : 2, \"type\" : 2 }&gt; var myDocument = documentArray[3]&gt; myDocument&gt; Cursor Behaviors（游标行为） 关闭非活动游标 默认情况下，服务器将在限制10分钟后或客户端用尽光标后自动关闭光标。要覆盖此行为时，可以使用cursor.noCursorTimeout()。 1var myCursor = db.users.find().noCursorTimeout(); 当设置了noCursorTimeout之后，必须要使用cursor.close()关闭游标或者耗尽游标的方式关闭游标。 光标隔离 当光标返回文档时，其他操作可能会与查询交错。对于MMAPv1存储引擎来说，对文档进行干预的写操作可能会导致游标返回一个文档（如果该文档已更改）多次。 MMAPv1是MongoDB基于内存映射文件的原始存储引擎。它在大量插入，读取和就地更新的工作负载方面表现出色 从3.2版本开始。MMAPv1不再是默认存储引擎；WiredTige成为默认的存储引擎。 光标批次 MongoDB服务器批量返回查询结果。批处理中的数据量将不超过BSON文档的最大大小。可以使用batchSize()和limit()覆盖默认大小。 3.4新版功能：find(),aggregate(),listIndexes和listCollections类型的操作每批最多返回16兆字节。batchSize()可以强制执行一个较小的限制，但是不能执行较大的限制。 BSON文档最大大小为16MB，嵌套深度级别不超过100 当遍历游标并到达返回批处理的末尾时，如果有更多结果，cursor.next()将执行getMore操作以检索下一个批处理。要查看迭代游标时批处理中剩余多少文档，可以使用objsLeftIntatch()方法。 1234&gt; var myCursor = db.goods.find()&gt; var myFirstDocument = myCursor.hasNext()?myCursor.next():null&gt; myCursor.objsLeftInBatch()5 Cursor Information（光标信息）db.serverStatus()方法返回的文档，其中包括度量字段，该指标字段包含metrics.cursor以下信息字段： 自上次服务器重新启动以来超时的游标数 设置了选项DBQuery.Option.noTimeout的打开游标的数量， 以防止一段时间不活动后发生超时 “固定”打开游标的数量 打开的游标总数 12345678910&gt; db.serverStatus().metrics.cursor{ \"timedOut\" : NumberLong(0), \"open\" : { \"noTimeout\" : NumberLong(0), \"pinned\" : NumberLong(0), \"total\" : NumberLong(0) }}&gt; 三、更新文档1、更新介绍MongoDB中提供了如下的集合更新方式： 方法 描述 db.collection.updateOne（） 即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新一个文档。3.2新版功能。 db.collection.updateMany（） 更新所有通过过滤条件匹配到的文档。3.2新版功能。 db.collection.replaceOne（） 即使可能有多个文档通过过滤条件匹配到，但是也最多也只能替换一个文档。3.2新版功能。 db.collection.update（） 即使可能有多个文档通过过滤条件匹配到，但是也最多也只更新或替换一个文档。默认情况下，db.collection.update（）只更新一个文档。要更新多个文档时，可以使用 multi选项。 语法：db.collection.update(查询表达式，新值，选项) 注意：使用下面语句时，不是更新数据，而是更新文档。更新就是用新文档替换旧文档。 更新方法需要接收以下参数： 过滤条件：决定更新哪些文档。使用查询表达是过滤内容。 更新文档——指定要执行的修改或者替换文档——完全替换匹配文档（除了_id字段） 选项 2、行为表现1、原子性MongoDB中所有的写操作在单一文档层级上是原子的。 2、_id字段一旦设定，不能更新_id字段的值，也不能用有不同_id字段值得替换文档来替换已经存在的文档。 3、文档大小当执行更新操作增加的文档大小超过了为该文档分配的内存空间时，更新操作会在磁盘上重定位该文档。 4、字段顺序MongoDB按照文档写入的顺序整理文档字段，除了以下情况： _id字段始终是文档的第一个字段 包括字段名称的renaming操作可能导致文档中的字段重新排序。 在2.6版开始，MongoDB主动尝试保持字段在文档中的顺序。2.6版本之前，MongoDB不会主动保持文档中的字段的顺序。 5、upsert选项如果 db.collection.update()，db.collection.updateOne()， db.collection.updateMany()或者 db.collection.replaceOne()包含 upsert : true 并且 没有文档匹配指定的过滤器，那么此操作会创建一个新文档并插入它。如果有匹配的文档，那么此操作修改或替换匹配的单个或多个文档。 3、更新操作首先插入数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687db.users.insertMany( [ { _id: 1, name: \"sue\", age: 19, type: 1, status: \"P\", favorites: { artist: \"Picasso\", food: \"pizza\" }, finished: [ 17, 3 ], badges: [ \"blue\", \"black\" ], points: [ { points: 85, bonus: 20 }, { points: 85, bonus: 10 } ] }, { _id: 2, name: \"bob\", age: 42, type: 1, status: \"A\", favorites: { artist: \"Miro\", food: \"meringue\" }, finished: [ 11, 25 ], badges: [ \"green\" ], points: [ { points: 85, bonus: 20 }, { points: 64, bonus: 12 } ] }, { _id: 3, name: \"ahn\", age: 22, type: 2, status: \"A\", favorites: { artist: \"Cassatt\", food: \"cake\" }, finished: [ 6 ], badges: [ \"blue\", \"Picasso\" ], points: [ { points: 81, bonus: 8 }, { points: 55, bonus: 20 } ] }, { _id: 4, name: \"xi\", age: 34, type: 2, status: \"D\", favorites: { artist: \"Chagall\", food: \"chocolate\" }, finished: [ 5, 11 ], badges: [ \"Picasso\", \"black\" ], points: [ { points: 53, bonus: 15 }, { points: 51, bonus: 15 } ] }, { _id: 5, name: \"xyz\", age: 23, type: 2, status: \"D\", favorites: { artist: \"Noguchi\", food: \"nougat\" }, finished: [ 14, 6 ], badges: [ \"orange\" ], points: [ { points: 71, bonus: 20 } ] }, { _id: 6, name: \"abc\", age: 43, type: 1, status: \"A\", favorites: { food: \"pizza\", artist: \"Picasso\" }, finished: [ 18, 12 ], badges: [ \"black\", \"blue\" ], points: [ { points: 78, bonus: 8 }, { points: 57, bonus: 7 } ] } ]) 1、$set——修改指定字段update只能更新查询到的第一个数据。 使用 $set 操作符更新 favorites.food 字段的值为 \"pie\" 并更新 type 字段的值为 3, 使用 $currentDate 操作符更新 lastModified 字段的值到当前日期。如果 lastModified 字段不存在， $currentDate 会创建该字段。 12&gt; db.users.updateOne({\"favorates.artist\":\"Picasso\"},{$set:{\"favorites.food\":\"pie\",type:3},$currentDate:{lastModified:true}}){ \"acknowledged\" : true, \"matchedCount\" : 0, \"modifiedCount\" : 0 } 2、$unset——删除某个列1db.collection.update({name:'lisi'},{$unset:{age:30}}) 3、$rename——重命名某个列1db.collection.update({name:'wangwu'},{$rename:{'age':'max-age'}}) 4、$inc——增加某个列1db.collection.update({name:'hahaha'},{$inc:{age:20}}) 5、选项:{upsert:true/false,multi:true/false}upsert:true/false:默认为false，为true时，不存在则插入，如果存在就更新。 multi:true/false默认为false，为true时，会更新匹配到的所有数据。 四、删除文档1、删除的方法 方法 描述 db.collection.remove() 删除所有符合条件的数据，不写条件时删除所有 db.collection.deleteOne() 最多删除一个符合条件的文档。3.2 新版功能. db.collection.deleteMany() 删除所有匹配指定过滤条件的文档.3.2 新版功能. 注意： 1.查询表达式依然是个json对象{age:20} 2.查询表达式匹配的行，将被删除。 3.如果不写查询表达式，collection中的所有文档将被删除。 2、删除的行为表现1、索引即使把文档中的所有数据都删除了，索引也不会被删除。 2、原子性MongoDB所有写操作在单一文档层级上是原子的。如果想要删除集合中的所有数据，可以直接删除集合，然后重新集合和索引，这种方式更为高效。 3、删除操作db.collection.remove(查询表达式) {justOne:true/false},是否只删除一行，默认为false。 删除stu表中sn属性值为’001’的文档 1db.stu.remove({sn:'001'}) 删除stu表中gender属性为m的文档，只删除1行 1db.stu.remove({gender:'m',true}) 删除第一个status 字段等于 \"A\" 的文档 1db.users.remove( { status: \"D\" }, 1) .查询表达式依然是个json对象{age:20} 2.查询表达式匹配的行，将被删除。 3.如果不写查询表达式，collection中的所有文档将被删除。 2、删除的行为表现1、索引即使把文档中的所有数据都删除了，索引也不会被删除。 2、原子性MongoDB所有写操作在单一文档层级上是原子的。如果想要删除集合中的所有数据，可以直接删除集合，然后重新集合和索引，这种方式更为高效。 3、删除操作db.collection.remove(查询表达式) {justOne:true/false},是否只删除一行，默认为false。 删除stu表中sn属性值为’001’的文档 1db.stu.remove({sn:'001'}) 删除stu表中gender属性为m的文档，只删除1行 1db.stu.remove({gender:'m',true}) 删除第一个status 字段等于 \"A\" 的文档 1db.users.remove( { status: \"D\" }, 1)","categories":[],"tags":[]},{"title":"聚合操作","slug":"TreasureBox/数据库/MongoDB/3.聚合操作","date":"2022-05-19T01:14:40.403Z","updated":"2023-04-28T09:25:47.191Z","comments":true,"path":"2022/05/19/treasurebox/shu-ju-ku/mongodb/3.ju-he-cao-zuo/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/shu-ju-ku/mongodb/3.ju-he-cao-zuo/","excerpt":"","text":"聚合操作[TOC] 聚合操作处理数据记录并返回计算结果。聚合操作将来自多个文档的值分组在一起，并且可以对分组的数据执行各种操作以返回单个结果。MongoDB提供了三种执行聚合的方法：聚合管道，map-reduce函数和单一目的聚合方法。 一、集合管道1、管道介绍聚合管道是一个基于数据处理管道概念建模的数据聚合框架。文档进入多阶段管道，一个管道处理完毕后交给下一个管道，该管道将文档转换为汇总结果。 语法：db.collection_name.aggregate([{管道1},{管道2},{管道3},…]) 常用的管道操作 $project 修改输入文档的结构。可以用来重命名、增加或修改域，也可以用于创建计算结果以及嵌套文档。 $match 用于过滤数据，只输出符合条件的文档。使用MongoDB的标准查询操作。 $limit 用来限制MongoDB聚合管道返回的文档数 $skip 在聚合管道中跳过指定数量的文档，并返回余下的文档 $group 将集合中的文档分组，可用于统计结果 $sort 将输入文档排序后输出。 group中的操作表达式 表达式 描述 $sum 计算总和 $avg 计算平均值 $min 获取集合中所有文档对应值的最小值 $max 获取集合中所有文档对应值得最大值 $first 根据资源文档的排序获取第一个文档数据 $last 根据资源文档的排序获取最后一个文档数据 练习： 1.查询每个年龄段的人员数量： 1db.school.aggregate([{$group:{_id:\"$age\",total:{$sum:1}}}]) 2.查询总共有多少人 1db.school.aggregate([{$group:{_id:null,total:{$sum:1}}}]) 3.分组查询并获取另外某个字段的值 12345678&gt; db.c1.find(){ \"_id\" : ObjectId(\"6054963d74d2f8be32f5b168\"), \"f1\" : 1, \"f2\" : \"2\" }{ \"_id\" : ObjectId(\"6054964174d2f8be32f5b169\"), \"f1\" : 1, \"f2\" : \"3\" }{ \"_id\" : ObjectId(\"6054964674d2f8be32f5b16a\"), \"f1\" : 1, \"f2\" : \"4\" }{ \"_id\" : ObjectId(\"6054964a74d2f8be32f5b16b\"), \"f1\" : 2, \"f2\" : \"3\" }{ \"_id\" : ObjectId(\"6054965174d2f8be32f5b16c\"), \"f1\" : 2, \"f2\" : \"4\" }&gt; db.c1.aggregate({$match:{\"f1\":{\"$in\":[1]}}},{$group:{\"_id\":\"$f1\",\"f2\":{\"$push\":\"$f2\"}}}){ \"_id\" : 1, \"f2\" : [ \"2\", \"3\", \"4\" ] } 2、管道优化 $sort+ $match顺序优化 如果管道中,sort后面跟着match，可以先使用match进行筛选，这样会减少之后排序的对象。 $skip+$match顺序优化 如果你的管道中，skip后面跟着limit，优化器会把limit移到skip前面，这个时候limit的会值加上skip的个数。 $redact+$match顺序优化 $ project + $ skip或 $ limit序列优化 $ sort + $ limit合并 $ limit + $ limit合并 $ skip + $ skip合并 $ match + $ match合并 $ lookup + $ unwind合并 $ sort + $ skip + $ limit顺序 $ limit + $ skip + $ limit + $ skip顺序 二、映射化简1、映射化简的JavaScript方法在MongoDB中，map-reduce操作使用自定义javaScript函数将值映射或关联到键。如果一个键具有映射到它的多个值，则该操作会将键的值减少到单个对象。 例如，当处理一个文档的时候，映射函数可以映射多个键值对或者一个也不映射。映射化简还可以在结束的时候使用JavaScript对聚合结果做最后的修改，例如附加的计算。 2、映射化简的特点在MongoDB中，map-reduce操作可以将结果写入集合或内联返回结果。如果将map-reduce输出写入集合，则可以在同一输入集合上执行随后的map-reduce操作，这些操作将替换结果，合并结果或归约结果与先前结果合并。 如果选择映射化简操作的即时返回结果，这些文档一定要在BSON文档大小限制以内，当前这个限制是16MB。 MongoDB支持对分片集合进行 map-reduce操作。Map-reduce操作还可以将结果输出到分片集合。 三、单一目的聚合方法MongoDB还提供db.collection.count（）和 db.collection.distinct（）。 所有这些操作都汇总了单个集合中的文档。尽管这些操作提供了对常见聚合过程的简单访问，但是它们缺乏聚合管道和映射减少的灵活性和功能。 1234567891011&gt; db.goods.find(){ \"_id\" : 1, \"type\" : 1 }{ \"_id\" : 2, \"type\" : 2 }{ \"_id\" : 3, \"type\" : 3 }{ \"_id\" : 4, \"type\" : 2 }{ \"_id\" : 5, \"type\" : 2 }{ \"_id\" : 6, \"type\" : 3 }&gt; db.goods.distinct(\"type\")[ 1, 2, 3 ]&gt; db.goods.count()6 “_id” : 6, “type” : 3 } db.goods.distinct(“type”)[ 1, 2, 3 ]db.goods.count()6","categories":[],"tags":[]},{"title":"快捷键","slug":"TreasureBox/快捷键","date":"2022-05-19T01:14:40.402Z","updated":"2023-04-28T09:25:47.098Z","comments":true,"path":"2022/05/19/treasurebox/kuai-jie-jian/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/kuai-jie-jian/","excerpt":"","text":"无序列表：输入-之后输入空格有序列表：输入数字+“.”之后输入空格任务列表：-[空格]空格 文字标题：ctrl+数字表格：ctrl+t生成目录：[TOC]按回车选中一整行：ctrl+l选中单词：ctrl+d选中相同格式的文字：ctrl+e跳转到文章开头：ctrl+home跳转到文章结尾：ctrl+end搜索：ctrl+f替换：ctrl+h引用：输入&gt;之后输入空格代码块：ctrl+alt+f加粗：ctrl+b倾斜：ctrl+i下划线：ctrl+u删除线：alt+shift+5插入图片：直接拖动到指定位置即可或者ctrl+shift+i插入链接：ctrl+k","categories":[],"tags":[]},{"title":"插值","slug":"TreasureBox/vue/2.模板语法/1.插值","date":"2022-05-19T01:14:40.401Z","updated":"2023-04-28T09:25:47.184Z","comments":true,"path":"2022/05/19/treasurebox/vue/2.mo-ban-yu-fa/1.cha-zhi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/vue/2.mo-ban-yu-fa/1.cha-zhi/","excerpt":"","text":"模板语法一、插值 文本 数据绑定的最基本形式是使用”Mustache”语法（双花括号）的文本插值，例： 1&lt;span&gt;Message: {{ msg }}&lt;/span&gt; 每当数据对象的msg属性更改时，该数据也会被更新，可以使用v-once指令执行一次性插值，该插值不会随着数据更改而更新，但是也会影响同一节点上其他的绑定。 1234&lt;div id=\"app\"&gt; &lt;span v-once&gt;Message:{{ msg }}&lt;/span&gt; &lt;span&gt;{{ msg }}&lt;/span&gt;&lt;/div&gt; 123456789&lt;script&gt; var vm =new Vue({ el:\"#app\", data:{ msg:'hello world!', } }); vm.msg='hello';&lt;/script&gt; 原始HTML 属性 使用JavaScript使用JavaScript","categories":[],"tags":[]},{"title":"索引效率测试","slug":"TreasureBox/utils/2.索引效率测试","date":"2022-05-19T01:14:40.400Z","updated":"2023-04-28T09:25:47.217Z","comments":true,"path":"2022/05/19/treasurebox/utils/2.suo-yin-xiao-lu-ce-shi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/utils/2.suo-yin-xiao-lu-ce-shi/","excerpt":"","text":"MySQL索引效率测试一、以mysql添加索引和不添加索引为例，测试数据的插入速度和查询速度。1、首先创建数据表和数据库，在cmd命令行中执行：1234create database TestDataSpeed charset=utf8;use testdataspeed;create table DataNoIndex(id int,name char(10),age int,address char(20),gender char(1)); #创建不带索引的数据表create table DataNoIndex(id int primary key autoincrement,name char(10),age int,address char(20),gender char(1)); # 创建带主键索引的数据表 2、创建完数据库之后，使用pymysql操作分别插入1000万条数据：首先分别向无索引和有索引的表中插入数据，在无索引的表中插入1000万条数据共耗时1134秒，在有索引的表中插入共耗时1138秒，插入数据时耗用时间相差不大。： 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-import pymysqlimport timefrom functools import wrapsimport randomimport tracebackdef timer(func): @wraps(func) def inner(*args): start_time = time.time() func(*args) end_time = time.time() print(end_time-start_time) return inner@timerdef insert_no_index(*args): try: db = pymysql.connect(user=user,password=password,database=\"testdataspeed\") cursor = db.cursor() for i in range(1,10*1000*1000): age = random.randint(10,25) gender = random.choice([\"男\",\"女\"]) address = random.choice([\"北京\",\"上海\",\"广州\",\"杭州\",\"深圳\",\"成都\",\"重庆\"]) sql = \"INSERT INTO DATANOINDEX VALUE('{}','{}','{}','{}','{}');\".format(i,\"小明\"+str(i),age,address,gender) # print(sql) cursor.execute(sql) db.commit() db.close() except: print(traceback.format_exc())if __name__ == '__main__': user = \"root\" password = \"root\" insert_no_index(user,password) 3、比较查询速度 比较查询所有数据的速度无索引情况： 1234567mysql&gt; select count(gender) from datanoindex;+---------------+| count(gender) |+---------------+| 9999999 |+---------------+1 row in set (7.67 sec) 有索引情况： 1234567mysql&gt; select count(gender) from dataindex;+---------------+| count(gender) |+---------------+| 9999999 |+---------------+1 row in set (6.42 sec) 比较使用where查询主键条件的速度无索引情况： 1234567mysql&gt; select * from datanoindex where id=1000;+------+----------+------+---------+--------+| id | name | age | address | gender |+------+----------+------+---------+--------+| 1000 | 小明1000 | 25 | 广州 | 男 |+------+----------+------+---------+--------+1 row in set (8.10 sec) 有索引情况： 1234567mysql&gt; select * from dataindex where id=1000;+------+----------+------+---------+--------+| id | name | age | address | gender |+------+----------+------+---------+--------+| 1000 | 小明1000 | 22 | 北京 | 男 |+------+----------+------+---------+--------+1 row in set (0.00 sec) 可以看到，在添加索引之后，使用主键进行查询时，速度得到了显著提升。 比较使用非索引键查询的速度无索引的情况： 1234567mysql&gt; select * from datanoindex where name=\"小明1000\";+------+----------+------+---------+--------+| id | name | age | address | gender |+------+----------+------+---------+--------+| 1000 | 小明1000 | 25 | 广州 | 男 |+------+----------+------+---------+--------+1 row in set (8.95 sec) 有索引情况： 1234567mysql&gt; select * from dataindex where name=\"小明1000\";+------+----------+------+---------+--------+| id | name | age | address | gender |+------+----------+------+---------+--------+| 1000 | 小明1000 | 22 | 北京 | 男 |+------+----------+------+---------+--------+1 row in set (7.15 sec) 可以看到，在有索引的表中，即使不使用索引的字段进行查询，查询速度依然优于无索引的表，只是效率提升相对较少。 向有1000万数据的表中添加主键索引向无索引的表中添加主键索引，测试需要花费的时间。 123mysql&gt; alter table datanoindex add primary key(id);Query OK, 0 rows affected (2 min 45.44 sec)Records: 0 Duplicates: 0 Warnings: 0 大约两分钟45秒可以把索引建立完成。此时再使用主键进行查询： 1234567mysql&gt; select * from datanoindex where id=100000;+--------+------------+------+---------+--------+| id | name | age | address | gender |+--------+------------+------+---------+--------+| 100000 | 小明100000 | 19 | 成都 | 女 |+--------+------------+------+---------+--------+1 row in set (0.10 sec) 查询速度有了显著的提升，这就是索引的优点，当数据越大时，提升的效果越明显。 查询速度有了显著的提升，这就是索引的优点，当数据越大时，提升的效果越明显。","categories":[],"tags":[]},{"title":"利用蒙特卡洛计算π","slug":"TreasureBox/utils/3.利用蒙特卡洛计算π","date":"2022-05-19T01:14:40.400Z","updated":"2023-04-28T09:25:47.217Z","comments":true,"path":"2022/05/19/treasurebox/utils/3.li-yong-meng-te-qia-luo-ji-suan-p/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/utils/3.li-yong-meng-te-qia-luo-ji-suan-p/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839from graphics import *#利用蒙特卡洛方法计算PI值from random import randomfrom math import sqrtimport timewin = GraphWin(\"Celsius Converter\", 400, 300)#载入界面，标题栏win.setCoords(0.0, 0.0, 3.0, 4.0)#按比例转换坐标# 绘制接口Text(Point(1,3), \" Celsius Temperature:\").draw(win)#输入文字Text(Point(1,1), \"Fahrenheit Temperature:\").draw(win)input= Entry(Point(2,3),5)#前面是位置，后面是宽度,可以写数字input.setText(\"0.0\")input.draw(win)output = Text(Point(2,1),\"\")#确定输出位置output.draw(win)button = Text(Point(1.5,2.0),\"Convert It\")#按钮字样button.draw(win)Rectangle(Point(1,1.5), Point(2,2.5)).draw(win)#长方形# 等待鼠标点击win.getMouse()# 转换输入DARTS = eval(input.getText())#得到你的输入值，getText()# DARTS = 2**26 #这个时候已经比较精确了，耗时也将近1分钟了。修改DARTS可以进一步提高计算精度。hits=0start_time = time.time()for i in range(1,int(DARTS)): x,y =random(),random() dist = sqrt(x**2+y**2) if dist &lt;=1.0: hits =hits+1pi = 4*(hits/DARTS)print(\"PI的值是%s\"%pi)print(\"程序运行的时间是%-5.5ss\"%(time.time()-start_time))# 显示输出，改变按钮output.setText(pi) #输出pibutton.setText(\"Quit\")# 等待响应鼠标点击，退出程序win.getMouse()win.close()","categories":[],"tags":[]},{"title":"初识vue","slug":"TreasureBox/vue/1.初识Vue/1.初识vue","date":"2022-05-19T01:14:40.400Z","updated":"2023-04-28T09:25:47.180Z","comments":true,"path":"2022/05/19/treasurebox/vue/1.chu-shi-vue/1.chu-shi-vue/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/vue/1.chu-shi-vue/1.chu-shi-vue/","excerpt":"","text":"初识Vue一、介绍Vue是用于构建用户界面的渐进框架。是从头设计的，可以逐步采用，并且可以根据不同的用例轻松地在库和框架之间扩展。它包含一个仅着眼于视图层的可访问的核心库，以及一个支持库的生态系统，可帮助解决大型单页应用中的复杂性。 浏览器兼容性：vue.js支持所有符合ES5的浏览器（不支持IE8及以下版本）。 github链接：https://github.com/vuejs/vue 使用在html文件中引入： 第一个vue示例： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue-Test&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; {{ foo }} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:'#app', //绑定id data:{ foo:'hello World' } }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 1574227453301.png”&gt;","categories":[],"tags":[]},{"title":"创建vue实例","slug":"TreasureBox/vue/1.初识Vue/2.创建vue实例","date":"2022-05-19T01:14:40.400Z","updated":"2023-04-28T09:25:47.182Z","comments":true,"path":"2022/05/19/treasurebox/vue/1.chu-shi-vue/2.chuang-jian-vue-shi-li/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/vue/1.chu-shi-vue/2.chuang-jian-vue-shi-li/","excerpt":"","text":"创建Vue实例每个Vue应用程序都通过使用以下功能创建一个新的Vue实例： 12345&lt;script&gt; var vm = new Vue({// options})&lt;/script&gt; j经常会使用vm（ViewModel）来引用Vue实例 数据与方法1、创建Vue实例后，它将在其data对象中找到所有属性添加到Vue的反应系统中。当这些属性的值更改时，视图中的数据也会发生改变。 123456789&lt;script&gt; var data = { a : 1 }; var vm = new Vue({ data:data }); console.log(vm.a == data.a); vm.a = 2; console.log(vm.a,data.a); // 修改属性时原来的值会相应修改 &lt;/script&gt; 使用Object.freeze()时，可以防止更改现有的属性 html文件： 12345&lt;div id=\"example\"&gt; {{ a }} &lt;button v-on:click=\"a=2\"&gt;change it&lt;/button&gt;&lt;/div&gt; 12345678&lt;script&gt;var obj = { foo:\"bar\"};Object.freeze(obj); //加上这个属性之后，vue绑定的数据不能做反向修改new Vue({ el:'#app', data:obj,});&lt;/script&gt; 视图数据更新只针对已经存在的数据，如果添加新的属性时，不会触发视图更新如： 1vm.b = 'hi' 2、Vue实例还有许多其他有用的实例属性和方法。这些以$为前缀，以区别用户定义的属性。 12345678910111213var data = {a :1};var vm = new Vue({ el:\"#example\", data:data});console.log(vm.$data === data); //trueconsole.log(vm.$el === document.getElementById('example')); //truevm.$watch('a',function (newValue,oldValue) { //当vm.a发生改变时会触发该方法 console.log(vm.a,111111111); //打印新、旧数值 console.log(newValue,oldValue)}); 实例生命周期挂钩每个Vue实例在创建时都会经历一系列初始化步骤-例如，它需要设置数据观察，编译模板，将实例安装到DOM以及在数据更改时更新DOM。在此过程中，它还运行称为生命周期挂钩的函数，使用户有机会在特定阶段添加自己的代码。 例如，created钩子可用于在创建实例后运行代码： 12345678910new Vue({data: { a: 1},created: function () {// this代表vm本身console.log('a is: ' + this.a)}})// =&gt; \"a is: 1\" 还有其他钩子，将在实例的生命周期的不同阶段被调用，如mounted，updated和destroyed。调用的所有生命周期挂钩，其this上下文都指向调用它的Vue实例 生命周期图�Vue实例 生命周期图","categories":[],"tags":[]},{"title":"python调用java的jar包","slug":"TreasureBox/utils/1.python调用java的jar包","date":"2022-05-19T01:14:40.399Z","updated":"2023-04-28T09:25:47.219Z","comments":true,"path":"2022/05/19/treasurebox/utils/1.python-diao-yong-java-de-jar-bao/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/utils/1.python-diao-yong-java-de-jar-bao/","excerpt":"","text":"在python中调用jar包最近的项目功能需要调用客户的java接口，在调用接口的时候需要使用配套的jar包生成一些参数，但是公司的项目是用django搭建的，经过无数血与泪的尝试，最终终于找到了合适的方法去调用….. jpype包是一个Python的包，可以在python项目中调用java的jar包，并获取最终的返回值。使用方法很简单，但是安装的过程比较复杂。本文在ubuntu18.0.4系统，以python2以及jdk8为基础，讲解jpype包的使用。 1、安装java首先去官网下载jdk1.8的tar包，放在/opt路径下，然后进行安装： tar -zxvf jdk-8u261-linux-x64.tar.gz 安装完jdk之后，需要配置环境变量，在/etc/profile文件中添加以下内容： 123456set java environmentJAVA_HOME=/opt/java/jdk1.8.0_261 JRE_HOME=/opt/java/jdk1.8.0_261/jre CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH 重启环境变量：source /etc/profile 2、安装python的jpype包找到项目依赖的python环境： 1sudo find / -name site-packages 将下载的jpype包放在site-packages路径下。 3、使用示例jpype中主要包含以下方法： 12345jpype.getDefalutJVMPath() # 获取jvm所在的路径jpype.startJVM() # 开启虚拟机demo = jpype.JClass('hello.Demo') # 加载jar包中的Demo文件demo.sayHello() # 调用 sayHello 方法jpype.shutdownJVM() # 关闭虚拟机 代码示例： 1234567def run_jar(): jvm_path = \"/opt/java/jdk1.8.0_261/jre/lib/amd64/server/libjvm.so\" jar_path = os.path.join(os.path.abspath(\".\"), \"/home/youzi/ssojar/Hello.jar\") jpype.startJVM(jvm_path, \"-Djava.class.path=%s\" % jar_path) # 启动虚拟机 demo = jpype.JClass('Demo') # 加载Demo类 demo.sayHello() # 调用sayHello方法 jpype.shutdownJVM() # 关闭虚拟机 ��拟机","categories":[],"tags":[]},{"title":"4、pandas使用","slug":"TreasureBox/python/数据分析/week1/4、pandas使用","date":"2022-05-19T01:14:40.399Z","updated":"2023-04-28T09:25:47.119Z","comments":true,"path":"2022/05/19/treasurebox/python/shu-ju-fen-xi/week1/4-pandas-shi-yong/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/shu-ju-fen-xi/week1/4-pandas-shi-yong/","excerpt":"","text":"pandas使用一、pandas简介pandas是一种建立在python基础上的快速，强大，灵活并且易于使用的开源数据分析和处理工具。是基于numpy实现的，具有存储表格数据、统计分析、数据清洗功能。 主要有两种数据结构：DataFrame和Series。 二、pandas使用 两种数据结构的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import pandas as pdimport numpy as np# 用来存储数据 ---两种结构# DataFrame ---具有行索引、列索引的表格数据# ---可以存储不同的数据类型# 创建df --列表嵌套data = [['zs', 19, 1], ['ls', 18, 2], ['ww', 20, 1], ['zl', 19, 2]]print('data:\\n', data)print('data的类型：\\n', type(data))# 将data 转化dfdf = pd.DataFrame(data=data, # 数据， index=['stu0', 'stu1', 'stu2', 'stu3'], # 行名称、行索引 columns=['name', 'age', 'group'], # 列索引、列名称 )print('df:\\n', df)print('df的类型：\\n', type(df)) # &lt;class 'pandas.core.frame.DataFrame'&gt;# 创建df ---使用大字典df = pd.DataFrame( data={ 'name': ['zs', 'ls', 'ww', 'zl'], 'age': [19, 18, 20, 19], 'group': [1, 2, 1, 2] }, index=['stu0', 'stu1', 'stu2', 'stu3'] # 行索引)print('df:\\n', df)print('df的类型：\\n', type(df))# 将ndarray数组转化为df# 先加载ndarrayres = np.load('./国民经济核算季度数据.npz')# 获取数组columns = res['columns']values = res['values']print('columns:\\n', columns)print('values:\\n', values)# 构建行索引名称index = ['index_' + str(tmp) for tmp in range(values.shape[0])]# 将columns 与 values 结合起来df = pd.DataFrame(data=values, columns=columns, index=index)print('df:\\n',df)print('df的类型：\\n',type(df))# Series ----只有行索引、数据的表格结构# ----数据的类型都是一致# 创建series --由简单列表、一维数组转化为seriesse = pd.Series(data=np.array(['zs', 'ls', 'ww', 'zl']), # 数据 index=['stu0', 'stu1', 'stu2', 'stu3']) # 行索引print('se:\\n', se)print('se的类型：\\n', type(se)) # &lt;class 'pandas.core.series.Series'&gt;# 创建series --通过映射关系来创建series，并按照index进行排序# 基础班 ---字典是无序(仅限于Python3.7版本之前)scores = {'zs': 90, 'ls': 80, 'ww': 60, 'zl': 48}index = ['zs', 'zl', 'ww', 'ls', 'kk']se = pd.Series(data=scores, index=index # 行名称，指定排序规则 )print('se:\\n', se)print('se的类型：\\n', type(se))# 从df中获取一列数据 ---series ---特殊的df(一列的且无列名称的特殊的df)se = df['name']print('se:\\n', se)print('se的类型：\\n', type(se)) dataframe和series属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import pandas as pd# 创建一个dataframedf = pd.DataFrame( data={ 'name': ['zs', 'ls', 'ww', 'zl'], 'age': [18, 19, 20, 18], 'group': [1, 2, 2, 1] }, index=['stu0', 'stu1', 'stu2', 'stu3'])print('df:\\n', df)print('df的类型：\\n', type(df))print('*' * 100)\"\"\" dataframe属性 values index columns dtypes size ndim shape df中的数据元素 可以将df 通过df.values转化为ndarray pd.DataFrame将ndarray转化为df\"\"\"print('df的values:\\n', df.values)print('df的values的类型：\\n', type(df.values)) # &lt;class 'numpy.ndarray'&gt;print('df的index :\\n', df.index) # 行索引print('df的columns:\\n', df.columns) # 列索引# df可以存储不同类型的数据print('df的dtypes:\\n', df.dtypes) # df中每一列的数据类型\"\"\"df的dtypes: age int64group int64name objectdtype: object\"\"\"print('df的size：\\n', df.size) # 元素个数print('df的ndim:\\n', df.ndim) # 维数----&gt;2维print('df的shape:\\n', df.shape) # 形状 (行，列)\"\"\"series属性\"\"\"se = df['age']print('se：\\n', se)print('se的类型：\\n', type(se))print('*' * 100)\"\"\" 相比于dataframe ---&gt;没有columns属性 values index dtypes/dtype ndim shape size itemsize se中的数据元素 pd.Series可以将一维数组转化series 也可以通过se.values将Series转化为ndarray\"\"\"print('se的values:\\n', se.values)print('se的values的类型:\\n', type(se.values)) # &lt;class 'numpy.ndarray'&gt;print('se的index:\\n', se.index) # 行索引print('se的dtypes:\\n', se.dtypes) # 元素类型print('se的dtype:\\n', se.dtype) # 元素类型print('se的ndim:\\n', se.ndim) # 维度---&gt;1维print('se的shape：\\n', se.shape) # 形状 # (4,) ---&gt;只有一个维度---&gt;行维度print('se的size:\\n', se.size) # 元素个数print('se的itemsize:\\n', se.itemsize) # 每一个元素的占位大小 读写文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import pandas as pd\"\"\" 常用的文件excel文件、csv文件、html文件、json文件.... 1、pandas读取文件 pandas里面读取文件格式：pd.read_xxx格式 pd.read_csv() pd.read_table() csv文件 ---特殊的以逗号分隔的、文本的序列文件\"\"\"# 读取csv文件info = pd.read_csv(filepath_or_buffer='./meal_order_info.csv', # 文件路径+名称 encoding='ansi', # 编码方式 # delimiter=',', # 分隔符 # sep=',' # 分隔符 # header='infer', # 读取的文件的时候，列索引自动识别，也可以显式指定 # header=0, # 显式指定第n行为 列索引 # names=['列1', '列2'], # 可以自定义列索引名称 # usecols=[0, 1] # 可以指定读取的列下标 # index_col=0, # 指定特定的列作为行索引名称 # nrows=10, # 可以指定读取前n行 )# 参数参考read_csv理解,和read_csv的区别在于：没有默认的分隔符# info = pd.read_table('./meal_order_info.csv', sep=',', encoding='ansi')print('info:\\n', info)print('info 的类型:\\n', type(info)) # &lt;class 'pandas.core.frame.DataFrame'&gt;# excel文件 ---以.xlsx .xls为结尾的表格数据文件detail = pd.read_excel(io='./meal_order_detail.xlsx', # 文件路径 + 名称 sheetname=None, # 读取表格下标 # header=0, # 以表格的第0行为列索引 # # index_col=0 ,# 可以指定特定列为行索引 # parse_cols=[0, 1], # 读取指定的列 )print('detail:\\n', detail) # ---&gt;OrderedDict# 可以通过print(detail.keys()) # odict_keys(['meal_order_detail1', 'meal_order_detail2', 'meal_order_detail3'])print('*' * 100)# 获取不同的sheetdetail_1 = detail['meal_order_detail1']detail_2 = detail['meal_order_detail2']detail_3 = detail['meal_order_detail3']print('detail_1:\\n', detail_1)\"\"\" 2、pandas保存文件 pandas保存文件的格式：df.to_xxx格式 csv文件保存\"\"\"info.to_csv(path_or_buf='./aaa.csv', # 保存的路径+名称 sep=',', # 分隔符 header=True, # 需要保存列索引,如果不需要保存列索引---&gt;header=False index=True, # 需要保存行索引，如果不需要保存行索引----&gt;index=False # columns=['info_id','emp_id'] # 指定需要保存的列 mode='a', # 没保存一次，之前的内容都会被覆盖掉，如果想要追加保存---&gt;mode='a' )# excel文件保存# 一次只能保存一个sheetdetail_1.to_excel(excel_writer='./bbb.xlsx', # 具体的路径+ 名称 或者ExcelWriter对象 sheet_name='Sheet1', # 默认保存的表格的名称 header=True, # 保存列索引，如果不保存--header=False index=True, # 保存行索引，如果不保存，---index=False # startrow=20, # 保存的文件里面跳过指定行继续保存 # startcol=5, # 保存的文件里面跳过指定列继续保存 )detail_2.to_excel(excel_writer='./bbb.xlsx', # 具体的路径+ 名称 或者ExcelWriter对象 sheet_name='Sheet2', # 默认保存的表格的名称 header=True, # 保存列索引，如果不保存--header=False index=True, # 保存行索引，如果不保存，---index=False # startrow=20, # 保存的文件里面跳过指定行继续保存 # startcol=5, # 保存的文件里面跳过指定列继续保存 )# 如果按照上面的方式进行保存----&gt;每保存一次，覆盖一次# 将多个df分别保存到相同文件的不同sheet中去# 可以借助 ExcelWriter 来进行保存# 创建ExcelWriter对象writer = pd.ExcelWriter('./ccc.xlsx')\"\"\" 将不同df 保存到不同sheet中 写入数据\"\"\"detail_1.to_excel(excel_writer=writer, sheet_name='sheet1')detail_2.to_excel(excel_writer=writer, sheet_name='sheet2')detail_3.to_excel(excel_writer=writer, sheet_name='sheet3')# # 保存修改writer.save()# # 关闭ExcelWriter对象writer.close() dataframe的查询操作 查询操作主要根据列索引和切片获取数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import pandas as pd# 加载detail数据# 默认加载第0个sheetdetail = pd.read_excel('./meal_order_detail.xlsx')# 修改一下行索引index = ['index_' + str(tmp) for tmp in detail.index]detail.index = indexprint('detail:\\n', detail)print('detail的列索引：\\n', detail.columns)print('*' * 100)# df索引方式---&gt;先列后行(直接索引方式)# ndarray索引---arr[行,列] ---同时索引# 获取 dishes_name 这一列数据 --列名 --Seriesprint('获取单列数据：\\n', detail['dishes_name'])# 获取 dishes_name dishes_id amounts counts 这四列数据 --列名列表 --dataframeprint('获取多列数据：\\n', detail[['dishes_name', 'dishes_id', 'amounts', 'counts']])\"\"\"获取单列数据指定行----&gt;行下标列表、行名称列表、行下标切片、行名称切片 ----&gt;head(获取前n行) ----&gt;tail(获取后n行)\"\"\"# 获取 dishes_name 这一列 数据 的前n行 ---行下标切片print('获取单列数据：\\n', detail['dishes_name'][:5])# # 获取 dishes_name 这一列 数据 的前n行 ---行名称切片 ---包含结束位置print('获取单列数据：\\n', detail['dishes_name'][:'index_4'])# 获取 dishes_name 这一列 数据 的前n行 ---行下标列表print('获取单列数据：\\n', detail['dishes_name'][[0, 1, 2, 3, 4]])# 获取 dishes_name 这一列 数据 的前n行 ---行名称列表print('获取单列数据：\\n', detail['dishes_name'][['index_0', 'index_1', 'index_2', 'index_3', 'index_4']])# # 获取 dishes_name 这一列 数据 的前n行 ---head()print('获取单列数据：\\n', detail['dishes_name'].head(10))# 获取 dishes_name 这一列 数据 的后n行 ---tail()print('获取单列数据：\\n', detail['dishes_name'].tail(10))\"\"\"获取多列数据的前n行----&gt;行下标切片、行名称切片 ----&gt;head(获取前n行) ----&gt;tail(获取后n行)\"\"\"# 获取 dishes_name dishes_id amounts counts 这四列数据 --列名列表 --dataframe ---&gt;前n行数据 --不能使用行下标列表# print('获取多列数据：\\n', detail[['dishes_name', 'dishes_id', 'amounts', 'counts']][[0, 1, 2, 3, 4, 5]]) # 此时是错误的，不能使用行下标列表# 获取 dishes_name dishes_id amounts counts 这四列数据 --列名列表 --dataframe ---&gt;前n行数据 --不能使用行名称列表# print('获取多列数据：\\n',# detail[['dishes_name', 'dishes_id', 'amounts', 'counts']][['index_0', 'index_1', 'index_2']]) # 此时是错误的，不能使用行名称列表# 获取 dishes_name dishes_id amounts counts 这四列数据 --列名列表 --dataframe ---&gt;前n行数据 --行下标切片 --可行print('获取多列数据：\\n',detail[['dishes_name', 'dishes_id', 'amounts', 'counts']][0:5])# 获取 dishes_name dishes_id amounts counts 这四列数据 --列名列表 --dataframe ---&gt;前n行数据 --行名称切片 --可行print('获取多列数据：\\n',detail[['dishes_name', 'dishes_id', 'amounts', 'counts']]['index_0':'index_5'])# 获取 dishes_name dishes_id amounts counts 这四列数据 --列名列表 --dataframe ---&gt;前n行数据 --head --可行print('获取多列数据：\\n', detail[['dishes_name', 'dishes_id', 'amounts', 'counts']].head(10))# 获取 dishes_name dishes_id amounts counts 这四列数据 --列名列表 --dataframe ---&gt;后n行数据 --tail--可行print('获取多列数据：\\n', detail[['dishes_name', 'dishes_id', 'amounts', 'counts']].tail(10)) name’, ‘dishes_id’, ‘amounts’, ‘counts’]].head(10)) 获取 dishes_name dishes_id amounts counts 这四列数据 –列名列表 –dataframe —&gt;后n行数据 –tail–可行 print(‘获取多列数据：\\n’, detail[[‘dishes_name’, ‘dishes_id’, ‘amounts’, ‘counts’]].tail(10))","categories":[],"tags":[]},{"title":"三大框架的对比","slug":"TreasureBox/python/三大框架的对比","date":"2022-05-19T01:14:40.398Z","updated":"2023-04-28T09:25:47.114Z","comments":true,"path":"2022/05/19/treasurebox/python/san-da-kuang-jia-de-dui-bi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/san-da-kuang-jia-de-dui-bi/","excerpt":"","text":"三大框架对比一、Django框架Django走的是大而全的方向，开发效率高。采用MTV架构，自带ORM，admin后台，自带sqlite数据库和开发测试用的服务器，给开发者提供了很高的开发效率。是一个重量级web框架，功能齐全，提供一站式解决的思路，能让开发者不用在选择上花费大量的时间。 自带ORM和模板引擎，支持Jinjia等非官方模板引擎。 自带ORM使Django和关系型数据库耦合度高，如果要使用非关系型，需要使用第三方库 自带数据库管理app 成熟，稳定，开发效率高，相对于Flask，Django整体封闭性比较好，适用于做企业级开发，python web框架的先驱，第三方库丰富。 二、Flask框架Flask是轻量级的框架，自由，灵活，可扩展性强，核心基于Werkzeng WSGI工具和jinja2模板引擎 适用于做小网站以及web服务的API，开发大型网站无压力，但架构需要自己设计 与关系型数据库的结合不弱于Django，与非关系型数据的结合要比Django好。 三、tornado框架Tornado框架走的是少而精的方向，性能优越，他最出名的是异步阻塞的设计方式。 Tornado的两大核心： iostraem：对非阻塞的socket进行简单的封装、 ioloop：对I/O多路复用的封装，它实现一个单例。","categories":[],"tags":[]},{"title":"数据处理","slug":"TreasureBox/python/rest_framework/3.数据处理","date":"2022-05-19T01:14:40.398Z","updated":"2023-04-28T09:25:47.129Z","comments":true,"path":"2022/05/19/treasurebox/python/rest-framework/3.shu-ju-chu-li/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/rest-framework/3.shu-ju-chu-li/","excerpt":"","text":"数据处理一、解析器二、序列化 请求数据校验 QuerySet进行序列化 三、分页四、路由五、视图","categories":[],"tags":[]},{"title":"1、numpy基本使用","slug":"TreasureBox/python/数据分析/week1/1、numpy基本使用","date":"2022-05-19T01:14:40.398Z","updated":"2023-04-28T09:25:47.120Z","comments":true,"path":"2022/05/19/treasurebox/python/shu-ju-fen-xi/week1/1-numpy-ji-ben-shi-yong/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/shu-ju-fen-xi/week1/1-numpy-ji-ben-shi-yong/","excerpt":"","text":"numpy一、numpy使用 numpy介绍 numpy是python的科学计算库，在存储数据时使用连续的内存空间存储，提高了查询效率。numpy内存图如下： numpy基本属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 导入numpyimport numpy as np\"\"\"数组的基本属性： ndim: 数组的秩(纬度)，一维为1，二维为2 shape: 数组的类型，为元组格式，示例:二行三列的数组为(2,3) size: 数组中元素的个数 itemsize: 每个整数占用4 dtype: 数组中数据的类型 data: 占用的内存地址，也被称为缓冲区\"\"\"# 创建数组arrl=np.array([1,2,3])print(type(arrl)) #&lt;class 'numpy.ndarray'&gt;#例1、一维数组print('arr1秩为：',arrl.ndim) #一维数组秩为1，二维数组秩为2print('arr1轴为：',arrl.shape) #(3,) 3列1行print('size为：',arrl.size) # 3*1print('数组中元素的站位大小:',arrl.itemsize) # 4print('元素类型：',arrl.dtype) # int(32)print('每个元素大小：',arrl.itemsize) # (4)print('缓冲区：',arrl.data) # 内存地址print(\"-------------------------------------------------------\")#例2：二维数组arr2=np.array([[1,2,3,4],[4,5,6,7],[7,8,9,10]])print(arr2)print('arr2秩为：',arr2.ndim) #2print('arr2轴为：',arr2.shape) # (3,4)print('size为：',arr2.size) # 3*4print('数组中元素的站位大小:',arr2.itemsize) # 4print('元素类型：',arr2.dtype) # (int(32))print('每个元素大小：',arr2.itemsize) # (4)print('缓冲区：',arr2.data) # 内存地址print(\"-------------------------------------------------------\")#例3：三维数组arr3=np.array([ [[1,2],[3,4],[5,6]], [[7,8],[9,10],[11,12]]])print(arr3)print('arr3秩为：',arr3.ndim) #3print('arr3轴为：',arr3.shape) # (2, 3, 2)print('size为：',arr3.size) # 12print('数组中元素的站位大小:',arr3.itemsize) #4print('元素类型：',arr3.dtype) # (int(32))print('每个元素大小：',arr3.itemsize) # (4)print('缓冲区：',arr3.data) # 内存地址 数组的dtype属性 123456789101112131415161718192021222324252627import numpy as np# numpy 数据类型---封装了Python中的数据类型---进行细致划分 ---&gt;变为numpy.数据类型# 可以创建数组的时候进行通过dtype参数指定arr = np.array([1, 2, 3, 4, 5, 6], dtype=np.float64)print(arr)print(arr.dtype)# 也可以进行强制转化# print(np.float(3))# print(np.int32(3.0))# 0代表False, 非0代表True# print(np.bool(1))# print(np.bool(0))# ndarray 用来存储单一数据类型的数据 ---运算的# 也可以用来存储 复合类型 --不推荐使用# 存储个人信息# df = np.dtype([('name', np.str, 40), ('height', np.float64), ('weight', np.float64)])# # 创建一个数组# arr = np.array([('zs', 178.0, 55.5), ('ls', 180.5, 65.0), ('ww', 190.0, 80.5)], dtype=df)# print(arr)# 创建bool数组---里面值全是bool类型的数组# bool_mask = np.array([0, 1, 1, 0], dtype=np.bool)# print(bool_mask) 数组的创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import numpy as np'''1、使用array函数来创建格式： np.array(object,dtype=None,copy=True,oreder='K',subok=False,ndmin=0)objece：接受array。表示想要创建的数据，无默认值dtype: 接受data-type.表示数组所需的数据类型。如果未给定，则选择保存对象所需的最小类型。默认为Nonendmin:接收int。指定生成数据应该具有的最小维数，默认为None'''a1=np.array([1,2,3,4])print(a1,a1.dtype) #[1 2 3 4] int32a2=np.array([1,2,3.14,4])print(a2,a2.dtype) #[1. 2. 3.14 4. ] float64a2=np.array([1,2,3.14,4],dtype=int)print(a2,a2.dtype) #[1 2 3 4] int32a4=np.array([(1,2),(3,4)])print(a4,a4.ndim)'''[[1 2] [3 4]] 2'''a5=np.array([[1,2],[3,4]])print(a5,a5.ndim)'''[[1 2] [3 4]] 2'''#2、arange()#格式：arange(开始值，终止值，步长) [开始值，终止值]arr6=np.arange(1,9,1)print(arr6) # [1 2 3 4 5 6 7 8]arr7=np.arange(0,1,0.22)print(arr7) #缺点是元素个数预估有难度# [0. 0.22 0.44 0.66 0.88]#3、linspace#格式：linspace(开始值，终止值，元素个数)arr8=np.linspace(0.1,1,7) #float型print(arr8) #[ 0.1 0.25 0.4 0.55 0.7 0.85 1. ]# 4、使用logspace()函数# 生成10~1 到10~3之间的等比例数# base参数默认为10，可选arr9=np.logspace(1,3,3,base=10) #float型print('arr9',arr9) # [ 10. 100. 1000.]# 其他函数a12=np.zeros((2,3)) #生成2行3列的0print(a12)\"\"\"[[0. 0. 0.] [0. 0. 0.]]\"\"\"#empty()函数a13=np.empty((2,3))print(a13)\"\"\"[[0. 0. 0.] [0. 0. 0.]][[0. 0. 0.]\"\"\"#eye(N)函数#生成N阶矩阵，并且对角线元素为1a14=np.eye(3)print(a14)\"\"\"[[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]]\"\"\"#使用diag()函数a15=np.diag([1,2,3,4]) #对角线为1,2,3,4.其他为0print(a15)\"\"\"[[1 0 0 0] [0 2 0 0] [0 0 3 0] [0 0 0 4]]\"\"\" 数组索引 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import numpy as np# # 创建一个一维数组# arr = np.arange(1, 13, 1)# print(arr)## print('arr的维度：', arr.ndim)# print('arr的形状：', arr.shape)# print('*' * 100)## # 使用下标--会降低维度# # 获取 3 ---下标# print('获取3元素:', arr[2])# # 获取11 --下标# print('获取11元素：', arr[-2])## # 使用切片不降低维度# # 获取3 --切片 ---步长为1 可以省略# print('获取3元素：', arr[2:3:1])## # 获取11 --切片# print('获取11元素：', arr[-2:-1:1])## # 获取 3 和 11 --&gt;下标列表# # ---先获取到具体的值，然后将获取多个值组合起来，就得到最终的结果# print('获取3和11元素：', arr[[2, -2]])## # 获取3 和 11 ---按照规律# print('获取3 和11元素：', arr[2:-1:8])# 创建二维数组arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])print(arr)print('arr的维度：', arr.ndim)print('arr的形状：', arr.shape)# # 获取 5元素 ---下标# print('获取5元素：', arr[1, 0])## # 获取11 元素---下标# print('获取11元素：', arr[2, 2])## # 获取 5元素 --切片# print('获取 5元素：', arr[1:2, 0:1])## # 获取 11 元素---切片# print('获取11元素：', arr[2:3, 2:3])## # 获取5 元素 --下标、切片配合# print('获取5 元素：', arr[1, 0:1])## # 获取11元素 --下标、切片配合# print('获取11元素：', arr[2:3, 2])## # 获取多个元素# # 获取 6 7 10 11 -下标列表 ---将多个具体的值组合起来# print('获取6 7 10 11：', arr[[1, 1, 2, 2], [1, 2, 1, 2]])## # 获取6 7 10 11 --切片# # [[ 6 7]# # [10 11]]# print('获取6 7 10 11：\\n', arr[1:3, 1:3])## # 获取 6 8 13 16 ---下标列表# print('获取6 8 13 16：', arr[[1, 1, 3, 3], [1, 3, 0, 3]])# 存在arr ---3维 ----&gt;arr[块索引,行索引,列索引]# 存在arr ---n维 ----&gt;arr[n-1个逗号将各个维度分开] 在各个维度上单独索引# 索引方式---思维方式# 获取 7 元素# print('获取7元素：', arr[1][2]) # 高维度是由多个低维度组成# bool数组索引# 利用bool数组的特性来进行索引# 数组里面全部为 bool值的数组bool_mask = np.array([0, 1, 1, 0], dtype=np.bool)print(bool_mask)# 利用bool数组索引# 保留True 干掉False# print('bool数组索引：\\n', arr[bool_mask, :])print('bool数组索引：\\n', arr[:, bool_mask])# 参考都使用下标列表形式理解# arr[[F,T,T,F],[F,T,T,F]]# print('bool数组索引：\\n', arr[bool_mask, bool_mask]) 数组shape属性 123456789101112131415161718192021222324252627282930313233import numpy as np# 创建数组# arr = np.arange(16)# print(arr)# print('arr的维度：', arr.ndim)# print('arr的形状：', arr.shape)# print('*' * 100)# 元素个数不能变化# 形状更改 ---shape属性重新赋值# arr.shape = (4, 4)# print(arr)# reshape --更改形状 --返回新的数组# arr = arr.reshape((4,4))# print(arr)# 同时使用np.arange 和 reshapearr = np.arange(16).reshape((4, 4))print(arr)# 将高维度 展开为一维数组# new_arr = arr.flatten() # 返回的是一个拷贝# 参数 C --行优先展开# F---列优先展开# new_arr = arr.ravel() # 返回自身的视图# print(new_arr)# -1 只是占位作用# new_arr = arr.reshape((-1,))# new_arr = arr.reshape((-1, 1))# print(new_arr) 组合数组 1234567891011121314151617181920212223242526import numpy as np# 创建数组arr1 = np.arange(4).reshape((2, 2))arr2 = np.array([[0, 1], [0, 1]])print('arr1:\\n', arr1)print('arr2:\\n', arr2)print('*' * 100)# 合并# 向下拼接 ----垂直拼接# res = np.vstack((arr1,arr2))# print(res)# 向右拼接 ----水平拼接# res = np.hstack((arr1, arr2))# print(res)# # 行的方向进行拼接---垂直拼接# res = np.concatenate((arr1, arr2), axis=0)# print(res)## # 列的方向进行拼接---水平拼接# res = np.concatenate((arr1, arr2), axis=1)# print(res) 数组拆分 123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as np# 创建数组arr = np.arange(16).reshape((4, 4))print(arr)print('*' * 100)# 第二个必须是能够被整除的，均匀拆分# 水平拆分 ---将水平的行 打断# res = np.hsplit(arr, 2)# print(res)# 垂直拆分 ---将垂直的列 打断# res = np.vsplit(arr, 2)# print(res)# 把行的方向拆成 2部分 ---垂直拆分# res = np.split(arr, 2, axis=0)# print(res)# 把列的方向拆成2部分---水平拆分# res = np.split(arr, 2, axis=1)# print(res)# 可以不均匀拆分# 把行的方向进行拆分# ---这么拆：[:1] [1:3],[3:]# ---[:开始值]# ---[开始值：结束值]# ---[结束值：]# res = np.split(arr, [1, 3], axis=0)[0]# print(res)# print('*' * 100)# res = np.split(arr, [1, 3], axis=0)[1]# print(res)# 前n列为一部分，最后一列为一部分# 使用索引# part_1 = arr[:, :-1]# part_2 = arr[:, -1:]# print('part_1:\\n',part_1)# print('part_2:\\n',part_2) 生成矩阵 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as np# 生成矩阵# 可以使用np.mat np.asmatrix来创建矩阵# np.mat = np.asmatrix 一样的# np.mat 将特殊字符串转化为矩阵# m1 = np.mat('1 2 3;4 5 6;7 8 9')# print(m1)# print(type(m1)) # &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;# print(m1.ndim) # 2维 ---只能是2维# print(m1.shape) # (3,3)# print(m1.itemsize)# print(m1.dtype)# print(m1.size)# # 也可以将列表嵌套转化为矩阵# m1 = np.asmatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])# print(m1)# print(type(m1)) # &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;### # 也可以将二维数组转化为矩阵## # 创建一个二维数组# arr = np.arange(9).reshape((3, 3))## m1 = np.mat(arr)## print(m1)# print(type(m1)) # &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;# 可以使用np.bmat来组合矩阵arr1 = np.array([[1, 2], [1, 2]])arr2 = np.arange(4).reshape((2, 2))print('arr1:\\n', arr1)print('arr2:\\n', arr2)print('*' * 100)# 利用np.bmat将数组组合成矩阵# res = np.bmat('arr1 arr2;arr2 arr1')# res = np.bmat([[arr1, arr2], [arr2, arr1]]) # 列表对象# print(res)# print(type(res)) # &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;# 可以使用np.bmat 可以将 二维数组转化为矩阵res = np.bmat(arr1)# res = np.bmat('1 2 3;4 5 6;7 8 9') # 错误的# res = np.bmat([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # 错误的print(res)print(type(res)) # &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt; ��表对象 print(res)print(type(res)) # &lt;class ‘numpy.matrixlib.defmatrix.matrix’&gt;可以使用np.bmat 可以将 二维数组转化为矩阵 res = np.bmat(arr1) res = np.bmat(‘1 2 3;4 5 6;7 8 9’) # 错误的res = np.bmat([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # 错误的 print(res) print(type(res)) # &lt;class ‘numpy.matrixlib.defmatrix.matrix’&gt;","categories":[],"tags":[]},{"title":"2、数组操作","slug":"TreasureBox/python/数据分析/week1/2、数组操作","date":"2022-05-19T01:14:40.398Z","updated":"2023-04-28T09:25:47.120Z","comments":true,"path":"2022/05/19/treasurebox/python/shu-ju-fen-xi/week1/2-shu-zu-cao-zuo/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/shu-ju-fen-xi/week1/2-shu-zu-cao-zuo/","excerpt":"","text":"数组操作 矩阵运算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import numpy as np# 创建矩阵进行运算m1 = np.mat('1 2;3 4') # ---(2,2)m2 = np.asmatrix([[2, 1], [1, 2]]) # ----(2,2)print('m1:\\n', m1)print('m2:\\n', m2)print('*' * 100)# 矩阵相加 ---同型矩阵 ---对应位置相加print('m1 + m2 :\\n', m1 + m2)# 矩阵相减---矩阵加上后面的矩阵的负矩阵 ---对应位置相减print('m1 - m2 :\\n', m1 - m2)# 矩阵与 数的相乘 ----每一个元素都与数进行相乘# 3 和 m1 进行相乘print('3 * m1 :\\n', 3 * m1)# # 矩阵 与矩阵 相乘# # 规则：如果两个矩阵进行相乘，左矩阵的列 必须等于右矩阵的行，才能相乘# # 生成一个左矩阵行、右矩阵列的矩阵print('m1 * m2:\\n', m1 * m2)# np.matmulprint('m1 * m2 :\\n', np.matmul(m1, m2))# np.dotprint('m1 * m2 :\\n', np.dot(m1, m2))# 矩阵对应位置元素相乘 ---同型矩阵print('m1、m2对应位置元素相乘：\\n', np.multiply(m1, m2))# 矩阵性质# 矩阵转置print('m1 的转置：\\n',m1.T)# 矩阵的逆print('m1 的逆矩阵：\\n', m1.I)# 逆矩阵性质---A*A的逆 = E ----&gt; |A| = 0 ---&gt;直接报错，或者出现infprint('m1 * m1 的逆矩阵：\\n', m1 * m1.I)# 矩阵的视图# 可以通过np.mat np.asmatrix将ndarray转化为矩阵# 可以通过矩阵.A 来获取 ndarrayprint('m1 的视图：\\n', m1.A)print('m1 视图的类型：\\n', type(m1.A)) # &lt;class 'numpy.ndarray'&gt;# 索引---对于ndarray,使用下标会降低维度# 对于矩阵 --使用下标 不降低维度print('获取m1的/元素', m1[0, :])# 矩阵的共轭转置# 先共轭，再转置 ---复数print('m1的共轭转置：\\n',m1.H) 数组计算 数组的全通用函数 —是一种能够对数组中所有元素进行操作的函数–以整个数组为输出。 要求：运算的数组 —必须是同型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import numpy as np# 创建两个数组# arr1 = np.array([[1, 2], [2, 1]]) # (2,2)# arr2 = np.arange(1, 5).reshape((2, 2)) # (2,2)# print('arr1:\\n', arr1)# print('arr2:\\n', arr2)# print('*' * 100)# (1) 四则运算 --- + - * / ** ----&gt;对应位置运算进行对应的四则元素--以整个数组为一个运算单位# print('arr1 + arr2:\\n', arr1 + arr2) # 对应位置元素相加# print('arr1 - arr2 :\\n', arr1 - arr2) # 对应位置元素相减# print('arr1 * arr2 :\\n', arr1 * arr2) # 对应位置元素相乘# print('arr1 / arr2 :\\n', arr1 / arr2) # 对应位置元素相除---注意：除数不能为0# print('arr1 ** arr2:\\n', arr1 ** arr2) # 对应位置元素求幂# (2) 比较运算 --- &gt; &lt; &gt;= &lt;= == != ----&gt;返回bool数组# 对应位置元素进行比较，如果满足比较的条件，返回True 否则为False ---&gt;返回bool数组# print('arr1 == arr2 :\\n', arr1 == arr2)# print('arr1 &lt;= arr2:\\n', arr1 &lt;= arr2)# print('arr1 &gt; arr2 :\\n', arr1 &gt; arr2)# print('*' * 100)# (3) 逻辑运算 ---返回bool值# np.all 相当于and --只有都满足的条件的时候，才返回True，只要有一个不满足，结果即为False# np.any 相当于or --只要有一个满足条件，就返回True,全部都不满足条件，则结果为False# print('all:\\n', np.all(arr1 == arr2))# print('all:\\n', np.all(arr1 &lt;= arr2))# print('any:\\n', np.any(arr1 == arr2))# print('any:\\n', np.any(arr1 &gt; arr2))# 先比较---然后利用比较运算返回的bool数组进行索引操作# 创建一个数组---身高的数组height = np.array([170, 175, 178, 180, 172])# 找到偶数的身高 ---bool数组bool_mask = height % 2 == 0print(bool_mask)# 筛选出具体的偶数的身高new_height = height[bool_mask]print(new_height)# 创建两个数组arr1 = np.arange(6).reshape((2, 3)) # (2,3)--&gt;shape的长度为2arr2 = np.array([2, 1, 3]) # (3,) ---&gt;shape的长度为1 ---&gt; arr2向arr1看齐 ---&gt;(1,3)arr3 = np.array([[1, 2], [2, 1]]) # (2,2)print('arr1:\\n', arr1)print('arr2:\\n', arr2)print('arr3:\\n', arr3)# 数组的广播机制 --- 不同型的数组的算术运算规则# print('arr1 + arr2 :\\n', arr1 + arr2)# print('arr1 + arr3 :\\n', arr1 + arr3) # 不能运算# arr1# [[0 1 2]# [3 4 5]]# arr2# [2 1 3] ---&gt;(1,3) ---&gt;[[2 1 3]] --&gt;行维度为1 ---沿着行维度的计算，---都使用第0行数据# (4) ---两个数组进行运算--如果有维度为1，沿着此轴上的运算都用第一组值# 根据(4) ---&gt;arr2# [[2 1 3]# [2 1 3]]# [[0 1 2] + [[2 1 3]# [3 4 5]] [2 1 3]]# ---&gt;[[2 2 5]# 5 5 8 ]]# ----&gt;输出(2,3)# 输入(2,3) (3,)--&gt;(1,3) ---&gt;可以运算# arr1 arr3 为什么不能运算？# arr1 (2,3) arr3(2,2)# (2)规则---&gt; 输出(2,3) ---&gt;(3)规则# ---输出数组形状的列维度 与 arr3输入数组形状在列维度不相等且并没有一个为1的，所以不能运算# 假设存在arr1 shape为(1,2,3,4,4,5,6)数组# 存在arr2 shape为(1,2,4,4,1,1)数组---&gt;(1,1,2,4,4,1,1)# 这两个数组不能相加 数组保存与读取 123456789101112131415161718192021import numpy as np# 数组可以以二进制形式、文本形式进行保存# 二进制形式---以0101的这种进行保存# 创建一个数组进行保存arr = np.arange(16).reshape((4, 4))print(arr)# 将单个数组以二进制形式进行保存# 参数1 路径+ 名称，此时，文件后缀名可以省略，默认保存成以.npy为结尾二进制文件# 参数2 需要保存的数组np.save('./arr',arr)print('保存成功')# 加载.npy文件# 参数 文件路径+名称，此时后缀名不能省略data = np.load('./arr.npy')print('加载的数据为：\\n',data)# 文本形式---以人可以识别的有序的序列内容进行保存 数组排序 12345678910111213141516171819202122232425262728293031323334353637383940import numpy as np# 创建一个一维的数组arr = np.array([5, 4, 6, 8, 1, 2, 9])print('arr:\\n', arr)# 对数组进行排序 ---快排--对列的方向的进行排序--对原数组直接产生影响arr.sort()# 升序排序print('排序之后的数组：\\n', arr)# 创建二维的数组# arr = np.array([[7, 5, 8], [9, 6, 4], [3, 4, 9]])# print(arr)# 对二维数组进行排序# 列的方向进行升序排序# 如：此时排序，各行之间毫无关系，只是在各行内部，对不同的列进行升序排序# arr.sort()# 行的方向上升序排序# 如：此时排序，各列之间毫无关系，只是在各列内部，对不同的行进行升序排序# arr.sort(axis=0)# print('排序之后的数组：\\n', arr)# 间接排序# 不对数组排序，只是返回数组排序之后的下标arr = np.array([5, 4, 6, 8, 1, 2, 9])print('arr:\\n', arr)# 使用np.argsort进行排序res = np.argsort(arr)print('排序之后的结果：\\n',res)# 二维数组# arr = np.array([[7, 5, 8], [9, 6, 4], [3, 4, 9]])# print(arr)## # 列的方向 ---返回的是对应的下标res = np.argsort(arr, axis=-1)print(res) 数组去重 12345678910111213141516171819import numpy as np# 数组去重功能# 创建数组arr = np.array([2, 2, 2, 2, 1, 1, 1, 5, 5, 5, 4, 4, 4, 6, 6, 6])print(arr)arr = np.array(['zs', 'ls', 'ww', 'zl', 'kk', 'zz', 'zs', 'ls', 'ww', 'zl', 'kk'])print(arr)arr = np.array(['小明','小名','小名','小名','小花','小华','小花'])print(arr)print('*' * 100)# 查看该数组中具有哪些数据# 可以使用unique进行去重，---兼并排序# 英文数组 也适用# 中文数组 也适用 ---- 中文数组排序 ----编码---unicode---之后在进行ansii排序res = np.unique(arr)print(res) 重复数组 123456789101112131415161718192021222324252627import numpy as np# 创建一个二维数组arr = np.arange(9).reshape((3, 3))print('arr:\\n', arr)print('*' * 100)# 重复 -# np.tile --以数组的整体为单位进行重复# 参数1 需要重复的数组# 参数2 重复次数 ---可以指定按照对应的维度重复的次数res = np.tile(arr, 2)print(res)# 现在列的方向重复2次之后，以整体再在行的方向重复2次，再在以整体在块的方向重复2次res = np.tile(arr, [2, 2, 2])print(res)# np.repeat# 重复# 参数1 需要重复的数组# 参数2 重复的次数# axis 指定重复方向、轴# 若指定轴，沿着轴的方向以整行、整列为一个重复单位来重复指定的次数res = np.repeat(arr, 2, axis=1)# 如果不指定轴，默认会将数组展开，然后按照列的方向 以每一个元素为一个重复单位来重复指定次数# res = np.repeat(arr, 2)# # 不能省略重复次数print(res) 统计指标计算 主要有求和，均值，标准差，方差，最小值，最大值等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import numpy as np# 创建一个二维数组arr = np.arange(1, 17).reshape((4, 4))print('arr:\\n', arr)print('*' * 100)# np.统计指标 --numpy里面的方法# arr.统计指标 --ndarray里面的方法# 沿着行的方向 ---向下统计的# sum(和) -----相加print('对arr 进行求和：', np.sum(arr, axis=0))# mean(均值) -----和/个数print('对arr 进行求均值：', np.mean(arr, axis=0))# std(标准差) ---反应的数据的离散程度print('对arr 进行求标准差：', np.std(arr, axis=0))# var(方差) ---标准差的平方---反应的数据的离散程度print('对arr 进行求方差：', np.var(arr, axis=0))# min(最小值)print('对arr 进行求最小值：', np.min(arr, axis=0))# max(最大值)print('对arr 进行求最大值：', np.max(arr, axis=0))# argmin(最小值的下标)print('对arr 进行求最小值下标：', np.argmin(arr, axis=0))# argmax(最大值的下标)print('对arr 进行求最大值下标：', np.argmax(arr, axis=0))# cumsum(累计和)print('对arr 进行求累计和：\\n', np.cumsum(arr, axis=0))# cumprod(累计积)print('对arr 进行求取累计积：\\n', np.cumprod(arr, axis=0))# 如果不指定轴 ---展开进行成一维进行统计指标print('对arr 进行求取累计和：\\n',np.cumsum(arr))# ndarray里面的方法print('对arr 进行求取累计和：\\n',arr.cumsum(axis=0)) ��\\n’, np.cumprod(arr, axis=0)) 如果不指定轴 —展开进行成一维进行统计指标 print(‘对arr 进行求取累计和：\\n’,np.cumsum(arr)) ndarray里面的方法 print(‘对arr 进行求取累计和：\\n’,arr.cumsum(axis=0))","categories":[],"tags":[]},{"title":"3、matplotlib使用","slug":"TreasureBox/python/数据分析/week1/3、matplotlib使用","date":"2022-05-19T01:14:40.398Z","updated":"2023-04-28T09:25:47.121Z","comments":true,"path":"2022/05/19/treasurebox/python/shu-ju-fen-xi/week1/3-matplotlib-shi-yong/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/shu-ju-fen-xi/week1/3-matplotlib-shi-yong/","excerpt":"","text":"matplotlib使用matplotlib是一个可视化库，用于在python中创建静态，动画和交互式可视化。绘图流程主要包含以下三步： 创建画布 绘制图形 图形展示 简单图形示例 123456789101112131415161718192021222324252627import matplotlib.pyplot as pltimport numpy as np# 绘图三部曲# (1)创建画布# 参数： figsize ---画布大小# 参数： dpi ---像素# 返回值： 返回画布对象plt.figure()# (2)绘制图形# 绘制下一周天气走势---折线图# 折线图---要素：点 ---坐标轴：x,y坐标 ---(x,y)# 绘制折线图的时候---准备 (x1,y1) (x2,y2) (x3,y3) ....# 绘制折线图的时候，不需要配对xy---只需要准备好一个x数组，一个y的数组# 横轴---周一、周二、 ...、周日# 纵轴---不同的温度# 如果横轴是中文，一般先用序号代替，后续再进行将序号替换为中文x = np.arange(1, 8)y = np.array([15, 20, 22, 23, 20, 18, 16])print('x:\\n', x)print('y:\\n', y)# 绘制plt.plot(x,y)# (3)图形展示plt.show() 图形修饰 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import matplotlib.pyplot as pltimport numpy as np# 绘图三部曲# (1)创建画布# 参数： figsize ---画布大小# 参数： dpi ---像素# 返回值： 返回画布对象plt.figure()# 默认不支持中文# 修改参数，让其支持中文plt.rcParams['font.sans-serif'] = 'SimHei'# 修改参数让其重新支持负号plt.rcParams['axes.unicode_minus'] = False# (2)绘制图形# 绘制下一周天气走势---折线图# 折线图---要素：点 ---坐标轴：x,y坐标 ---(x,y)# 绘制折线图的时候---准备 (x1,y1) (x2,y2) (x3,y3) ....# 绘制折线图的时候，不需要配对xy---只需要准备好一个x数组，一个y的数组# 横轴---周一、周二、 ...、周日# 纵轴---不同的温度# 如果横轴是中文，一般先用序号代替，后续再进行将序号替换为中文x = np.arange(1, 8)y_bj = np.array([15, 20, 22, 23, 20, 18, 16])y_heb = np.array([-10, -8, -12, -10, -8, -6, 1])print('x:\\n', x)print('y_bj:\\n', y_bj)print('y_heb:\\n', y_heb)# color --线的颜色# linestyle --线的样式# linewidth --线的宽度# marker --点的样式# markersize --点的大小# markerfacecolor --点的填充颜色# markeredgecolor --点的边缘颜色# 绘制plt.plot(x, y_bj, color='r', linestyle=':', linewidth=1.2, marker=\"*\", markersize=7, markerfacecolor='b', markeredgecolor='g')plt.plot(x, y_heb, color='#2F4F4F', linestyle='-.', linewidth=1.2, marker=\"d\", markersize=7, markerfacecolor='r', markeredgecolor='r')# 增加标题plt.title('北京、哈尔滨下一周天气温度走势图')# 修改横轴名称plt.xlabel('日期')# 修改纵轴名称plt.ylabel('温度/℃')# 将横轴的序号 替换为中文 --修改横轴刻度# 注意：如果修改的时候，是将序号替换为中# 参数1 ：需要被替换的序号# 参数2 ：替换之后的中文# 构建中文日期列表xticks = ['周一', '周二', '周三', '周四', '周五', '周六', '周日']# rotation=45 旋转角度plt.xticks(x, xticks, rotation=45)# 修改纵轴刻度# 重新设置新的显示的刻度范围# 注意：只需要将新的刻度范围传递进去# 并不改变真实点的纵坐标，只是修改其显示位置yticks = np.arange(-15, 31, 3)plt.yticks(yticks)# 增加图例# loc 图例的位置plt.legend(['北京', '哈尔滨'], loc=4)# 标注# plt.text ---一次标注一个点# 循环标注for i, j in zip(x, y_bj): # zip打包函数 # i 点的横坐标 # j 点的纵坐标 # 参数1 标注的横坐标 # 参数2 标注的纵坐标 # 参数3 标注的内容---str plt.text(i, j + 1, '%d℃' % j, horizontalalignment='center', # 水平居中 # verticalalignment='bottom' # 点的底部 )for i, j in zip(x, y_heb): # zip打包函数 # i 点的横坐标 # j 点的纵坐标 # 参数1 标注的横坐标 # 参数2 标注的纵坐标 # 参数3 标注的内容---str plt.text(i, j + 1, '%d℃' % j, horizontalalignment='center', # 水平居中 # verticalalignment='bottom' # 点的底部 )# 将图片进行保存plt.savefig('./北京、哈尔滨下一周天气温度走势图.png')# (3)图形展示plt.show() 柱状图 123456789101112131415161718192021import matplotlib.pyplot as pltlabels = ['G1', 'G2', 'G3', 'G4', 'G5']men_means = [20, 35, 30, 35, 27]women_means = [25, 32, 34, 20, 25]men_std = [2, 3, 4, 1, 2]women_std = [3, 5, 2, 3, 3]width = 0.35 fig, ax = plt.subplots()ax.bar(labels, men_means, width, yerr=men_std, label='Men')ax.bar(labels, women_means, width, yerr=women_std, bottom=men_means, label='Women')ax.set_ylabel('Scores')ax.set_title('Scores by group and gender')ax.legend()plt.show() 更多示例参见官网案例：https://matplotlib.org/gallery/index.htmlow() ``` 更多示例参见官网案例：https://matplotlib.org/gallery/index.html","categories":[],"tags":[]},{"title":"os","slug":"TreasureBox/python/python常用标准库/1.os","date":"2022-05-19T01:14:40.397Z","updated":"2023-04-28T09:25:47.141Z","comments":true,"path":"2022/05/19/treasurebox/python/python-chang-yong-biao-zhun-ku/1.os/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/python-chang-yong-biao-zhun-ku/1.os/","excerpt":"","text":"OS模块 函数 说明 os.getcwd() 获取当前工作路径 os.chdir(path) 切换到path路径 os.listdir(path) 获取path路径的所有文件或文件夹列表，文件夹为空时为空列表 os.mkdir(path,permission) 创建空文件夹，可以指定权限 os.makedirs(“/home/vc/ss”) 循环创建文件夹 os.removedirs(“/home/vc/ss”) 循环删除空文件夹，文件夹不为空时会报错 os.rename(“home”,”HOME”) 文件夹重命名 os.stat(path) 获取文件或文件夹信息 os.system(“ls -al”) 执行系统命令 result=os.popen(“ls -al”) 执行系统命令并能获取执行结果 os.getenv(‘PATH’) 获取系统环境变量 os.putenv(‘PATH’,’/home/sy/ 将一个目录添加到环境变量中 os.curdir 表示当前文件夹，类似(.) os.pardir 表示上一层文件夹，类似(..) os.name 获取操作系统的名字，nt代表windows，posix代表linux或者unix os.sep 获取系统路径间隔符号，windows\\ os.extsep 获取文件名称和后缀的间隔符号 os.linesep 获取操作系统的幻狼福，windows是“\\r\\n”，linux是”\\n” os.path子模块的内容 函数 说明 os.path.abspath(“/boys”) 将相对路径转换为绝对路径 os.path.dirname(path) 获取完整目录除最后文件夹的其他部分 os.path.basename(path) 获取最后的目录部分 os.path.split(“/home/sy/boys”) (‘/home/sy’, ‘boys’) 将一个完整路径切割成目录部分和主体部分 os.path.join(path1,path2) 将两个路径合并成1个 os.path.splitext(filepath) 将一个文件路径切成文件后缀和其他两部分，用于获取文件后缀名 os.path.getsize(filepath) 获取文件的字节数 os.path.isfile(path) 检测是否是文件 os.path.isdir(path) 检测是否是文件夹 os.path.islink(path) 检测是否是链接 os.path.getctime(filepath) 获取文件的创建时间 os.path.getmtime(filepath) 获取文件的修改时间 os.path.getatime(filepath) 获取文件的访问时间 os.path.exists(filepath) 检测某个路径是否真实存在 os.path.isabs(path) 检测一个路径是否绝对路径 os.path.samefile(path1,path2) 检测两个路径是否是同一个文件 |","categories":[],"tags":[]},{"title":"random","slug":"TreasureBox/python/python常用标准库/2.random","date":"2022-05-19T01:14:40.397Z","updated":"2023-04-28T09:25:47.142Z","comments":true,"path":"2022/05/19/treasurebox/python/python-chang-yong-biao-zhun-ku/2.random/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/python-chang-yong-biao-zhun-ku/2.random/","excerpt":"","text":"random模块的使用random主要用于生成随机数使用： 函数 说明 random.seed(a=None, version=2) 初始化伪随机数生成器。如果未提供a或者a=None，则使用系统时间为种子。如果a是一个整数，则作为种子。 random.getstate() 返回一个当前生成器的内部状态对象 random.setstate(state) 传入一个先前利用getstate方法获得的状态对象，使得生成器恢复到这个状态。 random.getrandbits(k) 返回range(0,2***k)之间的一个整数，相当于randrange(0,2***k) random.randrange(start, stop[, step]) 返回range[start,stop)之间的一个整数，可加step，跟range(0,10,2)类似 random.randint(a, b) 返回range[a,b]之间的一个整数，等价于range(a,b+1) random.choice(seq) 非空序列seq中随机选取一个元素。如果seq为空则弹出 IndexError异常。 random.choices(population, weights=None, *, cum_weights=None,k=1) 3.6版本新增。从population集群中随机抽取K个元素（可重复），以列表形式存在。weights是相对权重列表，cum_weights是累计权重，两个参数不能同时存在。 lst = [1,2,3]random.shuffle(lst)print(lst) 随机打乱序列x内元素的排列顺序。只能针对可变的序列。 random.sample(population,k) 从population样本或集合中随机抽取K个不重复的元素形成新的序列。常用于不重复的随机抽样。返回的是一个新的序列，不会破坏原有序列。要从一个整数区间随机抽取一定数量的整数，请使用sample(range(10000000), k=60)类似的方法，这非常有效和节省空间。如果k大于population的长度，则弹出ValueError异常。 random.random() 返回一个介于左闭右开[0.0, 1.0)区间的浮点数 random.uniform(a, b) 返回一个介于a和b之间的浮点数。如果a&gt;b，则是b到a之间的浮点数。这里的a和b都有可能出现在结果中。 random.triangular(low, high, mode) 返回一个low &lt;= N &lt;=high的三角形分布的随机数。参数mode指明众数出现位置。 random.betavariate(alpha, beta) β分布。返回的结果在0~1之间，alpha和beta都要大于0 random.expovariate(lambd) 指数分布 random.gammavariate(alpha, beta) 伽玛分布，alpha和beta都要大于0 random.gauss(mu, sigma) 高斯分布 random.lognormvariate(mu, sigma) 对数正态分布 random.normalvariate(mu, sigma) 正态分布 random.vonmisesvariate(mu, kappa) 卡帕分布 random.paretovariate(alpha) 帕累托分布 random.weibullvariate(alpha, beta) 威布尔分布 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import random\"\"\"'betavariate', 'choice', 'expovariate', 'gammavariate', 'gauss', 'getrandbits', 'getstate', 'lognormvariate', 'normalvariate', 'paretovariate', 'randint', 'random', 'randrange', 'sample', 'seed', 'setstate', 'shuffle', 'triangular', 'uniform', 'vonmisesvariate', 'weibullvariate'\"\"\"# random.seed(a=None, version=2) # 初始化伪随机数生成器。如果未提供a或者a=None，则使用系统时间为种子。如果a是一个整数，则作为种子。# print(random.seed( version=2))# random.getstate() # 返回一个当前生成器的内部状态的对象# state = random.getstate()# print(state, type(state))# random.setstate(state) # 传入一个先前利用getstate方法获得的状态对象，使得生成器恢复到这个状态。# state = random.getstate()# print(state, type(state))# random.getrandbits(k) # 返回range(0,2**k)之间的一个整数，相当于randrange(0,2**k)# print(random.getrandbits(3))# print(random.randrange(0,2**3))# random.randrange(stop) # 返回range(0,stop)之间的一个整数# random.randrange(start, stop[, step]) # 返回range[start,stop)之间的一个整数，可加step，跟range(0,10,2)类似## random.randint(a, b) # 返回range[a,b]之间的一个整数，等价于range(a,b+1)## random.choice(seq) # 从非空序列seq中随机选取一个元素。如果seq为空则弹出 IndexError异常。## random.choices(population, weights=None, *, cum_weights=None,k=1) # 3.6版本新增。从population集群中随机抽取K个元素（可重复）。weights是相对权重列表，cum_weights是累计权重，两个参数不能同时存在。# print(random.choices((1,2,3,4), weights=None, cum_weights=None,k=2))# random.shuffle(x[, random]) # 随机打乱序列x内元素的排列顺序。只能针对可变的序列，对于不可变序列，请使用下面的sample()方法。lst = [1,2,3]random.shuffle(lst)print(lst)# random.sample(population,k) # 从population样本或集合中随机抽取K个不重复的元素形成新的序列。常用于不重复的随机抽样。返回的是一个新的序列，不会破坏原有序列。要从一个整数区间随机抽取一定数量的整数，请使用sample(range(10000000), k=60)类似的方法，这非常有效和节省空间。如果k大于population的长度，则弹出ValueError异常。print(random.sample((1,2,3),2))# random.random() # 返回一个介于左闭右开[0.0, 1.0)区间的浮点数## random.uniform(a, b) # 返回一个介于a和b之间的浮点数。如果a&gt;b，则是b到a之间的浮点数。这里的a和b都有可能出现在结果中。## random.triangular(low, high, mode) # 返回一个low &lt;= N &lt;=high的三角形分布的随机数。参数mode指明众数出现位置。print(random.triangular(1, 5, 3))# random.betavariate(alpha, beta) # β分布。返回的结果在0~1之间## random.expovariate(lambd) # 指数分布print(random.expovariate(2))# random.gammavariate(alpha, beta) # 伽玛分布## random.gauss(mu, sigma) # 高斯分布## random.lognormvariate(mu, sigma) # 对数正态分布## random.normalvariate(mu, sigma) # 正态分布## random.vonmisesvariate(mu, kappa) # 卡帕分布## random.paretovariate(alpha) # 帕累托分布## random.weibullvariate(alpha, beta) # 威布尔分布 布# random.weibullvariate(alpha, beta) # 威布尔分布","categories":[],"tags":[]},{"title":"rest_framework初识","slug":"TreasureBox/python/rest_framework/1.rest_framework初识","date":"2022-05-19T01:14:40.397Z","updated":"2023-04-28T09:25:47.126Z","comments":true,"path":"2022/05/19/treasurebox/python/rest-framework/1.rest-framework-chu-shi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/rest-framework/1.rest-framework-chu-shi/","excerpt":"","text":"rest_framework初识在开发过程中，通常会进行前后端分离设计，这样不仅有助于加快前后端的开发速度，降低前后端代码的耦合度，还有利于提高后端代码的适用性，比如一个API接口可以同时供web端和app端进行使用。首先了解python中API开发，python中的API主要有两种视图的处理： FBV：Function base view（基于函数的视图） CBV：Function base view（基于类的视图） CBV：基于反射实现，根据请求方式的不同，执行不同的方法：get,post,put,delete等 一、restful 规范随着代码编写，逐渐形成了一种大家公认的，比较合理的接口开发和命名规范，这种规范就被称为restful风格。是建议在开发的过程中遵守restful接口规范，但并不是强制要求。restful接口规范主要有以下10种。 普通接口，用用户管理示例，需要四个接口： 12345678def get_user(request): passdef add_user(request): passdef put_user(request): passdef delete_user(request): pass 使用restful风格，一个接口处理一条数据： 1234567891011def users(request): uses_list = [\"柚子\", \"西瓜\"] if request.method == \"GET\": pass elif request.method == \"POST\": pass elif request.method == \"PUT\": pass elif request.method == \"DELETE\": pass return HttpResponse(json.dumps(uses_list)) url中带上api进行区分 www.youzi.com/api/ 版本 www.youzi.com/api/v1 路径 url尽量使用名词：www.youzi.com/api/v1/user method GET:从服务器获取资源 POST:在服务器新建一个资源 PUT：更新全部资源 PATCH:更新部分资源 DELETE：删除资源 过滤 www.youzi.com/api/v1/user/limit=10 www.youzi.com/api/v1/user/offsey=10 www.youzi.com/api/v1/user/type=1 状态码 状态码 说明 200 成功 201 用户新建或修改数据成功(POST/PUT/PATCH) 202 Accepted，表示异步任务已经进入后台排队 204 用户删除数据成功(DELETE) 301 一次重定向 302 永久重定向 401 没有权限 403 有权限，但是访问禁止了，可能是没通过其他的校验，比如django的csrf 404 数据不存在 406 数据请求格式不正确，比如请求json，但是只有xml 410 用户请求的数据被永久删除，且不会再得到了 422 当创建对象时，发生校验码错误 500 服务器错误 错误处理 123{ error:\"password error\"} 返回结果对不同的请求方式返回不同的结果，例如查看列表或者查看详情。 在列表页返回详情页的链接123456789101112[ { \"id\":\"1\", \"name\":\"youzi\", \"url\":www.youzi.com/api/v1/fruit/1 }, { \"id\":\"2\", \"name\":\"xigua\", \"url\":www.youzi.com/api/v1/fruit/2 },] 二、Django rest_framework框架RestFramework是一个能快速为我们提供API接口，方便我们编程的框架。依赖于django框架。自带很多实用的功能，并且提供了丰富的扩展性，我们可以通过重写一些方法进行二次开发。 普通的基于类的视图 基于类的视图需要继承django.views中的View类，在urls中调用类视图的as_view()方法，请求时首先会执行dispatch()方法，在dispatch()方法中通过getattr()进行反向映射找到要请求的方法如：get，post，put，patch等。 以下是使用类视图的示例： views代码： 12345678910111213141516171819202122from django.views import Viewclass TeachersView(View): \"\"\"teacher view\"\"\" def dispatch(self, request, *args, **kwargs): \"\"\"重写dispatch方法\"\"\" print(\"before\") ret = super().dispatch(request, *args, **kwargs) print(\"after\") return ret def get(self,request,*args,**kwargs): return HttpResponse(\"get\") def post(self,request,*args,**kwargs): return HttpResponse(\"post\") def put(self,request,*args,**kwargs): return HttpResponse(\"put\") def delete(self,request,*args,**kwargs): return HttpResponse(\"delete\") urls代码 12345from django.urls import pathfrom django.views.decorators.csrf import csrf_exempturlpatterns = [ path('teachers/', csrf_exempt(views.TeachersView.as_view()), name=\"teachers\")] django.view.View中的部分源码： 1234567891011121314151617181920212223242526272829303132333435363738394041class View: \"\"\" Intentionally simple parent class for all views. Only implements dispatch-by-method and simple sanity checking. \"\"\" http_method_names = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace'] def __init__(self, **kwargs): \"\"\" Constructor. Called in the URLconf; can contain helpful extra keyword arguments, and other things. \"\"\" # Go through keyword arguments, and either save their values to our # instance, or raise an error. for key, value in kwargs.items(): setattr(self, key, value) @classonlymethod def as_view(cls, **initkwargs): \"\"\"Main entry point for a request-response process.\"\"\" def view(request, *args, **kwargs): self = cls(**initkwargs) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs \"\"\"执行dispatch方法\"\"\" return self.dispatch(request, *args, **kwargs) '''''' def dispatch(self, request, *args, **kwargs): # Try to dispatch to the right method; if a method doesn't exist, # defer to the error handler. Also defer to the error handler if the # request method isn't on the approved list. if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed return handler(request, *args, **kwargs) rest_framework的使用 安装：pip install reset_framework 简单示例： 123456789101112131415from rest_framework.views import APIView# APIView继承的是django.views中的View，只是对request进行了再封装。class TestPage(APIView): \"\"\"试卷\"\"\" def get(self,request,*args,**kwargs): return HttpResponse(\"get\") def post(self,request,*args,**kwargs): return HttpResponse(\"post\") def put(self,request,*args,**kwargs): return HttpResponse(\"put\") def delete(self,request,*args,**kwargs): return HttpResponse(\"delete\") APIView源码讲解： APIView继承的也是django.view中的View，只是重写了dispatch()方法，对request进行了再封装。主要有四部分的操作 版本控制 验证用户是否登录 校验权限 访问频率限制 在以后逐渐讲解各部分的用法，感兴趣的可以先阅读源码。 部分源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class APIView(View): def dispatch(self, request, *args, **kwargs): \"\"\" `.dispatch()` is pretty much the same as Django's regular dispatch, but with extra hooks for startup, finalize, and exception handling. \"\"\" self.args = args self.kwargs = kwargs # 对原生的request进行再封装 # Request(request) # 原生的request = request._request request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: # 序列化request self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response '''''' # 序列化数据 def initial(self, request, *args, **kwargs): \"\"\" Runs anything that needs to occur prior to calling the method handler. \"\"\" self.format_kwarg = self.get_format_suffix(**kwargs) # Perform content negotiation and store the accepted info on the request neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg # Determine the API version, if versioning is in use. # 1、版本处理 version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted # 2、验证是否登录 self.perform_authentication(request) # 3、校验权限 self.check_permissions(request) # 4、限制访问频率 self.check_throttles(request) def initialize_request(self, request, *args, **kwargs): \"\"\" Returns the initial request object. \"\"\" parser_context = self.get_parser_context(request) # 对request进行再封装 return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) ```","categories":[],"tags":[]},{"title":"rest_framework四个封装详解","slug":"TreasureBox/python/rest_framework/2.rest_framework四个封装详解","date":"2022-05-19T01:14:40.397Z","updated":"2023-04-28T09:25:47.127Z","comments":true,"path":"2022/05/19/treasurebox/python/rest-framework/2.rest-framework-si-ge-feng-zhuang-xiang-jie/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/rest-framework/2.rest-framework-si-ge-feng-zhuang-xiang-jie/","excerpt":"","text":"REST framework的四个处理上篇文章中我们说到rest framework的APIView中对request进行了再封装以及校验，本篇文章主要从源码的角度分析这些方法，通过重写实现自己的功能模块快速开发。 我们接着看向下的流程。首先先看APIView中的关键源码，本篇主要讲解self.initial(request, *args, **kwargs)之后进行的操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class APIView(View): def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # 对原生的request进行再封装 # Request(request) # 原生的request = request._request request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: # 序列化request self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response def initial(self, request, *args, **kwargs): self.format_kwarg = self.get_format_suffix(**kwargs) neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg # 1、版本处理 version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # 2、验证是否登录 self.perform_authentication(request) # 3、校验权限 self.check_permissions(request) # 4、限制访问频率 self.check_throttles(request) def initialize_request(self, request, *args, **kwargs): \"\"\" Returns the initial request object. \"\"\" parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 一、用户登录认证在网站访问过程中，有些页面比如网站首页一般不需要用户进行登录，有些页面比如个人中心，用户必须登录之后才能访问，如果不使用统一的登录校验，就需要在每个视图中对用户是否登录加以校验，这样会出现很多重复的代码，所以我们可以实现一个用户登录校验装置进行身份校验，在需要的时候调用即可。 在常规方法中我们可以使用装饰器等实现，本篇主要介绍关于rest framework中自定义的用户登录验证，就是上边源码的2部分，通过重写这些登录认证，达到快速开发登录认证功能。 首先新建一个django项目，在model.py文件中建立数据库： 123456789101112131415class UserInfo(models.Model): user_type_choices = ( (1, \"普通用户\"), (2, \"VIP\"), (3, \"SVIP\"), ) username = models.CharField(null=True,max_length=32, verbose_name=\"用户名\",unique=True) password = models.CharField(null=True,max_length=32, verbose_name=\"密码\") user_type = models.IntegerField(choices=user_type_choices,verbose_name=\"用户类别\") def __str__(self): return self.usernameclass UserToken(models.Model): user = models.OneToOneField(\"UserInfo\",on_delete=models.CASCADE) token = models.CharField(max_length=32,verbose_name=\"token\") 该模型是我们用户登录和权限校验的基础，目前不进行密码加密。建立完数据库之后，首先在数据库中插入几条用户。 rest framework中登录类介绍 rest ramework中自定义了用户登录认证类，我们可以通过继承和方法重写这些认证类，实现用户的登录校验。 在上边代码中我们已经知道会执行perform_authentication()判断用户是否登录，接着向下看 12def perform_authentication(self, request): request.user 在perform_authentication中返回了request.user，我们已经知道这个request是封装之后的Request，接着看Request中的源代码，我们可以找到这部分代码： 123456@propertydef user(self): if not hasattr(self, '_user'): with wrap_attributeerrors(): self._authenticate() return self._user 可以发现，通过执行self._authenticate()进行接下来的校验 12345678910111213141516171819202122def _authenticate(self): # 循环每一个对象 for authenticator in self.authenticators: try: # 执行认证类的authenticate方法 # 1、如果出现异常，执行self._not_authenticated() # 2、如果没报错，接着向下执行 # 3、返回None代表没有进行赋值 user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator # 把元组的数据赋值给request # 第一个元组赋值给user # 第二个赋值给auth self.user, self.auth = user_auth_tuple return self._not_authenticated() 可以看到，通过循环self.authenticators，执行每一个的authenticate方法，接着我们去找self.authenticators的来源，来源于APIView对request进行第一次封装时候： 12345678910111213def initialize_request(self, request, *args, **kwargs): \"\"\" Returns the initial request object. \"\"\" parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 在上边代码中可以看到有authenticators，接着找self.get_authenticators() 12345def get_authenticators(self): \"\"\" Instantiates and returns the list of authenticators that this view can use. \"\"\" return [auth() for auth in self.authentication_classes] 可以看到最终的来源于一个列表推导式，我们接着看self.authentication_classes，在APIView的类变量中可以看到： 1authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 最终的来源是默认的配置文件中，最终源码中所有需要的组件已经全部拿到，这时我们就可以重写这些方法实现自己的登录校验。 重写登录认证类 知道了源代码的组件之后，我们就可以开始复写了。 先开发一个登录接口，下发token，作为是否登录的判定条件 123456789101112131415161718192021222324252627282930313233343536373839404142from rest_framework.views import APIViewfrom .models import UserInfo,UserTokenfrom django.http import JsonResponsedef md5(user): import hashlib import time ctime = str(time.time()) m = hashlib.md5(bytes(user,encoding=\"utf-8\")) m.update(bytes(ctime,encoding=\"utf-8\")) return m.hexdigest()class AuthView(APIView): #此时虽然没有使用登录认证，其实已经在默认使用了rest framework的的登录认证 def __init__(self,**kwargs): super().__init__(**kwargs) self.ret = { \"code\":10000, \"msg\":None } def post(self, request, *args, **kwargs): \"\"\"用户登录\"\"\" user = request._request.POST.get(\"username\") pwd = request._request.POST.get(\"password\") obj = UserInfo.objects.filter(username=user,password=pwd) if not obj: self.ret[\"code\"] = 10001 self.ret[\"msg\"] = \"用户名或者密码有误\" else: # 为登录的用户创建token token = md5(user) print(token) UserToken.objects.update_or_create( user = obj[0], defaults={\"token\":token} ) self.ret[\"code\"] = 10000 self.ret[\"msg\"] = \"login success\" self.ret[\"token\"] = token return JsonResponse(self.ret) 在登录校验类中进行判断 重写校验时，必须有这两个方法，详情参见上面源码流程。 1234567891011121314151617class Authtication(object): \"\"\"重写用户登录校验必须有这两个方法\"\"\" def authenticate(self,request): \"\"\"authenticate\"\"\" token = request._request.GET.get(\"token\") token_obj = UserToken.objects.filter(token=token).first() if not token_obj: raise exceptions.AuthenticationFailed(\"用户认证失败\") # 在rest_framework内部会将元组内容赋值给request以供后续使用 # 赋值在其他的类中就可以使用request.user,request.auth进行调用 return (token_obj.user, token_obj) # 认证失败时给浏览器返回的响应头 def authenticate_header(self,request): # print(request._request) # return 'Basic realm=\"%s\"'% \"api\" pass 局部使用认证类 认证类开发完成之后，就可以使用了，此时我们写一个新的接口，查看用户的个人中心，用户必须登录之后才能查看，这种校验方式是局部校验，只在某个类中添加authentication_classes属性，该属性必须为列表格式。 12345678910111213141516class Userinfo(APIView): \"\"\"用户详情\"\"\" # 加上用户登录校验 authentication_classes = [Authtication] def get(self,request,*args,**kwargs): ret = {\"code\": 1000, \"msg\": None, \"date\": None} return JsonResponse(ret) def post(self,request,*args,**kwargs): return HttpResponse(\"post\") def put(self,request,*args,**kwargs): return HttpResponse(\"put\") def delete(self,request,*args,**kwargs): return HttpResponse(\"delete\") 在全局配置认证类 全局校验时，需要添加在settings.py配置中，默认作用于全局，影响范围比较广。 123456# 配置全局用户认证REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\":[\"rest_source.utils.auth.Authtication\"], # 全局应用登录校验 \"UNAUTHENTICATED_USER\":None, # request.user = None \"UNAUTHENTICATED_TOKEN\":None, # request.auth = None} rest framework中自带的认证 BaseAuthentication是所有认证的基类，所以我们以后可以直接继承BaseAuthentication。 1from rest_framework.authentication import BaseAuthentication 对Authtication继承BaseAuthentication 12class Authtication(BaseAuthentication): pass 二、权限权限是系统开发不可缺少的部分，有些视图需要权限才能访问，有些不要权限。权限部分流程与登录认证类似，所以我们直接从重写权限认证开始。 重写权限类 123456789from rest_framework.permissions import BasePermissionclass MyPermission(BasePermission): message = \"您无权限查看！\" def has_permission(self,request,view): print(\"view\",view) if request.user.user_type != 3: return False return True 局部使用权限 1234567891011121314151617181920212223242526272829303132ORDER_DICT = { 1:{ \"name\":\"柚子\", \"price\":18, \"number\":10, \"address\":\"北京\", }, 2: { \"name\": \"苹果\", \"price\": 18, \"number\": 10, \"address\": \"北京\", }}class OrderView(APIView): \"\"\"订单\"\"\" \"\"\"只有svip才能看\"\"\" permission_classes= [MyPermission] def get(self,request,*args,**kwargs): ret = {\"code\":1000,\"msg\":None,\"data\":None} ret[\"data\"] = ORDER_DICT return JsonResponse(ret) def post(self,request,*args,**kwargs): return HttpResponse(\"post\") def put(self,request,*args,**kwargs): return HttpResponse(\"put\") def delete(self,request,*args,**kwargs): return HttpResponse(\"delete\") 全局配置权限 全局配置也是一样，需要在settings中添加配置： 1234567# 配置全局用户认证REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\":[\"rest_source.utils.auth.Authtication\"], # 全局应用登录校验 \"UNAUTHENTICATED_USER\":None, # request.user = None \"UNAUTHENTICATED_TOKEN\":None, # request.auth = None \"DEFAULT_PERMISSION_CLASSES\":[\"rest_source.utils.permission.MyPermission\"],# 全局应用权限校验} 三、访问频率限制(节流)访问频率限制一般用于网站反爬中，通过判断用户ip在某个时间段的访问频率，当超过某个频率时就先让用户等待一段时间，防止网站被恶意爬虫爬崩。 重写访问限制类 12345678910111213141516171819202122232425262728293031323334from rest_framework.throttling import BaseThrottleimport time# 定义全局变量存放访问频率VISIT_CODE = {}class VisitThrottle(BaseThrottle): \"\"\"60s只能访问3次\"\"\" def __init__(self): self.history = None def allow_request(self, request, view): ip = request._request.META.get(\"REMOTE_ADDR\") ctime = time.time() # 第一次访问，记录数据 if ip not in VISIT_CODE: VISIT_CODE[ip] = [ctime] return True # 判断第一次访问和最后一次访问的关系 history = VISIT_CODE[ip] self.history = history while history and ctime - 60 &gt; history[-1]: history.pop() if len(history) &lt; 3: history.insert(0, ctime) return True return False def wait(self): \"\"\"访问拒绝时返回需要等待的时间\"\"\" ctime = time.time() return int(60-(ctime-self.history[-1])) 局部使用 1234567891011121314151617181920212223242526272829303132333435363738class AuthView(APIView): # 设置局部不需要认证登录 authentication_classes = [] # 设置局部不需要鉴权 permission_classes= [] # 设置局部访问频率控制 throttle_classes = [VisitThrottle] def __init__(self,**kwargs): super().__init__(**kwargs) self.ret = { \"code\":10000, \"msg\":None } def post(self, request, *args, **kwargs): \"\"\"用户登录\"\"\" user = request._request.POST.get(\"username\") pwd = request._request.POST.get(\"password\") obj = UserInfo.objects.filter(username=user,password=pwd) if not obj: self.ret[\"code\"] = 10001 self.ret[\"msg\"] = \"用户名或者密码有误\" else: # 为登录的用户创建token token = md5(user) print(token) UserToken.objects.update_or_create( user = obj[0], defaults={\"token\":token} ) self.ret[\"code\"] = 10000 self.ret[\"msg\"] = \"login success\" self.ret[\"token\"] = token return JsonResponse(self.ret) 全局使用 全局使用时跟以上两个相同，加入到settings.py中： 123456789# 配置全局用户认证REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\":[\"rest_source.utils.auth.Authtication\"], # 全局应用登录校验 \"UNAUTHENTICATED_USER\":None, # request.user = None \"UNAUTHENTICATED_TOKEN\":None, # request.auth = None \"DEFAULT_PERMISSION_CLASSES\":[\"rest_source.utils.permission.MyPermission\"], # 全局应用权限校验 \"DEFAULT_THROTTLE_CLASSES\":[\"rest_source.utils.visitthrottle.VisitThrottle\"] # 全局应用ip限制} 系统自带的访问限制 系统源码位置： 1from rest_framework.throttling import BaseThrottle,SimpleRateThrottle 系统源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113class SimpleRateThrottle(BaseThrottle): \"\"\" A simple cache implementation, that only requires `.get_cache_key()` to be overridden. The rate (requests / seconds) is set by a `rate` attribute on the View class. The attribute is a string of the form 'number_of_requests/period'. Period should be one of: ('s', 'sec', 'm', 'min', 'h', 'hour', 'd', 'day') Previous request information used for throttling is stored in the cache. \"\"\" cache = default_cache timer = time.time cache_format = 'throttle_%(scope)s_%(ident)s' scope = None THROTTLE_RATES = api_settings.DEFAULT_THROTTLE_RATES def __init__(self): if not getattr(self, 'rate', None): self.rate = self.get_rate() self.num_requests, self.duration = self.parse_rate(self.rate) def get_cache_key(self, request, view): \"\"\" Should return a unique cache-key which can be used for throttling. Must be overridden. May return `None` if the request should not be throttled. \"\"\" raise NotImplementedError('.get_cache_key() must be overridden') def get_rate(self): \"\"\" Determine the string representation of the allowed request rate. \"\"\" if not getattr(self, 'scope', None): msg = (\"You must set either `.scope` or `.rate` for '%s' throttle\" % self.__class__.__name__) raise ImproperlyConfigured(msg) try: return self.THROTTLE_RATES[self.scope] except KeyError: msg = \"No default throttle rate set for '%s' scope\" % self.scope raise ImproperlyConfigured(msg) def parse_rate(self, rate): \"\"\" Given the request rate string, return a two tuple of: &lt;allowed number of requests&gt;, &lt;period of time in seconds&gt; \"\"\" if rate is None: return (None, None) num, period = rate.split('/') num_requests = int(num) duration = {'s': 1, 'm': 60, 'h': 3600, 'd': 86400}[period[0]] return (num_requests, duration) def allow_request(self, request, view): \"\"\" Implement the check to see if the request should be throttled. On success calls `throttle_success`. On failure calls `throttle_failure`. \"\"\" if self.rate is None: return True self.key = self.get_cache_key(request, view) if self.key is None: return True self.history = self.cache.get(self.key, []) self.now = self.timer() # Drop any requests from the history which have now passed the # throttle duration while self.history and self.history[-1] &lt;= self.now - self.duration: self.history.pop() if len(self.history) &gt;= self.num_requests: return self.throttle_failure() return self.throttle_success() def throttle_success(self): \"\"\" Inserts the current request's timestamp along with the key into the cache. \"\"\" self.history.insert(0, self.now) self.cache.set(self.key, self.history, self.duration) return True def throttle_failure(self): \"\"\" Called when a request to the API has failed due to throttling. \"\"\" return False def wait(self): \"\"\" Returns the recommended next request time in seconds. \"\"\" if self.history: remaining_duration = self.duration - (self.now - self.history[-1]) else: remaining_duration = self.duration available_requests = self.num_requests - len(self.history) + 1 if available_requests &lt;= 0: return None return remaining_duration / float(available_requests) 通过查看源码可以知道关键的属性有scope，和关键方法get_cache_key，这是rest framework预留给开发人员的参数和方法，我们可以通过重写这两个方法快速实现节流功能。 重写系统方法 1234567from rest_framework.throttling import SimpleRateThrottleclass VisitThrottle1(SimpleRateThrottle): \"\"\"仿写系统自带的节流：未登录用户的访问限制\"\"\" scope = \"Youzi\" def get_cache_key(self, request, view): return self.get_ident(request) 全局应用配置： 12345678910# 配置全局用户认证REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\":[\"rest_source.utils.auth.Authtication\"], # 全局应用登录校验 \"UNAUTHENTICATED_USER\":None, # request.user = None \"UNAUTHENTICATED_TOKEN\":None, # request.auth = None \"DEFAULT_PERMISSION_CLASSES\":[\"rest_source.utils.permission.MyPermission\"], # 全局应用权限校验 # \"DEFAULT_THROTTLE_CLASSES\":[\"rest_source.utils.visitthrottle.VisitThrottle\"] # 全局应用ip限制 \"DEFAULT_THROTTLE_CLASSES\":[\"rest_source.utils.visitthrottle.VisitThrottle1\"], # 全局应用ip限制 \"DEFAULT_THROTTLE_RATES\":{\"youzi\":\"3/m\"}, # 参数固定格式} 重写已经登录的用户限制 123456class UserThrottle1(SimpleRateThrottle): \"\"\"仿写系统自带的节流：已经登录的用户访问限制\"\"\" scope = \"YouziUser\" def get_cache_key(self, request, view): return self.get_ident(request) 全局应用多个，已经登录的每分钟可以访问10次，没有登陆的使用局部，每分钟可以访问三次： 12345678910111213# 配置全局用户认证REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\":[\"rest_source.utils.auth.Authtication\"], # 全局应用登录校验 \"UNAUTHENTICATED_USER\":None, # request.user = None \"UNAUTHENTICATED_TOKEN\":None, # request.auth = None \"DEFAULT_PERMISSION_CLASSES\":[\"rest_source.utils.permission.MyPermission\"], # 全局应用权限校验 # \"DEFAULT_THROTTLE_CLASSES\":[\"rest_source.utils.visitthrottle.VisitThrottle\"] # 全局应用ip限制 \"DEFAULT_THROTTLE_CLASSES\":[\"rest_source.utils.visitthrottle.UserThrottle1\"], # 全局应用ip限制 \"DEFAULT_THROTTLE_RATES\":{ \"Youzi\":\"3/m\", \"YouziUser\":\"10/m\" },} 局部应用每分钟可以访问3次： 123456789101112131415161718class AuthView(APIView): # 设置局部不需要认证登录 authentication_classes = [] # 设置局部不需要鉴权 permission_classes = [] throttle_classes = [VisitThrottle1] def __init__(self, **kwargs): super().__init__(**kwargs) self.ret = { \"code\": 10000, \"msg\": None } def post(self, request, *args, **kwargs): \"\"\"用户登录\"\"\" pass 四、版本控制在代码开发的过程中，往往会有版本的迭代功能， 在代码开发过程中，阅读源码是不可缺少的部分，希望通过本篇文章可以帮助您提高阅读源码的兴趣和能力。最后把一句话送给读者：Either outstanding or out. （要么出众，要么出局）。 def init(self, **kwargs): super().init(**kwargs) self.ret = { “code”: 10000, “msg”: None } def post(self, request, *args, **kwargs): \"\"\"用户登录\"\"\" pass ``` 四、版本控制在代码开发的过程中，往往会有版本的迭代功能， 在代码开发过程中，阅读源码是不可缺少的部分，希望通过本篇文章可以帮助您提高阅读源码的兴趣和能力。最后把一句话送给读者：Either outstanding or out. （要么出众，要么出局）。","categories":[],"tags":[]},{"title":"数据类型和运算符","slug":"TreasureBox/python/python基础/1.基础/2.数据类型和运算符","date":"2022-05-19T01:14:40.396Z","updated":"2023-04-28T09:25:47.133Z","comments":true,"path":"2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/2.shu-ju-lei-xing-he-yun-suan-fu/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/2.shu-ju-lei-xing-he-yun-suan-fu/","excerpt":"","text":"数据类型和运算符一、变量和类型在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。首先介绍几种基础的数据类型： 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型：字符串是以单引号或双引号括起来的任意文本，比如'hello'和\"hello\",字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。实际上，这个类型并不常用。 变量命名 对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 硬性规则： 变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。 大小写敏感（大写的a和小写的A是两个不同的变量）。 不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。 PEP 8要求： 用小写字母拼写，多个单词用下划线连接。 受保护的实例属性用单个下划线开头。 私有的实例属性用两个下划线开头。 变量的使用 python的变量不需要声明数据类型，使用时直接使用**=**进行赋值。使用变量保存数据： 123456\"\"\"version:0.1Author:youzi\"\"\"a = 100b = 200 查看变量的数据类型 python中提供了type()函数用于查看变量的数据类型，id()函数查看变量的内存地址。示例： 12345678910111213\"\"\"version:0.1Author:youzi\"\"\"number1 = 100number2 = 200.01bool1 = Truestr1 = \"hello\"print(type(number1)) # intprint(type(number2)) # floatprint(type(bool1)) # boolprint(type(str1)) # strprint(id(str1)) python中内置了很多函数可以帮助我们对类型进行转换，常用的有： - `int()`：将一个数值或字符串(字符串必须为数字)转换成整数，可以指定进制。 - `float()`：将一个字符串(字符串中必须为数字)转换成浮点数。 - `str()`：将指定的对象转换成字符串形式，可以指定编码。 - `chr()`：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 保存键盘中输入的数据 python中内置了input函数用来让用户输入，输入的内容都默认为str类型，使用时对类型进行转化： 1234567891011121314\"\"\"使用input()函数获取键盘输入(字符串)使用int()函数将输入的字符串转换成整数使用print()函数输出变量中保存的内容Version: 0.1Author: youzi\"\"\"a = int(input('a = '))b = int(input('b = '))c = input(\"c = \")print(a,type(a))print(b,type(b))print(c,type(c)) 二、运算符Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，运算符的优先级指的是多个运算符同时出现时，先做什么运算然后再做什么运算。如果不确定运算符的优先级，可以使用小括号，小括号的优先级最高。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ ` ` &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ` = ^= &gt;&gt;= &lt;&lt;=` 赋值运算符 赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。 1234567891011\"\"\"赋值运算符和复合赋值运算符Version: 0.1Author: youzi\"\"\"a = 10b = 3a += b # 相当于：a = a + ba *= a + 2 # 相当于：a = a * (a + 2)print(a) # 算一下这里会输出什么 比较运算符和逻辑运算符 比较运算符有的地方也称为关系运算符，包括==、!=、&lt;、&gt;、&lt;=、&gt;=。唯一需要提醒的是比较相等用的是==，请注意这个地方是两个等号，因为=是赋值运算符，==才是比较相等的比较运算符。比较运算符会产生布尔值，要么是True要么是False。 逻辑运算符有三个，分别是and、or和not。and的优先级高于or。and字面意思是“而且”，所以and运算符会连接两个布尔值，如果两个布尔值都是True，那么运算的结果就是True；左右两边的布尔值有一个是False，最终的运算结果就是False。如果and左边的布尔值是False，不管右边的布尔值是什么，最终的结果都是False，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在and运算符左边为False的情况下，右边的表达式根本不会执行。or字面意思是“或者”，所以or运算符也会连接两个布尔值，如果两个布尔值有任意一个是True，那么最终的结果就是True。当然，or运算符也是有短路功能的，在它左边的布尔值为True的情况下，右边的表达式根本不会执行。not运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，后面的布尔值如果是True运算结果就是False，而后面的布尔值如果是False则运算结果就是True。 123456789101112131415161718\"\"\"比较运算符和逻辑运算符的使用Version: 0.1Author: 柚子\"\"\"flag0 = 1 == 1flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not (1 != 2)print('flag0 =', flag0) # flag0 = Trueprint('flag1 =', flag1) # flag1 = Trueprint('flag2 =', flag2) # flag2 = Falseprint('flag3 =', flag3) # flag3 = Falseprint('flag4 =', flag4) # flag4 = Trueprint('flag5 =', flag5) # flag5 = False 123456789101112131415161718\"\"\"比较运算符和逻辑运算符的使用Version: 0.1Author: 骆昊\"\"\"flag0 = 1 == 1flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not (1 != 2)print('flag0 =', flag0) # flag0 = Trueprint('flag1 =', flag1) # flag1 = Trueprint('flag2 =', flag2) # flag2 = Falseprint('flag3 =', flag3) # flag3 = Falseprint('flag4 =', flag4) # flag4 = Trueprint('flag5 =', flag5) # flag5 = False 说明： ​ 比较运算符的优先级高于赋值运算符，所以在：flag0 = 1 == 1时候，flag0的值为True。print函数想输出多个值时，多个值使用英文逗号隔开。 练习 看程序写结果，总结用法： 123456789101112\"\"\"使用input()函数获取键盘输入(字符串)使用int()函数将输入的字符串转换成整数使用print()函数输出带占位符的字符串Version: 0.1Author: youzi\"\"\"a = int(3.4)b = int(3.5)c = int(\"12\")print(a,b,c) 输入圆的半径计算计算周长和面积。 1234567891011\"\"\"输入半径计算圆的周长和面积Version: 0.1Author: 柚子\"\"\"radius = float(input('请输入圆的半径: '))perimeter = 2 * 3.14 * radiusarea = 3.14 * radius * radiusprint('周长: %.2f' % perimeter)print('面积: %.2f' % area) 说明：%.2f是python小数类型的占位符，以后会有详细用法。 判断年份是不是闰年 闰年：能被4整除且不能被100整除，或者能被400整除的。 1234567891011\"\"\"输入年份 如果是闰年输出True 否则输出FalseVersion: 0.1Author: 柚子\"\"\"year = int(input('请输入年份: '))# 如果代码太长写成一行不便于阅读 可以使用\\对代码进行折行is_leap = year % 4 == 0 and year % 100 != 0 or \\ year % 400 == 0print(is_leap) 说明：之前提到过and的优先级比or高。 is_leap = year % 4 == 0 and year % 100 != 0 or year % 400 == 0 print(is_leap) 说明：之前提到过`and`的优先级比`or`高。","categories":[],"tags":[]},{"title":"顺序结构和分支结构","slug":"TreasureBox/python/python基础/1.基础/3.顺序结构和分支结构","date":"2022-05-19T01:14:40.396Z","updated":"2023-04-28T09:25:47.136Z","comments":true,"path":"2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/3.shun-xu-jie-gou-he-fen-zhi-jie-gou/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/3.shun-xu-jie-gou-he-fen-zhi-jie-gou/","excerpt":"","text":"顺序结构和分支结构代码中的结构共分为三种，本篇主要讲解顺序结构和分支结构。： 顺序结构 分支结构 循环结构 一、顺序结构 顺序结构介绍 顺序结构是代码执行的基础，在同一个代码块中，代码自上而下按顺序执行，这种顺序就被称为顺序结构。 案例： 运行代码时会发现先输出hello world，然后等待用户输入，最后输出用户输入的内容。这个就是顺序结构。 1234567891011\"\"\"使用input()函数获取键盘输入(字符串)使用int()函数将输入的字符串转换成整数使用print()函数输出带占位符的字符串Version: 0.1Author: 柚子\"\"\"print(\"hello world\")a = inout(\"请输入：\")print(a) 二、分支结构当顺序结构不能满足需求时，比如当玩家在闯关时，积累到一定分数时就进入下一关，如果玩家积分太低，就终止游戏，这时候就要使用分支结构。在python中的分支结构主要有if、elif、else关键字。像if和else就是专门构造分支结构的关键字，不能用于当作变量名。 单分支结构 1234567891011\"\"\"用户身份验证Version: 0.1Author: 柚子\"\"\"username = input('请输入用户名: ')password = input('请输入密码: ')# 用户名是admin且密码是123456则身份验证成功否则身份验证失败if username == 'admin' and password == '123456': print('身份验证成功!') 练习：输入工资判断可以买的车型 123456789salary=int(input(\"请输入你的工资：\"))if salary&gt;=10000 and salary&lt;20000: print('买辆迈腾')if salary&gt;=20000 and salary&lt;30000: print('速腾')if salary&gt;=30000: print('买辆A6')if salary&lt;=3000: print('电动72 35v 50迈，续航：90') 双分支结构 12345678910111213\"\"\"用户身份验证Version: 0.1Author: 柚子\"\"\"username = input('请输入用户名: ')password = input('请输入密码: ')# 用户名是admin且密码是123456则身份验证成功否则身份验证失败if username == 'admin' and password == '123456': print('身份验证成功!')else: print(\"校验失败\") 多分支介绍 使用if…else…elif。 123456789score=95if score &gt;= 90: print(\"优秀\")elif score&gt;80: print(\"良好\")elif score&gt;60: print(\"一般\")else: print(\"不及格\") 嵌套分支 案例：用户输入购买的西红柿单价和数量，计算总价后，用户输入vip等级，根据vip等级返回对应的结果。 1234567891011121314151617181920price=float(input('请输入西红柿单价：'))num=float(input('请输入购买数量：'))total=price*numif total&gt;=50: level=input('请输入vip级别：') if level == '1': total *= 0.8 print('享受总金额打八折优惠，金额为：%.2f' % total) elif level == '2': total=int(total) total=total-total%10 print('享受抹零优惠，金额为：%d' % total) elif level == '3': print('享受去小数优惠，金额为：%d' % total)else: sex=input('请输入性别:') if sex == '男': print('赠送玩具劳斯莱斯一个') elif sex == '女': print('赠送小猫一只') elif sex == '女': print('赠送小猫一只')","categories":[],"tags":[]},{"title":"循环结构","slug":"TreasureBox/python/python基础/1.基础/4.循环结构","date":"2022-05-19T01:14:40.396Z","updated":"2023-04-28T09:25:47.136Z","comments":true,"path":"2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/4.xun-huan-jie-gou/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/4.xun-huan-jie-gou/","excerpt":"","text":"循环结构应用场景：当我们在编写代码时，如果有一个需求是输出10次”hello world“，这时候我们可以直接写十次print(\"hello world\")。但是当我们需要些十万次”hello world”呢？肯定不会直接写十万行print(\"hello world\")。这时候我们就需要用到循环语句了。 python中的循环语句分为两种语法： for…in while… 循环的条件： 初始值 控制条件(循环结束的条件) 步长 一、for…in循环如果知道要迭代的次数或者要对某一个迭代器对象进行循环，这时候就可以使用for循环。 1234567891011\"\"\"用for循环实现1~10求和Version: 0.1Author: 柚子\"\"\"sum = 0for x in range(10): sum += xprint(sum) 说明：range(1, 101)可以用来构造一个从1到100的范围数据，通过x对所有的数据进行循环取出，依次进行叠加。 附录：range()函数的使用 range(101)：可以用来产生0到100范围的整数，需要注意的是取不到101。 range(1, 101)：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。 range(1, 101, 2)：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。 range(100, 0, -2)：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。 练习1：1~100之间的偶数求和1234567891011\"\"\"用for循环实现1~100之间的偶数求和Version: 0.1Author: 柚子\"\"\"sum = 0for x in range(2, 101, 2): sum += xprint(sum) 练习2：使用for循环判断1000以内的水仙花数123456789101112\"\"\"水仙花数：个位数的3次方加十位数的3次方加百位数的3次方等于该数本身。Version: 0.1Author: 柚子\"\"\"for i in range(100,1000): gewei = str(i)[2] shiwei = str(i)[1] baiwei = str(i)[0] if int(gewei)**3+int(shiwei)**3+int(baiwei)**3==i: print(i) 二、while循环如果要构造的循环不知道具体要循环的次数，这时候可以使用while循环进行控制。无限循环一般使用while True或while 1。 语法格式： 123456\"\"\"由初始值，结束条件，步长三部分组成\"\"\"num = 0while num&lt;10: num+=1 练习1：根据用户输入的金额输出可以买的西瓜的个数 1234567891011\"\"\"每个西瓜10元钱，每买一个西瓜，减去10元钱Version: 0.1Author: 柚子\"\"\"money = int(input('请输入金额：'))while money &gt;= 10: print('买一个西瓜') money -= 10 print('剩余', money, '元') 三、break和continuebreak用于终止循环，continue用于终止本次循环，继续进行下次循环，终止的都是最近的循环。 看代码分析区别 123456789for i in range(5): if i==2: break print(i) for i in range(5): if i==2: continue print(i) 练习1：猜数字游戏random模块用于生成随机数，使用请参考random模块详解。 123456789101112131415161718192021222324\"\"\"猜数字游戏： 先随机生成一个数字，然后用户开始猜，每次给用户一个提示大或者小了。 Version: 0.1Author: 柚子\"\"\"import randomanswer = random.randint(1, 100)counter = 0while True: counter += 1 number = int(input('请输入: ')) if number &lt; answer: print('大一点') elif number &gt; answer: print('小一点') else: print('恭喜你猜对了!') breakprint('你总共猜了%d次' % counter)if counter &gt; 7: print('你的智商余额明显不足') 练习2：猜拳游戏在案例中使用了列表的语法，可以试用下标对列表取值。format是python的字符串格式化输出语法，字符串中用{}站位，后边跟上.format()。 1234567891011121314151617181920212223242526272829303132\"\"\"猜拳游戏： 系统随机生成0,1,2分别代表拳，剪刀，布。 Version: 0.1Author: 柚子\"\"\"import randomnum = 1ying_num = 0shu_num = 0while num &lt;= 3: if shu_num == 2 or ying_num == 2: break user = int(input('请出拳 0（石头） 1（剪刀） 2（布）')) if user &gt; 2: print('不能出大于2的值') else: data = ['石头', '剪刀', '布'] com = random.randint(0, 1) print(\"您出的是{}，电脑出的是{}\".format(data[user], data[com])) if user == com: print('平局') elif (user == 0 and com == 1) or (user == 1 and com == 2) or (user == 2 and com == 0): print('你赢了') ying_num += 1 else: print('你输了') shu_num += 1 num += 1 和分支结构一样，循环结构也可以进行嵌套使用：练习3：输出乘法口诀表12345678910\"\"\"使用双重循环生成99乘法表Version: 0.1Author: 柚子\"\"\"for i in range(1,10): for j in range(1,i+1): print(j,\"*\",i,\"=\",i*j,end=\" \") print() 四、for…else和while….else..的用法当for和else连用或者while和else连用时。如果循环遇到break结束时，就会执行else中的语句。 示 例1：12345678910\"\"\"此时没有break，else就会执行Version: 0.1Author: 柚子\"\"\"for i in range(5): print(i)else: print(\"else\") 示 例2：1234567891011\"\"\"此时执行了break，else就会执行Version: 0.1Author: 柚子\"\"\"for i in range(5): print(i) breakelse: print(\"else\") 练习1：判断2-100的质数123456789101112\"\"\"只能被1和它本身整除的数为质数Version: 0.1Author: 柚子\"\"\"for i in range(2,100): for j in range(2,i): if i%j==0: break else: print(i) 练习2：打印三角形图案12345*************** 12345 * ** *** ********* 12345 * *** ***** **************** 答案：12345678910111213141516171819202122232425262728\"\"\"打印三角形图案Version: 0.1Author: 柚子\"\"\"row = int(input('请输入行数: '))for i in range(row): for _ in range(i + 1): print('*', end='') print()for i in range(row): for j in range(row): if j &lt; row - i - 1: print(' ', end='') else: print('*', end='') print()for i in range(row): for _ in range(row - i - 1): print(' ', end='') for _ in range(2 * i + 1): print('*', end='') print() ow): if j &lt; row - i - 1: print(‘ ‘, end=’’) else: print(‘*’, end=’’) print() for i in range(row): for _ in range(row - i - 1): print(‘ ‘, end=’’) for _ in range(2 * i + 1): print(‘*’, end=’’) print()","categories":[],"tags":[]},{"title":"组合数据类型","slug":"TreasureBox/python/python基础/1.基础/5.组合数据类型","date":"2022-05-19T01:14:40.396Z","updated":"2023-04-28T09:25:47.138Z","comments":true,"path":"2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/5.zu-he-shu-ju-lei-xing/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/5.zu-he-shu-ju-lei-xing/","excerpt":"","text":"组合数据类型当基本的数据类型不能完全表示所有的数据时，这时候就会用到组合数据类型。学习组合数据类型之前，需要知道python的两个内置神级函数dir()和help()。 dir()：查看某个对象支持的操作方法，示例：dir(list) help()：查看某个方法的使用方式，示例：help(print) 一、列表list列表是组合数据类型中的一种，可以按照有位置顺序的方式、存储不同数据类型、重复的多个数据。列表和变量的使用方式一样，都需要先声明，再使用。 列表的声明 声明空列表 123456789101112\"\"\"声明一个空列表Version: 0.1Author: 柚子\"\"\"# 1、使用python中的关键字声明【推荐方式】names = list()# 2、直接使用[]声明ages = [] 声明非空列表 1234567891011121314\"\"\"声明一个非空列表Version: 0.1Author: 柚子\"\"\"# 1、直接声明【推荐方式】names = [\"柚子\",\"西瓜\",\"香蕉\"]# 2、使用list()转换s = \"hello\"s2 = list(s) # 类型转换~将其他类型转换成列表数据print(s2); #[\"h\", \"e\", \"l\", \"l\",\"o\"] 列表的操作 列表的操作主要分为四种：增加、修改、查询、删除。除此之外还有一些其他的操作需要了解。 增加 12345678910111213141516\"\"\"列表增加操作主要有： append(object)： 在列表末尾添加数据 insert(index,object) 在列表某个位置插入数据，超出列表长度不报错 extend(iterable) 添加一个可迭代对象Version: 0.1Author: youzi\"\"\"names = [\"柚子\", \"西瓜\"]names.append(\"榴莲\")print(names) #['柚子', '西瓜', '榴莲']names.insert(10, \"桃子\")print(names) #['柚子', '西瓜', '榴莲', '桃子']names.extend(\"苹果\")print(names) #['柚子', '西瓜', '榴莲', '桃子', '苹', '果'] 修改 修改列表中的数据直接使用L[下标]的方式进行修改，下标从0开始。 123names = [\"柚子\", \"西瓜\"]names[0] = \"哈密瓜\"print(names) #['哈密瓜', '西瓜',] 查询 查询数据有：查看所有数据，查看某个数据的位置，查看某个数据的次数三种。 12345678910111213141516\"\"\"index和count的用法\"\"\"names = [\"柚子\", \"西瓜\"]# 通过循环查看列表中的每一个数据for name in names: print(name)# 查看某个位置的数据print(names[0]) # 查看某个数据的第一次出现的位置，找不到会报错print(names.index(\"西瓜\")) #1# 查看某个数据出现的次数print(names.count(\"西瓜\")) #1 删除 删除操作也有两种，remove,pop, 1234567891011121314151617181920\"\"\"remove(object) 删除某个数据，数据不在时会报错pop(index) 按下标删除，不写时默认删除最后一个，超出列表下表会报错del L[index] 使用python的del删除clear() 清空列表\"\"\"names = ['哈密瓜', '西瓜', '榴莲', '桃子',\"柚子\", \"核桃\"]names.remove(\"西瓜\")print(names)names.pop()print(names)names.pop(0)print(names)del names[0]print(names)names.clear()print(names) 其它操作 操作 描述 L.sort() 在原列表的基础上进行排序 L.reverse() 对列表进行反转 L.copy() 生成一个浅拷贝对象 len(L) 获取列表中数据的个数 max(L) 获取列表中的最大值 min(L) 获取列表中的最小值 L[m:n:x] 列表的切片从m位置开始，切到n，间隔为x示例：L[:]：切取整个列表数据L[1:]:从1开始切到最后一位L[1:3:2]:从1开始切到3，间隔为2切片时支持负索引，最后一位为-1 案例：蜃楼用户管理系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445\"\"\"用户信息录入系统 开发步骤 1、定义一个首页界面[告诉我们要做什么] 2、通过列表保存数据 3、通过用户输入的选项，执行判断 4、实现各项的功能 5、测试功能运行是否正确 6、BUG 完善\"\"\"# 保存所有伙伴的列表sheng_lou = list()while True: # 首页 print(\"欢迎来到蜃楼用户管理系统\") print(\"~ * ~ * ~ * ~ * ~ * ~ * ~ * ~ * ~ * ~ * ~\") print(\" 1、查看所有小伙伴\") print(\" 2、录入个人信息\") print(\" 3、查看个人信息\") print(\" 4、退出系统\") print(\"~ * ~ * ~ * ~ * ~ * ~ * ~ * ~ * ~ * ~ * ~\") # 用户输入选项 c = input(\"请输入您的选项:\") if c == \"1\": # 遍历所有小伙伴 for stu in sheng_lou: print(\"小伙伴：\", stu) print(\"~~~~~~~~~~~~~~~~~~~~~~~~~\") input(\"查看完成按任意键返回首页.\") elif c == \"2\": # 提示用户输入姓名 name = input(\"请输入昵称：\") if name in sheng_lou: input(\"该昵称已经存在，请使用其他昵称录入\") continue # 保存昵称:列表的末尾追加 sheng_lou.append(name) input(\"录入完成，按任意键返回首页...\") elif c == \"3\": # 提示用户输入要查看的昵称 nickname = input(\"请输入要查看的昵称：\") if nickname in sheng_lou: # 成员成员运算符，判断昵称是否包含在列表中[True/False] print(\"该成员已经在大厅中.\") else: print(\"该昵称代表的成员没有在大厅中.\") input(\"查看个人信息，正在升级中...\") elif c == \"4\": input(\"退出系统，保存好个人数据，按任意键退出\") exit(1) 二、元组tuple元组也是组合数据类型中的一种，可以有顺序的存放可重复的数据、可以是不同类型的多个数据，数据一旦保存之后，不允许改动,可以使用for循环遍历，跟列表相同。 元组的声明 声明空元组 因为元组不能修改，声明空元组没有任何意义。 12t = tuple() # 声明了一个元组[空] - 推荐t2 = () # 声明了一个元组[空] - 很容易和四则运算的小括号混淆 声明一个元素的元组 12345t = tuple([“a”]) # 这是包含一个数据的元素，不推荐的语法~ 类型转换t2 = (“a”, ) # 声明了只包含一个元素的元组~一定要那个逗号print(type(t2)) # tuplet3 = (“a”) # 这不是元组，括号~就是四则运算的括号~t3=”a”print(type(t3)) # str 声明多个元素的元组 12t = (“春”, “夏”, “秋”, “冬”) # 声明了一个包含四个数据的元组，推荐t2 = tuple([“春”, “夏”, “秋”, “冬”]) # 使用tuple()转换-不推荐，繁琐 元组的操作 123456789101112#-*-coding:utf-8 -*-\"\"\"count(object):某个数据出现的次数index(object):某个数据第一次出现的下标len(T):元组的长度T[下标]:查看某个下标的数据\"\"\"t = (\"春\", \"夏\", \"秋\", \"冬\")print(t.count(\"春\"))print(t.index(\"春\"))print(len(t)) 使用场景 元组因为不能修改，经常存储固定不变的数据，比如一年的四季，一年的12个月份等。 三、集合set集合set是组合类型中的一种，集合中可以存放没有顺序的、不能重复的、任意数据类型的数据，多个数据之间用逗号隔开，不能使用for循环遍历。 集合的声明 声明空集合 1234\"\"\"只能使用set()声明\"\"\"s1 = set() 声明非空集合 1234# 推荐的非空集合的声明方式s1 = {“A”, “b”, “C”, “d\"}# 另一种声明方式~繁琐~ 列表做了数据类型转换，得到了一个集合！ s2 = set([“a”, “b”, “c”, “d”]) 说明：集合具有自动去重功能，如果其中的数据有重复的，集合会自动去重。 集合的操作 集合中已经存放了一些数据，那么对于集合的操作都有哪些处理方式呢？ 集合的特点~没有顺序的，不可以重复，不同数据类型(可以)，多个数据 。 12345678910111213141516171819202122232425262728\"\"\"单个集合操作： 'add' 增加, 'clear '清空集合, 'copy' 复制一个集合, 'pop', 随机删除一个集合中的数据[集合中的数据没有顺序] 'remove', 删除一个指定的数据，如果数据不存在就会报错 'discard', 删除一个指定的数据，如果数据不存在什么都不做两个集合操作 'isdisjoint', 检验两个集合是否有交集，如果没有就返回True 'issubset', s1 集合中的数据是不是包含在 s2 集合中，等价于 s1 &lt; s2 'issuperset', s1 集合是不是包含了 s2 集合中的数据，等价于 s1 &gt; s2 'difference', 获取 s1 集合和 s2 集合的差集 'difference_update', 获取 s1 和 s2 的差集并将结果数据更新到 s1 中 'intersection', 获取 s1 集合和 s2 集合的交集 'intersection_update', 获取 s1 和 s2 的交集并将结果更新到 s1 中 'symmetric_difference', 获取 s1 和 s2 共同的差集 'symmetric_difference_update', 获取共同的差集并更新到 s1 中 'union', 获取 s1 和 s2 的并集 'update' 获取 s1 和 s2 的并集，并将数据更新给 s1\"\"\"s1 = {1}s1.add(2)print(s1) 使用场景 集合主要用户去重操作和求两组数据的交集或者并集之类的操作。 四、字典dict字典的概念类似日常使用的《中华字典》，通过前边的页码找到后边对应的数据。前边的页码在python中对应字典的key，后边的页码对应python中的value。字典中的数据都是以键值对的形式存在。 字典的特点 字典的格式为{key1:value1,key2:value2}，其中key不能重复，且不能是可以修改的数据类型，value可以重复，数据类型没有限制。 字典的声明 python中使用dict表示字典。 空字典 12345# 1、使用dict(),推荐使用dict1 = dict()# 2、使用{}声明dict2 = {} 非空字典 12user = {“username”: “admin”, “password”: “123456”} #推荐使用 可读性强user2 = dict([(“username”, “admin”), (“password”, “123456”)]) 字典的使用 1234567891011'clear', 清空字典'copy', 复制字典'fromkeys', 根据给定的 数据作为 key 初始化一个字典'get', 根据一个 key 获取对应的 value 数据,key不存在时得到None'items', 获取字典中的所有键值对数据'keys', 获取字典中的所有 key 数据'pop', 根据 key 删除指定的一个键值对'popitem', 随机删除一个键值对'setdefault', 如果 key 不存在增加一个数据，如果 key 存在什么都不做'update', 如果 key 不存在增加一个数据，如果 key 存在更新这个数据'values' 获取字典中的所有的 value 数据 查看数据 12345678dct={'username': 'waltz', 'nickname': '柚子'}print(dct.items()) # dict_items([('username', 'waltz'), ('nickname', '柚子')])print(dct.keys()) # dict_keys(['username', 'nickname'])print(dct.values()) #dict_values(['waltz', '柚子'])print(dct.get(\"nickname\")) #'柚子'print(dct.get(\"age\")) # Noneprint(dct.get(\"age\",\"西瓜\")) # 西瓜print(dct[\"nickname\"]) #'柚子' 修改数据 12345678dct={'username': 'waltz', 'nickname': '柚子'}# 修改数据dct[\"nickname\"] = \"桃子\"dct.update({\"username\":\"youzi\"})print(dct)dct.setdefault(\"username\", \"xigua\")dct.setdefault(\"age\", 24)print(dct) 增加数据 123456D.setdefault(key, value)只有 key 在字典中不存在的情况下，新增一个键值对数据D.update({key:value})只有 key 在字典中不存在的情况下，新增一个/多个键值对数据D[key] = value 只有 key 在字典中不存在的情况下，新增一个键值对数据 删除数据 1234567891011121314151617\"\"\"pop() 通过key删除值，可以接收返回值，，key不存在时会报错popitem() 随机删除一个键值对，可以接收元组形式的返回值clear() 清空字典 \"\"\"# 删除数据dct={'username': 'waltz', 'nickname': '柚子', \"age\":24}value = dct.pop(\"username\")print(value) # waltzprint(dct)result = dct.popitem()print(result) #('age', 24)r = dct.clear()print(r)print(dct) 遍历字典 字典在使用循环遍历时，默认遍历字典中的key。 123456789dct={'username': 'waltz', 'nickname': '柚子', \"age\":24}for key in dct: print(key,dct[key])for value in dct.values(): print(value)for key,value in dct.items(): print(key,value) t(r) print(dct) 1234567891011121314154. #### 遍历字典 字典在使用循环遍历时，默认遍历字典中的key。 ```python dct={'username': 'waltz', 'nickname': '柚子', \"age\":24} for key in dct: print(key,dct[key]) for value in dct.values(): print(value) for key,value in dct.items(): print(key,value)","categories":[],"tags":[]},{"title":"字符串和案例练习","slug":"TreasureBox/python/python基础/1.基础/6.字符串和案例练习","date":"2022-05-19T01:14:40.396Z","updated":"2023-04-28T09:25:47.133Z","comments":true,"path":"2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/6.zi-fu-chuan-he-an-li-lian-xi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/6.zi-fu-chuan-he-an-li-lian-xi/","excerpt":"","text":"字符串和案例练习一、字符串的使用二、案例练习","categories":[],"tags":[]},{"title":"异常结构","slug":"TreasureBox/python/python基础/2.异常处理/1.异常结构","date":"2022-05-19T01:14:40.396Z","updated":"2023-04-28T09:25:47.131Z","comments":true,"path":"2022/05/19/treasurebox/python/python-ji-chu/2.yi-chang-chu-li/1.yi-chang-jie-gou/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/python-ji-chu/2.yi-chang-chu-li/1.yi-chang-jie-gou/","excerpt":"","text":"异常结构","categories":[],"tags":[]},{"title":"pip不能使用","slug":"TreasureBox/python/pip不能使用","date":"2022-05-19T01:14:40.395Z","updated":"2023-04-28T09:25:47.115Z","comments":true,"path":"2022/05/19/treasurebox/python/pip-bu-neng-shi-yong/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/pip-bu-neng-shi-yong/","excerpt":"","text":"https://bootstrap.pypa.io/get-pip.py 下载这个文件，然后在本地双击运行。","categories":[],"tags":[]},{"title":"flask请求钩子","slug":"TreasureBox/python/Flask/flask请求钩子","date":"2022-05-19T01:14:40.395Z","updated":"2023-04-28T09:25:47.116Z","comments":true,"path":"2022/05/19/treasurebox/python/flask/flask-qing-qiu-gou-zi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/flask/flask-qing-qiu-gou-zi/","excerpt":"","text":"Flask的请求钩子有时在处理请求之前或之后执行代码会很有用。例如，在请求开始时，我们可能需要创建数据库连接或者认证发起请求的用户。为了避免在每个视图函数中都使用重复的代码，Flask 提供了注册通用函数的功能，注册的函数可在请求被分发到视图函数之前或之后调用。 在请求的钩子函数和视图函数之间共享数据一般使用上下文全局变量g。例如，before_request处理程序时可以从数据库中加载已经登录的用户，并将其保存在g.user中，随后调用视图函数时，视图函数再使用g.user获取用户。 一、before_first_request注册一个函数，在处理第一个请求之前运行。 二、before_request注册一个函数，在每次请求之前执行 三、after_request注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行 四、teardown_request注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。 app.url_map查看都有哪些url映射。","categories":[],"tags":[]},{"title":"1、介绍","slug":"TreasureBox/python/Tornado/1、用户指南/1、介绍","date":"2022-05-19T01:14:40.395Z","updated":"2023-04-28T09:25:47.125Z","comments":true,"path":"2022/05/19/treasurebox/python/tornado/1-yong-hu-zhi-nan/1-jie-shao/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/tornado/1-yong-hu-zhi-nan/1-jie-shao/","excerpt":"","text":"用户指南一、介绍Tornado是一个Python web框架和异步网络库，通过非阻塞网络I/O，Tornado可以支持上万级的连接，处理场链接，WebSockets和其他需要与每个用户保持长久连接的应用。 Tornado大提升可以被分为4个主要的部分 web框架（包含创建web应用的RequestHandler类，还有很多其他支持的类） HTTP的客户端和服务端实现（HTTPServer and AsyncHTTPClient） 异步网络库（IOLoop和IOStream），为HTTP组件提供构建模块，也可以用来实现其他协议。 协程库（tornado.gen）允许异步代码写的更直接而不用链式回调的方式。 Tornado web 框架和HTTP server 一起为 WSGI 提供了一个全栈式的选择. 在WSGI容器 (WSGIAdapter) 中使用Tornado web框架或者使用Tornado HTTP server 作为一个其他WSGI框架(WSGIContainer)的容器,这样的组合方式都是有局限性的. 为了充分利用Tornado的特性,你需要一起使用Tornado的web框架和HTTP server. 二、异步和非阻塞I/O实时web功能需要为每个用户提供一个多数时间被闲置的长连接, 在传统的同步web服务器中，这意味着要为每个用户提供一个线程, 当然每个线程的开销都是很昂贵的. 为了尽量减少并发连接造成的开销，Tornado使用了一种单线程事件循环的方式. 这就意味着所有的应用代码都应该是异步非阻塞的, 因为在同一时间只有一个操作是有效的. 异步和非阻塞是非常相关的并且这两个术语经常交换使用,但它们不是完全相同的事情. 阻塞一个函数在等待某些事情的返回值的时候会被阻塞。函数被阻塞的原因有很多：网络I/O，磁盘I/O，互斥锁等，事实上 每个函数在运行和使用CPU的时候都或多或少会被阻塞(举个极端的例子来说明对待CPU阻塞和对待一般阻塞一样的严肃：比如密码哈希函数bcrypt，需要消耗几百毫秒的CPU时间。这已经远远超过了一般的网络或者磁盘请求时间了)。 一个函数可以在某些方面阻塞在另外一些方面不阻塞。例如：tornado.Httpclient在默认的配置下，会在DNS解析上面阻塞，但是在其他网络请求的时候不阻塞（为了减轻这种影响，可以用ThreadedResolver或者是通过正确配置libcurl用tornado.curl_httpclient来做）。在tornado的上下文中，我们一般讨论网络I/O上下文的阻塞，尽管各种阻塞已经被最小化。 异步异步函数会在完成之前返回，在应用中触发下一个动作前通常会在后台执行一些工作（和正常的同步函数在返回前就执行完所有的事情不同）。这里列举了几种风格的异步接口 回调参数 返回一个占位符（Future，Promise，Deferred） 传送给一个队列 回调注册表(POSIX信号) 不论使用那种类型的接口，按照定义异步函数与他们的调用者都有着不同的交互方式；也没有对调用者透明的方式使得同步函数异步（类似gevent使用轻量级现成的系统性能虽然堪比异步系统，但他们并没有真正的让事情异步）。 一个简单的同步函数： 12345from tornado.httpclient import HTTPClientdef synchronous_fetch(url): http_client = HTTPClient() response = http_client.fetch(url) return response.body 用回调参数重写的异步函数 1234567from tornado.httpclient import AsyncHTTPClient# 用回调参数重写的异步函数def asynchronous_fetch(url, callback): http_client = AsyncHTTPClient() def handle_response(response): callback(response.body) http_client.fetch(url, callback=handle_response) 使用Future代替回调 12345678910from tornado.concurrent import Future# 使用Future代替回调def async_fetch_future(url): http_client = AsyncHTTPClient() my_future = Future() fetch_future = http_client.fetch(url) fetch_future.add_done_callback( lambda f:my_future.set_result(f.result) ) return my_future 三、协程return my_future ### 三、协程","categories":[],"tags":[]},{"title":"初识python","slug":"TreasureBox/python/python基础/1.基础/1.初识python","date":"2022-05-19T01:14:40.395Z","updated":"2023-04-28T09:25:47.139Z","comments":true,"path":"2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/1.chu-shi-python/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/python-ji-chu/1.ji-chu/1.chu-shi-python/","excerpt":"","text":"初识python一、安装python windows安装 在python官网下载对应的解释器版本：https://www.python.org/。双击运行解释器进行安装。推荐在安装时不要安装在C盘。 Linux安装 Linux环境中自带了Python 2.x版本，想更新到3.x版本需要去官网下载对应的解释器，以Centos安装python示例： 安装依赖库 1yum -y install wget gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 下载Python源码并解压到指定目录 123wget https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tar.xzxz -d Python-3.7.6.tar.xztar -xvf Python-3.7.6.tar 切换到Python源代码目录并执行下边的命令进行配置和安装 123cd Python-3.7.6./configure --prefix=/usr/local/python37 --enable-optimizationsmake &amp;&amp; make install 修改用户主目录下名为.bash_profile的文件，配置PATH环境变量。 12cd ~vim .bash_profile 1export PATH=$PATH:/usr/local/python37/bin 激活环境变量 1source .bash_profile mac安装 macOS也自带了Python 2.x版本，可以通过Python的官方网站提供的安装文件（pkg文件）安装Python 3.x的版本。默认安装完成后，可以通过在终端执行python命令来启动2.x版本的Python解释器，启动3.x版本的Python解释器需要执行python3命令。 二、运行python程序 确认Python版本 可以在windows的命令提示符中键入：python --version Linux或者MacOS系统在终端输入：python3 --version 也可以输入python或者这python3进入交互模式: 123import sysprint(sys.version_info)print(sys.version) 编写python源代码 可以用文本编辑工具（推荐使用Sublime、Visual Studio Code等高级文本编辑工具）编写Python源代码并用hello.py作为文件名保存该文件，代码内容如下所示： 注意：在Windows中需要显示文件扩展名。 1print(\"hello\") python中时候换行符标识语句结束，多个python语句示例： 123print(\"hello\")print(\"world\")print(\"this is ths first python project\") 对代码的说明： ​ print是python内置的函数，用于在终端输出信息，经常用于代码调试，需要牢记。 运行程序 在windows的命令行（linux 的终端）切换到文件所在的文件夹，执行以下命令： 1python hello.py 代码中的注释 注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。 python中的注释分为两种： 单行注释（使用#） 多行注释（使用””””””或者’’’’’’） 12345678\"\"\"@File: hello.py@Time: 2020/6/6 13:50@user：liuhuan 多行注释\"\"\"# 单行注释print(\"hello\") Python开发工具 工欲善其事，必先利其器。开发工具在开发展过程中占据着重要的一环。python有自带的idea开发工具，但是在开发大型项目时不太适合。推荐的开发工具有sublime，editplus，pycharm，visual code等，其中pycharm是为python量身打造的开发工具，在开发大型项目时很方便。 python之禅 在python交互模式中输入：import this查看python之禅 12345678910111213141516171819Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do itAlthough that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those! asy to explain, it may be a good idea. Namespaces are one honking great idea – let’s do more of those!","categories":[],"tags":[]},{"title":"flask_mail使用","slug":"TreasureBox/python/Flask/flask_mail/flask_mail使用","date":"2022-05-19T01:14:40.395Z","updated":"2023-04-28T09:25:47.118Z","comments":true,"path":"2022/05/19/treasurebox/python/flask/flask-mail/flask-mail-shi-yong/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/flask/flask-mail/flask-mail-shi-yong/","excerpt":"","text":"flask-mail1、安装 pip install flask-mail 2、配置项 配置 默认值 说明 MAIL_SERVER localhost 电子邮件服务器的主机名或IP地址 MAIL_PORT 25 电子邮件服务器的端口 MAIL_USE_TLS False 启用传输层安全(TransportLayer Security,TLS)协议 MAIL_USE_SSL False 启用安全套接层(Secure SocketsLayer,SSL)协议 MAIL_USERNAME None 邮件账户的用户名 MAIL_PASSWORD None 邮件账户的密码","categories":[],"tags":[]},{"title":"4、中间件","slug":"TreasureBox/python/Django/其它/4、中间件","date":"2022-05-19T01:14:40.394Z","updated":"2023-04-28T09:25:47.153Z","comments":true,"path":"2022/05/19/treasurebox/python/django/qi-ta/4-zhong-jian-jian/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/qi-ta/4-zhong-jian-jian/","excerpt":"","text":"中间件中间件是Django请求/响应处理的框架。这是一个轻量级的插件系统，用于全局更改Django的输入或者输出。 每个中间件组件负责执行某些特定的功能，Django中有一些内置的中间件，可以直接进行使用。自定义中间件文件：MiddleWareIp.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#-*-coding:utf-8 -*-\"\"\"@File: middleware.py@user：liuhuan \"\"\"# process_request 请求开始，视图之前# process_views 请求开始，视图之中# process_exception 错误# process_template_response 视图结束，模板开始渲染# process_response 响应结束from django.utils.deprecation import MiddlewareMixinfrom django.http import HttpResponse,JsonResponseclass MiddleWareIp(MiddlewareMixin): def process_request(self,request): request_ip = request.META[\"REMOTE_ADDR\"] print(request_ip) # if request_ip == \"127.0.0.1\": # return HttpResponse(\"非法IP\") def process_view(self,request,view_func,view_args,view_kwargs): \"\"\" :param request: 请求 :param view_func: 视图函数 :param view_args: 视图函数需要的参数，元组类型 :param view_kwargs: 视图函数需要的参数，字典类型 :return: \"\"\" print(view_func,view_args,view_kwargs,1111111111) def process_exception(self,request,exception): print(exception) def process_template_response(self,request,response): \"\"\" :param request: 请求 :param response: 响应 :return: \"\"\" print(\"process_template_response\") print(response) return response def process_response(self,request,response): return response 在settings添加中间件配置： 1\"MyApp.middleware.MiddleWareIp\" yApp.middleware.MiddleWareIp”","categories":[],"tags":[]},{"title":"1、基础配置","slug":"TreasureBox/python/Flask/Flask-SQlalchemy/1、基础配置","date":"2022-05-19T01:14:40.394Z","updated":"2023-04-28T09:25:47.118Z","comments":true,"path":"2022/05/19/treasurebox/python/flask/flask-sqlalchemy/1-ji-chu-pei-zhi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/flask/flask-sqlalchemy/1-ji-chu-pei-zhi/","excerpt":"","text":"一、基础flask-sqlalchemy示例1234567891011121314151617181920212223242526272829303132333435363738394041from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)app.config[\"SQLALCHEMY_DATABASE_URI\"] = \"sqlite:///OA.sqlite\"# 链接mysql时设置：mysql://username:password@server/dbapp.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = Falsedb = SQLAlchemy(app)class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(80), unique=True) email = db.Column(db.String(120), unique=True) def __init__(self,username,email): self.username = username self.email = email def __repr__(self): return \"User {}\".format(self.username) def __str__(self): return self.username# 创建数据表# db.create_all()# 2、插入数据# admin = User(\"admin\",\"admin@sina.cn\")# user1 = User(\"user1\",\"user1@sina.cn\")# db.session.add(admin)# db.session.add(user1)# db.session.commit()# 3、查询数据# user = User.query.all()# print(user,type(user))## admin = User.query.filter_by(username=\"admin\").first()# print(admin) 二、主要的配置键 参数 作用 SQLALCHEMY_DATABASE_URI 应该用于连接的数据库URI。例子：sqlite:////tmp/test.db ；mysql://username:password@server/db SQLALCHEMY_BINDS 将绑定键映射到SQLAlchemy连接URI的字典（可绑定多个数据库） SQLALCHEMY_ECHO 如果设置为True， SQLAlchemy将记录所有发给stderr的语句，这对于调试很有用。 SQLALCHEMY_RECORD_QUERIES 可用于显式禁用或启用查询记录。查询记录将自动在调试或测试模式下发生 SQLALCHEMY_TRACK_MODIFICATIONS 如果设置为True，Flask-SQLAlchemy将跟踪对象的修改并发出信号。默认值为None，它启用跟踪，但发出警告，默认情况下它将在将来禁用。这需要额外的内存，如果不需要，应将其禁用。 SQLALCHEMY_ENGINE_OPTIONS 发送给的关键字args字典 create_engine() 配置多个数据库示例： 12345SQLALCHEMY_DATABASE_URI = 'postgres://localhost/main'SQLALCHEMY_BINDS = { 'users': 'mysqldb://localhost/users', 'appmeta': 'sqlite:////path/to/appmeta.db'} 三、支持的数据库引擎 Postgres 1postgresql://scott:tiger@localhost/mydatabase MySQL 1mysql://scott:tiger@localhost/mydatabase Oracle 1oracle://scott:tiger@127.0.0.1:1521/sidname SQLite 1sqlite:////absolute/path/to/foo.db 1sqlite:////absolute/path/to/foo.db","categories":[],"tags":[]},{"title":"2、声明模型","slug":"TreasureBox/python/Flask/Flask-SQlalchemy/2、声明模型","date":"2022-05-19T01:14:40.394Z","updated":"2023-04-28T09:25:47.117Z","comments":true,"path":"2022/05/19/treasurebox/python/flask/flask-sqlalchemy/2-sheng-ming-mo-xing/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/flask/flask-sqlalchemy/2-sheng-ming-mo-xing/","excerpt":"","text":"一、字段类型所有模型的基类都是db.Model，创建的表名会自动进行设置。将大写的表名转化为小写，并将”CamelCase”转换为”Camel_case”，需要改名字时设置类属性:*__tablename*__。 使用db.Column定义列，常见的字段类型。 类型 python类型 说明 Integer int 一个整数 String(size) str 最大长度的字符串（在某些数据库中为可选，例如PostgreSQL） Text str 一些更长的unicode文本 DateTime datetime.datetime 日期和时间表示为Pythondatetime对象。 Float float 存储浮点值 Boolean bool 存储一个布尔值 PickleType 任何 Python 存储一个pickled python 对象 LargeBinary str 存储大的任意二进制数据 列选项设置 选项名 说明 primary_key 如果设为True，就是表的主键 unique 如果设为True，不允许出现重复的值 index 创建索引，提高查询效率 nullable True时允许使用空值 default 定义默认值 二、一对多关系12345678910class Person(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(50), nullable=False) addresses = db.relationship('Address', backref='person', lazy=True)class Address(db.Model): id = db.Column(db.Integer, primary_key=True) email = db.Column(db.String(120), nullable=False) person_id = db.Column(db.Integer, db.ForeignKey('person.id'), nullable=False) 想建立1对1关系时，需要在relationship()中添加uselist=False。 设置nullable=False时说明该字段可以为空。 backref是在Address类上声明新属性的一种简单方法，可以试用my_address.person来找到该地址对应的人。 lazy定义SQLALchemy何时从数据库中加载数据。 select/True，默认设置，手动设置比不设置会好一点，代表SQLAlchemy使用标准的select语句一次性加载数据。 joined/False告诉SQLAlchemy使用一条JOIN语句在与腹肌相同的查询中加载关系。 subquery与joined类似，但joined会使用子查询。 dynamic是特殊的，SQLAlchemy将返回一个查询对象，可以在加载项目之前进一步优化该对象。 常用 SQLALchemy关系选项 选项名 说明 backref 在关系的另一个模型中添加反向引用 primaryjoin 明确指定两个明星之间使用的联结条件，只在模棱两可的关系中需要指定 lazy 指定如何加载相关记录。可选值有 select(首次访问时按需加)、immediate（源对象加载后就加载）、joined（加载记录，但使用联结）、subquery（立即加载，但使用子查询），noload（永不加载）和dynamic（不加载记录，但提供加载记录的查询） uselist 如果设置为False，不适用列表，而使用标量值 order_by 指定关系表中记录的排序方式 secondary 指定多对多关系中关系表的名字 secondaryjoin SQLalchemy无法自行决定时，指定多对多关系中的二级联结条件。 ��二级联结条件。 |","categories":[],"tags":[]},{"title":"3、增删查","slug":"TreasureBox/python/Flask/Flask-SQlalchemy/3、增删查","date":"2022-05-19T01:14:40.394Z","updated":"2023-04-28T09:25:47.117Z","comments":true,"path":"2022/05/19/treasurebox/python/flask/flask-sqlalchemy/3-zeng-shan-cha/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/flask/flask-sqlalchemy/3-zeng-shan-cha/","excerpt":"","text":"SQLALchemy的CRUD操作一、添加123me = User(\"user2\",\"user2@example.com\")db.session.add(me)db.session.commit() 二、删除123# 删除db.session.delete(User.query.filter_by(username=\"user2\").first())db.session.commit() 三、查找1、查询过滤器 过滤器 说明 filter() 把过滤器添加到原查询上，返回一个新查询 filter_by() 把等值过滤器添加到原查询上，返回一个新查询 limit() 使用指定的值限制原查询的结果数量，返回一个新查询 offset() 偏移原查询返回的结果，返回一个新查询 order_by() 根据指定条件对原查询结果进行排序，返回一个新查询 group_by() 根据指定结果对原查询结果进行分组，返回一个新查询 2、查询执行函数 方法 说明 all() 以列表形式返回查询的所有结果 first() 返回查询的第一个结果，如果没有结果，则返回None first_or_404() 返回查询的第一个结果。如果没有结果，则终止请求，返回404错误响应 get() 返回指定主键对应的行，如果没有对应的行，则返回None get_or_404() 返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回404错误响应 count() 返回查询结果的数量 paginate() 返回一个Paginate对象，它包含指定范围内的结果 12345678910111213141516171819# 1、通过用户名查找用户admin = User.query.filter_by(username=\"admin\").first()print(admin.id)# 不存在时直接为Noneuser2 = User.query.filter_by(username=\"user2\").first()print(user2)# 更复杂的表达式u1 = User.query.filter(User.email.endswith(\"@sina.cn\")).all()print(u1)# 排序u2 = User.query.order_by(User.username).all()print(u2)# 分页u3 = User.query.limit(1).all()print(u3)# 通过主键获取数据u4 = User.query.get(1)print(u4) .query.get(1)print(u4)","categories":[],"tags":[]},{"title":"4、使用flask_migrate管理数据库迁移","slug":"TreasureBox/python/Flask/Flask-SQlalchemy/4、使用flask_migrate管理数据库迁移","date":"2022-05-19T01:14:40.394Z","updated":"2023-04-28T09:25:47.116Z","comments":true,"path":"2022/05/19/treasurebox/python/flask/flask-sqlalchemy/4-shi-yong-flask-migrate-guan-li-shu-ju-ku-qian-yi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/flask/flask-sqlalchemy/4-shi-yong-flask-migrate-guan-li-shu-ju-ku-qian-yi/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"2、DataTable的使用","slug":"TreasureBox/python/Django/其它/2、DataTable的使用","date":"2022-05-19T01:14:40.393Z","updated":"2023-04-28T09:25:47.152Z","comments":true,"path":"2022/05/19/treasurebox/python/django/qi-ta/2-datatable-de-shi-yong/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/qi-ta/2-datatable-de-shi-yong/","excerpt":"","text":"DataTable的使用官网链接：https://datatables.net/ 一、引入 1234&lt;link href =\"https://cdn.datatables.net/1.10.20/css/jquery.dataTables.min.css\"&gt;&lt;script src=\"https://cdn.datatables.net/1.10.20/js/jquery.dataTables.min.js\"&gt;&lt;/script&gt; 二、使用 123456789101112131415161718192021222324252627282930313233&lt;script&gt; $(document).ready( function () { $('#table_0').DataTable({ /*使用id进行绑定*/ \"ordering\": false, /*关闭插件自带排序*/ \"pageLength\": 30, /*每页数目*/ language: { \"sProcessing\": \"处理中...\", \"sLengthMenu\": \"显示 _MENU_ 条记录\", \"sZeroRecords\": \"没有匹配结果\", \"sInfo\": \"显示第 _START_ 至 _END_ 条记录，共 _TOTAL_ 条提测记录\", \"sInfoEmpty\": \"显示第 0 至 0 条记录，共 0 条\", \"sInfoFiltered\": \"(由 _MAX_ 条记录过滤)\", \"sInfoPostFix\": \"\", \"sSearch\": \"搜索:\", \"sUrl\": \"\", \"sEmptyTable\": \"表中数据为空\", \"sLoadingRecords\": \"载入中...\", \"sInfoThousands\": \",\", \"oPaginate\": { \"sFirst\": \"首页\", \"sPrevious\": \"&lt;\", \"sNext\": \"&gt;\", \"sLast\": \"末页\" }, \"oAria\": { \"sSortAscending\": \": 以升序排列此列\", \"sSortDescending\": \": 以降序排列此列\" } } }); }); &lt;/script&gt;","categories":[],"tags":[]},{"title":"1、Paginator","slug":"TreasureBox/python/Django/其它/1、Paginator","date":"2022-05-19T01:14:40.393Z","updated":"2023-04-28T09:25:47.153Z","comments":true,"path":"2022/05/19/treasurebox/python/django/qi-ta/1-paginator/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/qi-ta/1-paginator/","excerpt":"","text":"Django自带的分页方法1、引入 1from django.core.paginator import Paginator,PageNotAnInteger,EmptyPage 2、使用 12345678p = Paginator(new_list,1) #news_list代表所有的数据,1代表每页的条数 number = p.num_pages #总的页码数page_range = p.page_range #所有页码的迭代器new_list.has_previous() #是否有上一条数据new_list.has_next() #是否有下一条数据new_list.previous_page_number() #上一页的页码new_list.next_page_number() #下一页的页码 3、示例 123456789101112131415161718192021222324from .models import Newsdef news(request): news_list = News.objects.order_by('id') p = Paginator(news_list,1) number = p.num_pages #页码的总数 page_range = p.page_range try: page = int(request.GET.get('page', 1)) except: page = 1 try: data = p.page(page) except: raise Http404 page = int(page) if page &lt; 4: #一次只返回四个页码 page_list = page_range[:4] elif page + 4 &gt; number: page_list = page_range[-4:] else: page_list = page_range[page - 2:page + 2] print(p.count) return render(request, 'changed/news.html',{\"news\":news,\"new_list\":data,\"page_range\":page_list}) 在前端中使用： 12345678910111213 {% if new_list.has_previous %} &lt;li&gt;&lt;a href=\"?page={{ new_list.previous_page_number }}\" class=\"pag-item\"&gt;&amp;lt;&amp;lt;&lt;/a&gt;&lt;/li&gt; {% endif %}{% for page in page_range %} {% if page == request.GET.page|add:0 %} &lt;li&gt;&lt;a href=\"?page={{ page }}\" class=\"pag-item pag-active\" &gt;{{ page }}&lt;/a&gt;&lt;/li&gt; {% else %} &lt;li&gt;&lt;a href=\"?page={{ page }}\" class=\"pag-item\" &gt;{{ page }}&lt;/a&gt;&lt;/li&gt; {% endif %}{% endfor %} {% if new_list.has_next %} &lt;li&gt;&lt;a href=\"?page={{ new_list.next_page_number }}\" class=\"pag-item\"&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/li&gt; {% endif %} 4、自定义分页器方法 12345678910111213141516171819202122def set_page(data,num,page): \"\"\" :param data: 所有的数据 :param num: 每页的数据个数 :param page: 当前的页码 :return: \"\"\" p = Paginator(data,num) number = p.num_pages page_range = p.page_range try: page = int(page) data = p.page(page) except: data = p.page(1) if page &lt; 5: # 一次只返回5个页码 page_list = page_range[:5] elif page + 4 &gt; number: page_list = page_range[-5:] else: page_list = page_range[page - 3:page + 2] return data,page_list page_range[page - 3:page + 2] return data,page_list","categories":[],"tags":[]},{"title":"3、免除csrf校验","slug":"TreasureBox/python/Django/其它/3、免除csrf校验","date":"2022-05-19T01:14:40.393Z","updated":"2023-04-28T09:25:47.152Z","comments":true,"path":"2022/05/19/treasurebox/python/django/qi-ta/3-mian-chu-csrf-xiao-yan/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/qi-ta/3-mian-chu-csrf-xiao-yan/","excerpt":"","text":"一、函数免除csrf校验1234from django.views.decorators.csrf import csrf_exempt# 免除csrf校验@csrf_exemptdef users(request): uses_list = [\"柚子\", \"西瓜\"] return HttpResponse(json.dumps(uses_list)) 二、对类免除csrf校验 第一种方式 123456789101112131415161718192021222324# dispatch是类视图的根方法，通过dispatch进行反射找到其他请求from django.views.decorators.csrf import csrf_exemptfrom django.utils.decorators import method_decoratorclass StudentsView(View): \"\"\"student view\"\"\" @method_decorator(csrf_exempt) def dispatch(self, request, *args, **kwargs): print(\"before\") ret = super(StudentsView, self).dispatch(request, *args, **kwargs) print(\"after\") return ret(request, *args, **kwargs) def get(self,*args,**kwargs): return HttpResponse(\"get\") def post(self,*args,**kwargs): return HttpResponse(\"post\") def put(self,*args,**kwargs): return HttpResponse(\"put\") def delete(self,*args,**kwargs): return HttpResponse(\"delete\") 第二种方式 123456789from django.views.decorators.csrf import csrf_exemptfrom django.utils.decorators import method_decorator@method_decorator(csrf_exempt,name=\"dispatch\")class StudentsView(View): \"\"\"student view\"\"\" def get(self,*args,**kwargs): return HttpResponse(\"get\") 第三种方式 12345678from django.views.decorators.csrf import csrf_exemptclass MyBaseView(object): @csrf_exempt def dispatch(self, request, *args, **kwargs): print(\"before\") ret = super(MyBaseView, self).dispatch(request, *args, **kwargs) print(\"after\") return ret 第四种，在url中添加 1234from django.views.decorators.csrf import csrf_exempturlpatterns = [ path('teachers/', csrf_exempt(TeachersView.as_view()), name=\"teachers\"),] ), name=”teachers”), ] ```","categories":[],"tags":[]},{"title":"会话介绍","slug":"TreasureBox/python/Django/7.会话技术/1.会话介绍","date":"2022-05-19T01:14:40.392Z","updated":"2023-04-28T09:25:47.173Z","comments":true,"path":"2022/05/19/treasurebox/python/django/7.hui-hua-ji-zhu/1.hui-hua-jie-shao/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/7.hui-hua-ji-zhu/1.hui-hua-jie-shao/","excerpt":"","text":"会话介绍Django支持匿名会话。绘画框架支持给予每个站点的访问者存储和检索任意数据，在服务器端存储数据并提供cookie的发送和接受。cookie包含会话id——而不是数据本身。 打开会话会话通过配置中间价实现，为了打开会话需要做以下操作： 编辑设置中的MIDDLEWARE，并确保包含了:‘django.contrib.sessions.middleware.SessionMiddleware’ 通过django-admin startproject创建的项目默认在settings.py中已经打开了SessionMiddleware这项设置。 如果不想使用会话功能时，可以从配置文件中删除”SessionMiddlware”,并且从INSTALLED_APPS中删除”django.contrib.sessions”。 配置会话引擎默认情况下，Django（使用模型django.contrib.sessions.models.Session）将会话存储在数据库中 。尽管这很方便，但是在某些设置中，将会话数据存储在其他位置更快，因此可以将Django配置为在文件系统或缓存中存储会话数据。 使用数据库支持的会话如果要使用数据库支持的会话，则需要添加 'django.contrib.sessions'到INSTALLED_APPS设置中。 配置 完安装后，运行以安装存储会话数据的单个数据库表。python manage.py migrate","categories":[],"tags":[]},{"title":"cookie和session","slug":"TreasureBox/python/Django/7.会话技术/2.cookie和session","date":"2022-05-19T01:14:40.392Z","updated":"2023-04-28T09:25:47.174Z","comments":true,"path":"2022/05/19/treasurebox/python/django/7.hui-hua-ji-zhu/2.cookie-he-session/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/7.hui-hua-ji-zhu/2.cookie-he-session/","excerpt":"","text":"Cookie和session1、Cookie​ cookie是服务器在本地机器上存储的小段文本并随每一个请求发送至同一服务器。Cookies保存在客户端，主要内容包括：名字，值，过期时间，路径等。 设置cookie： HttpResponse.set_cookie(key, value=’’, max_age=None, expires=None, path=’/‘, domain=None, secure=None, httponly=False) 参数： key： cookie的名称。 value: cookie的值,默认是空字符。 max_age：cookies的持续有效时间（以秒计），如果设置为 None，cookies 在浏览器关闭的时候就失效了。 expires：cookies的过期时间，格式:”Wdy, DD-Mth-YY HH:MM:SS GMT” 如果设置这个参数，它将覆盖max_age。 path: cookie生效的路径前缀，浏览器只会把cookie回传给带有该路径的页面，这样你可以避免将cookie传给 站点中的其他的应用。/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问 domain: cookie生效的站点。你可用这个参数来构造一个跨站cookie。如， domain=”.example.com” 所构造的。 获取cookie HttpRequest.COOKIES.get(key) #获取加“盐”的cookie HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt=’’, max_age=None) 删除cookie HttpResponse.delete_cookie(key, path=’/‘, domain=None) 2、会话cookie和持久cookie的区别会话cookie：不设置过期时间，只要关闭浏览器窗口cookie就消失。会话cookie不保存在硬盘上，保存在内存里。 持久cookie：设置过期时间，浏览器就会把cookie保存在硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享。而对于保存在内存中的cookie，不同的浏览器有不同的处理方式。 利用持久的Cookie自动登录：当用户在某个网站注册后，就会收到一个唯一用户ID的cookie。客户重新连接时，用户ID会自动返回，服务器对它进行检查，确定它是否为注册用户且选择了自动登录，从而使用户无需给出明确的用户名和密码，就可以访问服务器上的资源。 3、session定义session是在服务器端保存的用户数据。浏览器第一次发送请求时，服务器自动生成了Session ID来唯一标识这个，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的Session ID放在请求中并发到服务器上，服务器从请求中提取出Session ID，并和保存的所有session ID会进行对比，找到这个用户的信息。一般这个session ID会有个时间限制，默认超过30分钟时毁掉Session ID。 session和cookie有一定的关系，session id存在cookie中，每次访问时候将session id传到服务器进行对比。 设置session： 12request.session['manager_name'] = usernamerequest.session['manager_id'] = m[0].id 获取session： 12print(request.session['manager_name'])print(request.session['manager_id']) 删除session： 12request.session.clear() #清空del request.session['manager_name'] 4、cookie和session的区别和联系区别 session将数据存储与服务器端 cookie存储在客户端 cookie 存储在客户端，不安全，sess存储在服务器端，客户端只存sesseionid,安全 cookie在客户端存储值有大小的限制，大约几kb。session没有限制 联系 session基于cookie限制 联系 session基于cookie","categories":[],"tags":[]},{"title":"3","slug":"TreasureBox/python/Django/7.会话技术/3","date":"2022-05-19T01:14:40.392Z","updated":"2023-04-28T09:25:47.176Z","comments":true,"path":"2022/05/19/treasurebox/python/django/7.hui-hua-ji-zhu/3/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/7.hui-hua-ji-zhu/3/","excerpt":"","text":"在视图中使用会话当SessionMiddleware被激活时，每个HttpRequest 对象-的第一个参数的任何Django的视图函数-将有一个 session属性，它是一个类似于字典的对象。 可以使用request.session在视图中的任何位置阅读和写入。并且可以对其进行多次编辑。 类backends.base.``SessionBase¶是所有会话对象的基类。它具有以下标准词典方法： __getitem__（键） 例： fav_color = request.session['fav_color'] __setitem__（key，value） 例： request.session['fav_color'] = 'blue' __delitem__(key) 例： del request.session['fav_color'] 如果该key不存在时，会抛出一个KeyError异常。 __contains__(key) 例: 'fav_color' in request.session get(key, default=None) 例: fav_color = request.session.get('fav_color','red') pop(key, default=__not_given) 例: fav_color = request.session.pop('fav_color','blue') keys() 获取所有的key。 items() 获取所有的数据。 setdefault() clear() flush() 从会话中删除当前会话数据并删除会话cookie和数据表中的session。如果要确保用户不能再次从浏览器访问先前的会话数据，则使用此 方法。 则使用此 方法。","categories":[],"tags":[]},{"title":"项目流程","slug":"TreasureBox/python/Django/6.Django项目流程/1.项目流程","date":"2022-05-19T01:14:40.379Z","updated":"2023-04-28T09:25:47.154Z","comments":true,"path":"2022/05/19/treasurebox/python/django/6.django-xiang-mu-liu-cheng/1.xiang-mu-liu-cheng/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/6.django-xiang-mu-liu-cheng/1.xiang-mu-liu-cheng/","excerpt":"","text":"项目流程python当使用pip安装失败时，可以直接使用轮子进行安装：https://www.lfd.uci.edu/~gohlke/pythonlibs/，下载对应版本的轮子，然后使用pip install去安装： 1、需求分析定义项目需求，根据不同的用户群体划分不同的app： 商家用户： 开店（md5加密密码）——&gt;注册用户，个人信息管理，重置密码(邮箱校验，ajax异步通信技术)。 登录、退出操作（只删除该用户模式的session和cookie信息）。 商品管理： ​ (1) 添加商品：Bootstrap,table,form ​ (2) 商品数据展示：https://datatables.net/。 ​ (3) 修改商品 ：数量、价格、上架、下架 ​ (4) 订单管理：发货操作 买家用户： ​ 1、注册、登录 ​ 2、浏览商品、添加购物车、购买、收货、添加收货地址 商品模块： ​ 展示商品：index，list，detail 管理平台： ​ 1、管理商品类别 ​ 2、监督交易进展。 ​ 3、审核用户信息。 创建项目流程1、创建完整的项目架构： 2、修改settings.py设置: 注册app: 配置模板文件路径 配置数据库 修改语言和时区 配置静态文件的存放路径 设置用户上传文件路径 3、配置子路由：在子apps.py中设置： 在根urls中引入： 根urls中引入：","categories":[],"tags":[]},{"title":"报错信息处理","slug":"TreasureBox/python/Django/6.Django项目流程/2.报错信息处理","date":"2022-05-19T01:14:40.379Z","updated":"2023-04-28T09:25:47.155Z","comments":true,"path":"2022/05/19/treasurebox/python/django/6.django-xiang-mu-liu-cheng/2.bao-cuo-xin-xi-chu-li/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/6.django-xiang-mu-liu-cheng/2.bao-cuo-xin-xi-chu-li/","excerpt":"","text":"报错信息处理：1、连接mysql数据库报错时： 安装对应版的mysqlclient: 2、访问路径报错： 只能访问定义过的路径： 3、模板文件找不到： 解决办法： 1、查看settings.py中的配置文件对不对。 2、查看templates中有没有当前页面。 4、静态文件找不到： 解决办法： 1、查看settings.py中的配置。 2、查看在static文件夹是否有静态文件。 3、前端中的路径是否正确。 4、清理浏览器缓存。 5、路径不合法： 6、路径不能重复：执行静态收集时： python manage.py collectstatic 解决方法：先把MEDIA_ROOT暂时注释掉，收集完静态之后再打开。 静态收集成功： 静态文件收集之后，将STATIC_ROOT路径注释掉： 7、数据插入时常犯的错误：1、数据不能为null： 原因：前端中的name属性和后端不匹配。 html文件中： python文件中： 解决方法：修改前端或后端的name值。 2、类型错误 原因：在float字段中插入了字符串。 修改：将前端的数据设为必填并且为number类型。 3、外键关联字段错误： 原因：子表中外间关联的字段数据为0。 解决：外键关联的数据必须填值并且为大于0的整数。 原因： 解决方法： 428417.png) 解决方法：","categories":[],"tags":[]},{"title":"注册和动作","slug":"TreasureBox/python/Django/5.Django站点管理/1.注册和动作","date":"2022-05-19T01:14:40.378Z","updated":"2023-04-28T09:25:47.147Z","comments":true,"path":"2022/05/19/treasurebox/python/django/5.django-zhan-dian-guan-li/1.zhu-ce-he-dong-zuo/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/5.django-zhan-dian-guan-li/1.zhu-ce-he-dong-zuo/","excerpt":"","text":"Django站点管理Django最强大的部分之一是自动管理界面。它从模型中读取元数据，以提供一个快速的、以模型为中心的界面，受信任的用户可以在其中管理网站上的内容。管理员的建议用法仅限于组织的内部管理工具。 管理员有许多用于自定义的钩子，但是要当心使用这些专门的钩子。如果需要提供一个更加以流程为中心的接口，以抽象出数据库表和字段的实现细节，那么可能需要编写自己的视图了。 要使用Django站点管理时，需要首先进行数据迁移： python manage.py migrate 站点名称设置： 12admin.site.site_header='贵族时代管理后台'admin.site.site_title='贵族时代管理后台' 一、创建用户创建用户命令使用： python manage.py createsuperuser 登录站点时必须保证is_superuser或者is_staff设置为True。 django自带表的引入方式： 123from django.contrib.auth.models import User,Group,Permissionfrom django.contrib.admin.models import LogEntry #对应数据库admin_logfrom django.contrib.admin.models import ContentType #对应数据库ContentType django自带auth_user表的操作： 创建用户，在views.py中引入： 123456789101112from django.contrib import auth #引入auth模块from django.contrib.auth.models import User # auth应用中引入User类def register(request): if request.method == 'POST': user_obj = request.POST print(user_obj) username = user_obj.get('name') password = user_obj.get('password') user = User.objects.create_user(username=username, password=password,) user.save() return HttpResponse(\"注册成功\") 登录 123from django.contrib.auth import login as Auth_Login,authenticate,logout as Auth_Logoutuser = authenticate(username=\"username\", password='password')Auth_Login(request, user) 退出 1Auth_Logout(request) 二、添加模型的方法添加模型的方法有两种，通常，这些文件存储在admin.py应用程序中命名的文件中。： admin.site.register() 123456from django.contrib import adminfrom myproject.myapp.models import Authorclass AuthorAdmin(admin.ModelAdmin): passadmin.site.register(Author, AuthorAdmin) 如果只是注册一个简单的admin，则不需要定义admin类，可以直接进行注册： 1234from django.contrib import adminfrom myproject.myapp.models import Authoradmin.site.register(Author) 使用装饰器：@admin.register() 123456from django.contrib import adminfrom .models import Author@admin.register(Author)class AuthorAdmin(admin.ModelAdmin): pass 三、在admin中添加”动作“Django管理员的基本工作流程是“选择一个对象，然后更改它”。这对于大多数用例都适用。但是，如果需要一次对多个对象进行相同的更改，则此工作流程可能非常繁琐。此时可以编写和注册”动作”函数，通过这些函数再更改列表页面上的选择对象时进行调用。 示例：为模型增加批量修改状态功能。 动作函数需要添加三个参数： 当前ModelAdmin 一个HttpRequest表示当前请求， 甲QuerySet含有该组用户所选择的对象。 第一种方法：在ModelAdmin类外部定义动作函数。 12345678910111213from django.contrib import adminfrom myapp.models import Articledef make_published(modeladmin, request, queryset): queryset.update(status='p')make_published.short_description = \"批量更新状态\"class ArticleAdmin(admin.ModelAdmin): list_display = ['title', 'status'] ordering = ['title'] actions = [make_published]admin.site.register(Article, ArticleAdmin) 第二种方法：将动作挂钩给ArticleAdmin对象本身。 12345678class ArticleAdmin(admin.ModelAdmin): ... actions = ['make_published'] def make_published(self, request, queryset): queryset.update(status='p') make_published.short_description = \"Mark selected stories as published\" 可以使用提示的方法告诉用户操作成功： 12345678910class ArticleAdmin(admin.ModelAdmin): ... def make_published(self, request, queryset): rows_updated = queryset.update(status='p') if rows_updated == 1: message_bit = \"1 story was\" else: message_bit = \"%s stories were\" % rows_updated self.message_user(request, \"%s successfully marked as published.\" % message_bit) 还可以在动作执行之后进行HttpResponse或者路由的重定向。 12345678from django.contrib import adminfrom django.contrib.contenttypes.models import ContentTypefrom django.http import HttpResponseRedirectdef export_selected_objects(modeladmin, request, queryset): selected = request.POST.getlist(admin.ACTION_CHECKBOX_NAME) ct = ContentType.objects.get_for_model(queryset.model) return HttpResponseRedirect(\"/export/?ct=%s&amp;ids=%s\" % (ct.pk, \",\".join(selected))) 在整个站点范围内设置”动作“： 123from django.contrib import adminadmin.site.add_action(export_selected_objects) 禁止动作： 例如：禁止使用”删除所选对象“操作： 1admin.site.disable_action('delete_selected') 如果想在某个admin中重新启用某个动作，则只需在actions列表中列出即可： 123456789101112# 禁止全局的\"删除所选对象\"操作admin.site.disable_action('delete_selected')# 该amdin不包含\"删除所选对象\"操作class SomeModelAdmin(admin.ModelAdmin): actions = ['some_other_action'] ...#将\"删除所选对象\"操作加入该admin中class AnotherModelAdmin(admin.ModelAdmin): actions = ['delete_selected', 'a_third_action'] ... 在该admin中禁用所有特定的操作： 12class MyModelAdmin(admin.ModelAdmin): actions = None 有条件地启用或禁用操作可以通过覆盖根据每个请求有条件地启用或禁用操作。这将返回被允许的动作字典。键是动作名称，值是元组。(function, name, short_description)大多数时候，您将使用此方法从超类收集的列表中有条件地删除操作。例如，如果我只希望名称以“ J”开头的用户能够批量删除对象，则可以执行以下操作： 123456789class MyModelAdmin(admin.ModelAdmin): ... def get_actions(self, request): actions = super().get_actions(request) if request.user.username[0].upper() != 'J': if 'delete_selected' in actions: del actions['delete_selected'] return actions 设置操作权限：Django2.1的新功能： 通过allowed_permissions在动作功能上设置属性，动作可以将其可用性限制为具有特定权限的用户使用： 123def make_published(modeladmin, request, queryset): queryset.update(status='p')make_published.allowed_permissions = ('change',) 如果有多个权限时，则只需要通过其中一个权限就可以了，对应的权限如下： 'add'： ModelAdmin.has_add_permission() 'change'： ModelAdmin.has_change_permission() 'delete'： ModelAdmin.has_delete_permission() 'view'： ModelAdmin.has_view_permission() 还可以使用指定的其他值，只需要实现相应的方法即可： 1234567891011121314151617181920from django.contrib import adminfrom django.contrib.auth import get_permission_codenameclass ArticleAdmin(admin.ModelAdmin): actions = ['make_published'] def make_published(self, request, queryset): queryset.update(status='p') make_published.allowed_permissions = ('publish',) def has_publish_permission(self, request): \"\"\"Does the user have the publish permission?\"\"\" opts = self.opts codename = get_permission_codename('publish', opts) return request.user.has_perm('%s.%s' % (opts.app_label, codename))```equest): \"\"\"Does the user have the publish permission?\"\"\" opts = self.opts codename = get_permission_codename('publish', opts) return request.user.has_perm('%s.%s' % (opts.app_label, codename))","categories":[],"tags":[]},{"title":"ModelAdmin方法","slug":"TreasureBox/python/Django/5.Django站点管理/3.ModelAdmin方法","date":"2022-05-19T01:14:40.378Z","updated":"2023-04-28T09:25:47.148Z","comments":true,"path":"2022/05/19/treasurebox/python/django/5.django-zhan-dian-guan-li/3.modeladmin-fang-fa/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/5.django-zhan-dian-guan-li/3.modeladmin-fang-fa/","excerpt":"","text":"ModelAdmin方法 save_model 根据save_model方法是添加还是更改HttpRequest对象，覆盖此方法可进行保存或保存后的操作。调用super().save_model()以使用Model.save()方法来保存对象。 1234class GoodsInfoAdmin(admin.ModelAdmin): def save_model(self, request, obj, form, change): obj.seller=request.user super(GoodsInfoAdmin, self).save_model(request, obj, form, change) delete_model 重写此方法可以执行删除前或者删除后的操作。调用super().delete_model()以使用Model.delete()删除对象。 重写此方法可为”删除所选对象“操作自定义删除过程。 get_ordering 该方法采用request作为参数，并且返回与属性相似的list或tuple用于排序。如： 1234567class PersonAdmin(admin.ModelAdmin): def get_ordering(self, request): if request.user.is_superuser: return ['name', 'rank'] else: return ['name'] get_readonly_fields 1234567class PersonAdmin(admin.ModelAdmin): def get_readonly_fields(self, request, obj=None): if obj: if request.user.is_superuser: return ['publisher'] return ['publisher'] return ['publisher'] get_list_display 指定HttpRequest,返回一个list或者tuple类型的字段名称，这些名称将显示在更改列表是图中。类似list_display。 get_urls 在get_urls上一个方法ModelAdmin中相同的方式，URL配置要用于该返回的ModelAdmin的URL。因此，可以对url进行扩充： 123456789101112131415161718192021from django.contrib import adminfrom django.template.response import TemplateResponsefrom django.urls import pathclass MyModelAdmin(admin.ModelAdmin): def get_urls(self): urls = super().get_urls() my_urls = [ path('my_view/', self.my_view), ] return my_urls + urls def my_view(self, request): # ... context = dict( # Include common variables for rendering the admin template. self.admin_site.each_context(request), # Anything else you want in the context... key=value, ) return TemplateResponse(request, \"sometemplate.html\", context) 如果要使用管理员布局，请从admin/base_site.html以下扩展： 1234{% extends \"admin/base_site.html\" %}{% block content %}...{% endblock %} 在此示例中，my_view将通过访问 /admin/myapp/mymodel/my_view/（假设管理URL位于）/admin/ formfield_for_foreignkey 对外键关联的数据做筛选： 12345class RecordAdmin(admin.ModelAdmin): def formfield_for_foreignkey(self, db_field, request, **kwargs): if db_field.name == \"version\": kwargs['queryset'] = Version.objects.all().exclude(oss_links='') return super().formfield_for_foreignkey(db_field, request, **kwargs) formfield_for_manytomany 与formfield_for_foreignkey方法类似，formfield_for_manytomany可以重写该方法以将默认表单字段更改为多对多字段。例如，如果所有者可以拥有多辆汽车，并且汽车可以属于多个所有者（多对多关系），则可以过滤Car外键字段以仅显示拥有的汽车User： 12345class MyModelAdmin(admin.ModelAdmin): def formfield_for_manytomany(self, db_field, request, **kwargs): if db_field.name == \"cars\": kwargs[\"queryset\"] = Car.objects.filter(owner=request.user) return super().formfield_for_manytomany(db_field, request, **kwargs) formfield_for_choice_field 与formfield_for_foreignkey和formfield_for_manytomany 方法一样，formfield_for_choice_field可以重写该方法以更改已声明选择的字段的默认formfield。例如，如果超级用户可用的选择与普通员工可用的选择不同，则可以按以下步骤进行： 12345678910class MyModelAdmin(admin.ModelAdmin): def formfield_for_choice_field(self, db_field, request, **kwargs): if db_field.name == \"status\": kwargs['choices'] = ( ('accepted', 'Accepted'), ('denied', 'Denied'), ) if request.user.is_superuser: kwargs['choices'] += (('ready', 'Ready for deployment'),) return super().formfield_for_choice_field(db_field, request, **kwargs) get_queryset 返回特定的数据 1234567@admin.register(Orders)class OrdersAdmin(admin.ModelAdmin): def get_queryset(self, request): qs = super(OrdersAdmin, self).get_queryset(request) if request.user.is_superuser: return qs return qs.filter(seller=request.user.id) 待续 st.user.is_superuser: return qs return qs.filter(seller=request.user.id) ``` 待续","categories":[],"tags":[]},{"title":"ModelAdmin选项","slug":"TreasureBox/python/Django/5.Django站点管理/2.ModelAdmin选项","date":"2022-05-19T01:14:40.378Z","updated":"2023-04-28T09:25:47.150Z","comments":true,"path":"2022/05/19/treasurebox/python/django/5.django-zhan-dian-guan-li/2.modeladmin-xuan-xiang/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/5.django-zhan-dian-guan-li/2.modeladmin-xuan-xiang/","excerpt":"","text":"ModelAdmin选项 ModelAdmin是比较灵活的，具有定制页面的选项，所有选项都在ModelAdmin子类上定义： 1234from django.contrib import adminclass AuthorAdmin(admin.ModelAdmin): date_hierarchy = 'pub_date' date_hierarchy 设置date_hierarchy为模型中的DateField或DateTimeField，更改列表页面实现一个简单的分组功能，将符合某个日期分类的数据归为一类。如： 1date_hierarchy = 'pub_date' 还可以使用__查找在相关模型上指定的字段，如： 1date_hierarchy = 'author__pub_date' 这会根据可用的数据智能地分类，如果所有日期都在一个月之内，则按日级时间分类。 empty_value_display 覆盖记录字段为空（None，空字符串等）的默认显示值。默认值为破折号（—）。 1234from django.contrib import adminclass AuthorAdmin(admin.ModelAdmin): empty_value_display = '-empty-' 还可以只复写某个特定的字段如： 123456789from django.contrib import adminclass AuthorAdmin(admin.ModelAdmin): fields = ('name', 'title', 'view_birth_date') def view_birth_date(self, obj): return obj.birth_date view_birth_date.empty_value_display = '???' exclude 提供此属性时，代表要从表单中排除的字段名称列表。 例如，如下模型： 123456from django.db import modelsclass Author(models.Model): name = models.CharField(max_length=100) title = models.CharField(max_length=3) birth_date = models.DateField(blank=True, null=True) 如果仅希望Author模型的表单仅包含name 和title字段，则可以指定fields或exclude类似这样： 1234567from django.contrib import adminclass AuthorAdmin(admin.ModelAdmin): fields = ('name', 'title')class AuthorAdmin(admin.ModelAdmin): exclude = ('birth_date',) 由于作者模型只有三个字段，name，title，和 birth_date，上面的两种构造方式达成的效果一致。 fields fields选项控制在“添加”和“更改”页面上的表单进行简单的布局更改，如：仅显示可用字段的子集，修改顺序或者分组。 要在同一行上显示多个字段，请将这些字段包装在自己的元组中。在此示例中，url和title字段将显示在同一行上，并且该content字段将在其下面显示在其自己的行上： 12class FlatPageAdmin(admin.ModelAdmin): fields = (('url', 'title'), 'content') fieldsets fieldsets对表单进行分块如： 1234fieldsets = ( (\"基本信息\", {'fields': ['goods_name','goods_method','goods_pic','goods_address','type','oprice','xprice']}), (\"介绍\", {'fields': ['goods_info', 'goods_content']})) form 默认情况下，admin将会为模型动态创建一个ModelForm。它用于创建在两个添加/更改页面上显示的表单。您可以轻松地提供自己的设置，ModelForm以覆盖添加/更改页面上的任何默认表单行为。 如果您ModelForm和ModelAdmin双方都定义了一个exclude 选项，则ModelAdmin优先： 12345678910111213from django import formsfrom django.contrib import adminfrom myapp.models import Personclass PersonForm(forms.ModelForm): class Meta: model = Person exclude = ['name']class PersonAdmin(admin.ModelAdmin): exclude = ['age'] form = PersonForm 在上面的示例中，“年龄”字段将被排除，但“名称”字段将包含在生成的表单中。 inlines 内联样式，如下例子：GoodsInfo表和Detail表属于一对多的关系，这样可以在添加GoodsInfo页面时，添加三条Detail的数据。 12345678910111213class DetailInline(admin.TabularInline): model = Detail extra = 3@admin.register(GoodsInfo)class GoodsInfoAdmin(admin.ModelAdmin): def get_queryset(self, request): qs= super(GoodsInfoAdmin, self).get_queryset(request) if request.user.is_superuser: return qs return qs.filter(seller=request.user.id) #根据登录的用户返回数据 inlines = [DetailInline,] list_display list_display控制在列表页面显示哪些字段。例： 1list_display = ('first_name', 'last_name') 如果未设置list_display，则管理站点将只显示一列，显示_str_()每个对象的表示形式。 有四种形式的参数： 模型字段的名称。例如： 12class PersonAdmin(admin.ModelAdmin): list_display = ('first_name', 'last_name') 接受一个参数（模型实例）的可调用对象。例如： 123456def upper_case_name(obj): return (\"%s %s\" % (obj.first_name, obj.last_name)).upper()upper_case_name.short_description = 'Name'class PersonAdmin(admin.ModelAdmin): list_display = (upper_case_name,) 一个字符串，表示ModelAdmin接受一个参数（模型实例）的方法。例如： 123456class PersonAdmin(admin.ModelAdmin): list_display = ('upper_case_name',) def upper_case_name(self, obj): return (\"%s %s\" % (obj.first_name, obj.last_name)).upper() upper_case_name.short_description = 'Name' 代表模型属性或方法的字符串（无任何必需的参数）。例如： 12345678910111213from django.contrib import adminfrom django.db import modelsclass Person(models.Model): name = models.CharField(max_length=50) birthday = models.DateField() def decade_born_in(self): return self.birthday.strftime('%Y')[:3] + \"0's\" decade_born_in.short_description = 'Birth decade'class PersonAdmin(admin.ModelAdmin): list_display = ('name', 'decade_born_in') 需要注意的一些特殊情况list_display： 如果该字段为ForeignKey，则Django将显示 __str__()相关对象的。 不支持ManyToManyField字段，因为这将需要为表中的每一行执行一个单独的SQL语句。不过，如果要执行此操作，请为模型提供自定义方法，然后将该方法的名称添加到list_display。 如果该字段为BooleanField，则Django将显示一个漂亮的“ on”或“ off”图标，而不是Trueor False。 如果给定的字符串是模型的方法ModelAdmin或可调用的字符串，则Django将默认对输出进行HTML转义。要转义用户输入并允许您自己使用未转义的标签，请使用format_html()。 完整的示例代码： model.py中: 1234567891011121314151617from django.db import modelsfrom django.utils.html import format_htmlclass Person(models.Model): status=models.BooleanField(default=1,verbose_name=('上传状态')) def colored_status(self): if self.status == 0: return format_html( '&lt;span&gt;&lt;a href=\"/unlockcms/send_status/{}\"&gt;{}&lt;/a&gt;&lt;/span&gt;',self.id,'正在上传，查看详情', ) else: color_code='green' return format_html( '&lt;span style=\"color:{};\"&gt;{}&lt;/span&gt;',color_code,'上传成功', ) colored_status.short_description = u'上传状态' 在admin.py中设置： 12class VersionAdmin(admin.ModelAdmin): list_display = ('colored_status') list_display_links 默认情况下，list_display中的第一列会链接到每个项目的更改页面，但是可以通过list_display_links进行复写。 设置为None时，完全不链接。 将其设置为list_display您想要将其列转换为链接的字段列表或元组（格式与相同 ）。 可以指定一个或多个字段。只要这些字段显示在中 list_display，Django就不会在意链接了多少个字段。唯一的要求是，如果使用 list_display_links这种方式，则必须定义list_display。 list_filter设置list_filter可以激活管理员列表页面右侧的过滤器。如下图所示 list_filter应为元素的列表或元组，其中每个元素应为以下类型之一： BooleanField，CharField，DateField，DateTimeField， IntegerField，ForeignKey或ManyToManyField。 查找时也可以使用__来跨越关系查找如： 12class PersonAdmin(admin.ModelAdmin): list_filter = ('is_staff', 'company','company__name') list_per_page 设置list_per_page控制在每个列表页显示的项目条数，默认情况下为100条。如： 1list_per_page = 50 ordering 在admin中设置ordering以指定如何在Django管理视图中对对象列表进行排序，ordering参数应该为列表或者元组。 1ordering=('id',) raw_id_fields 默认情况下，Django的管理员对ForeignKey字段使用（）选择框界面。有时，不需要承担必须选择所有相关实例以显示在下拉菜单中的开销。 raw_id_fields是要更改为或Input窗口小部件的`ForeignKey``ManyToManyField字段的列表： 12class ArticleAdmin(admin.ModelAdmin): raw_id_fields = (\"newspaper\",) 该raw_id_fields Input窗口小部件应包含一个主键，如果该字段是一个ForeignKey或逗号分隔值的列表中，如果该字段为一个ManyToManyField的raw_id_fields,会在小部件旁边显示放大镜按钮，允许用户搜索和选择一个值的字段： readonly_fields 默认情况下，管理员将所有字段显示为可编辑，此选项中的任何字段（应为list或者tuple）将按原样显示其数据，并且不可编辑。在创建和标记ModelForm时也会被排除。 12class PersonAdmin(admin.ModelAdmin): readonly_fields = ('address_report',) 还可以通过方法进行控制： 123456class ModelInfoAdmin(admin.ModelAdmin): def get_readonly_fields(self, request, obj=None): if obj: if not request.user.has_perm('unlockcms.add_modelinfo'): return ['title','name'] return [] return [] save_as 设置save_as为在管理员更改表单页面的”另存为“功能。 通常，对象具有是哪个保存选项：”保存“，”保存并继续编辑“，和”保存并添加另一个“。如果save_as为True，则”保存并添加另一个“将由”另存为新“按钮代替，该按钮会创建新对象，而不是更新现有对象。 默认情况下，save_as设置为False。 save_as_continue 当save_as = True时，添加新对象的默认重定向是该对象的更改视图。如果设置save_as_continue=False，重定向将转到更改列表视图。默认情况下：save_as_continue设置为True。 save_on_top 设置save_on_top可以在管理员更改表单顶部添加保存按钮。通常，保存按钮只显示在底部。如果设置为save_on_top,则按钮同时显示在顶部和底部。 search_fields 设置search_fields为管理员列表页面启用搜索框。应该将其设置为一个字段名称列表。只要有人在该文本矿中提交搜索查询，就讲对其进行搜索。 这些字段应该是某种文本字段，例如CharField或TextField。您还可以使用ForeignKey或 ManyToManyField使用查询API来执行相关的关联查询。 123search_fields = ['foreign_key__related_fieldname']#在博客admin中按照作者邮箱查找博客条目search_fields = ['user__email'] 该搜索时按照icontains思路，搜索时不区分大小写。如果想要在搜索时区分大小写，则在最后添加exact： 1search_fields = ['first_name__exact'] show_full_result_count 设置show_full_result_count控制是否在过滤后的管理页面上显示对象的全部数量，默认为True，生成符合条件的条数。如果数量比较大时，使用比较费时。 filter_horizontal 多对多字段时可以在后台批量增加数据增加数据 12345# type，language，technology为Projects表中的多对多字段@admin.register(Projects)class ProjectsAdmin(admin.ModelAdmin): list_display = [\"project_name\", \"href\", \"url\", \"href\", \"add_time\"] filter_horizontal = [\"type\", \"language\", \"technology\"] �数据 12345# type，language，technology为Projects表中的多对多字段@admin.register(Projects)class ProjectsAdmin(admin.ModelAdmin): list_display = [\"project_name\", \"href\", \"url\", \"href\", \"add_time\"] filter_horizontal = [\"type\", \"language\", \"technology\"]","categories":[],"tags":[]},{"title":"Django的Form类","slug":"TreasureBox/python/Django/4.表单/2.Django的Form类","date":"2022-05-19T01:14:40.377Z","updated":"2023-04-28T09:25:47.146Z","comments":true,"path":"2022/05/19/treasurebox/python/django/4.biao-dan/2.django-de-form-lei/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/4.biao-dan/2.django-de-form-lei/","excerpt":"","text":"Django的From类Django表单系统的核心组件是Form类，Form类标书一张表单并决定它如何工作以及呈现。 类似模型类中的字段映射到数据库字段的方式，表单类的字段会映射到HTML表单的input元素。ModelForm通过Form映射模型类的字段到HTML表单的input元素，Django的admin就基于此。 表单字段本身也是累，他们管理表单数据并在提交表单时执行验证。DateField和FileField处理的数据类型差别较大，所以必须用来处理不同的字段。 在浏览器中，表单字段以HTML“控件”（用户界面的一个片段）的形式展现给我们，每个字段类型都有与之相匹配的控件类，但在必要时可以覆盖。 一、在Django 中构建一张表单Form类：在forms.py中去定义： 1234from django import formsclass NameForm(forms.Form): your_name = forms.CharField(label='Your name', max_length=100) 当设置了最大长度时，在前端会自动校验输入的字符的长度，在前端中的表现形式为： 12&lt;label for=\"your_name\"&gt;Your name: &lt;/label&gt;&lt;input id=\"your_name\" type=\"text\" name=\"your_name\" maxlength=\"100\" required&gt; 视图 发回Django网站的表单数据由视图来处理，一般和发布这个表单用的是同一个视图。这允许我们重用一些相同的逻辑。 为了处理标表单，需要将它实例化到一我们希望发布的URL的对应的视图中： views.py: 123456789101112131415161718192021from django.http import HttpResponseRedirectfrom django.shortcuts import renderfrom .forms import NameFormdef get_name(request): # 当POST请求时 if request.method == 'POST': # 获取提交的数据 form = NameForm(request.POST) # 检验是否符合 if form.is_valid(): #处理数据 your_name = form.cleaned_data['your_name'] return HttpResponseRedirect('/thanks/') # 当发起的是一个GET请求时，把表单返回 else: form = NameForm() return render(request, 'name.html', {'form': form}) 如果访问视图时用的GET请求，它会创建一个空的表单实例并将其放置在模板上下文中进行渲染。 如果表单提交用的是POST请求，那么该视图将再次创建一个表单实例并使用请求中的数据填充它：form = NameForm(request.POST)，叫做“将数据绑定到表单”。 调用表单的is_valid()方法；如果不为True时，讲表单返回到模板。这时表单将不再为空，所以HTML表单将用之前提交的数据进行填充，放到可以根据需要进行编辑和修正的位置。 如果is_valid()为True，我们就能在cleaned_data属性中找到所有通过验证的表单数据。 模板 在模板文件中不需要做太多的操作： 12345&lt;form action=\"/your-name/\" method=\"post\"&gt; {% csrf_token %} {{ form }} &lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt; 所有表单字段及其属性将通过Django模板语言从中被解包为HTML标记。语言从中被解包为HTML标记。","categories":[],"tags":[]},{"title":"表单的属性","slug":"TreasureBox/python/Django/4.表单/3.表单的属性","date":"2022-05-19T01:14:40.377Z","updated":"2023-04-28T09:25:47.146Z","comments":true,"path":"2022/05/19/treasurebox/python/django/4.biao-dan/3.biao-dan-de-shu-xing/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/4.biao-dan/3.biao-dan-de-shu-xing/","excerpt":"","text":"表单的属性一、绑定和非绑定形式 is_bound 如果将其绑定到一组数据中，则可以验证该数据并将表单显示为HTML，并将数据显示在HTML中。 如果未绑定，则无法进行验证（因为没有要验证的数据！），但仍可以将空白表单呈现为HTML。 要创建一个Form示例，只需要实例化该类： 1f = ContactForm() 要将数据绑定到表单，需要将数据作为字典传递给Form类构造函数的第一个参数： 12345data = {'subject': 'hello', 'message': 'Hi there', 'sender': 'foo@example.com', 'cc_myself': True}f = ContactForm(data) 在该字典中，键是字段名称，字段名称与Form类中的属性相对应，这些值是想要验证的数据，通常这些都是字符串，但不强制要求是字符串。 如果需要在运行时区分绑定表单实例和未绑定表单实例，需要检查is_bound属性的值。 123456789f = ContactForm()f.is_boundFalsef = ContactForm({'subject': 'hello'})f.is_boundTruef = ContactForm({})f.is_boundTrue 二、使用表单验证数据 is_valid() Form对象的主要任务是验证数据。对于绑定的Form实例，调用is_valid()方法以验证并返回一个布尔值，指定数据是否有效： 1234567data = {'subject': 'hello', 'message': 'Hi there', 'sender': 'foo@example.com', 'cc_myself': True}f = ContactForm(data)f.is_valid()True 当数据无效时：如subject为空白（所有的字段都是必需的），sender并不是有效的电子邮件地址： 1234567data = {'subject': '', 'message': 'Hi there', 'sender': 'invalid email address', 'cc_myself': True}f = ContactForm(data)f.is_valid()False errors 获取错误消息字典。 12f.errors{'sender': ['Enter a valid email address.'], 'subject': ['This field is required.']} 在此字典中，键是字段名称，值是代表错误消息的字符串列表。错误消息存储在列表中，因为一个字段中可能包含多个错误消息。 当使用errors时不需要调用is_valid()，表格在调用is_valid()时或者使用errors时自动生成errors。 errors.as_data() 返回一个dict将字段映射到其原始ValidationError实例。 123f.errors.as_data(){'sender': [ValidationError(['Enter a valid email address.'])],'subject': [ValidationError(['This field is required.'])]} 每当需要通过错误标识错误时，都可以使用此方法。 errors.as_json() 返回序列化为JSON的错误： 123f.errors.as_json(){\"sender\": [{\"message\": \"Enter a valid email address.\", \"code\": \"invalid\"}],\"subject\": [{\"message\": \"This field is required.\", \"code\": \"required\"}]} 默认情况下，as_json()不转义输出。如果将其应用于表单视图的Ajax请求，客户端将揭示该相应并将错误插入页面， initial initial用于在运行时生命表单字段的初始值，此时，可以使用initial参数。如果提供此参数，则应为将字段名称映射到初始值的字典。仅包要为其指定初始值的字段，不必再表单中包含每个字段。如： 1f = ContactForm(initial={'subject': 'Hi there!'}) has_changed() 当需要检查表单数据是否已从初始数据更改时，使用has_changed()验证表单： 1234567data = {'subject': 'hello', 'message': 'Hi there', 'sender': 'foo@example.com', 'cc_myself': True}f = ContactForm(data, initial=data)f.has_changed()False 提交表单后，对数据进行重构并提供原始数据，以便进行比较： 12f = ContactForm(request.POST, initial=data)f.has_changed() 如果request.POST中的数据不同于提供的initial值，则结果为True，否则为False。通过使用Field.has_changed()可以计算表单中每个字段的结果。 changed_data 如果这些字段绑定的值（通常是request.POST）与提供的initial值不同，就返回字段名称的列表。如果没有数据不同，将返回一个空列表。 123f = ContactForm(request.POST, initial=data)if f.has_changed(): print(\"The following fields changed: %s\" % \", \".join(f.changed_data)) if f.has_changed(): print(“The following fields changed: %s” % “, “.join(f.changed_data))```","categories":[],"tags":[]},{"title":"表单概述","slug":"TreasureBox/python/Django/4.表单/1.表单概述","date":"2022-05-19T01:14:40.377Z","updated":"2023-04-28T09:25:47.145Z","comments":true,"path":"2022/05/19/treasurebox/python/django/4.biao-dan/1.biao-dan-gai-shu/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/4.biao-dan/1.biao-dan-gai-shu/","excerpt":"","text":"表单概述一、HTML表单在HTML中，表单是在 &lt;form&gt;...&lt;/form&gt; 中的一些元素，它允许访客做一些类似输入文本、选择选项、操作对象或空间等动作，然后发送这些信息到服务端。 一些表单界面元素（文本框或复选框）非常简单并内置在HTML中。其他会复杂些；像弹出日期选择或者允许移动滑块或者操作控件，一般通过使用JavaScript，CSS以及HTML表单中的 &lt;input&gt; 元素来实现这些效果。 和它的 &lt;input&gt; 元素一样，表单必须指定两样东西： 何地（action）：负责响应用户输入数据的URL地址 如何（method）：数据请求使用的HTTP方法。 二、GET和POSTGET和POST是处理表单时唯一使用的HTTP方法： POST：浏览器将表单数据打包，编码以进行传输，将其发送到服务器，然后接收其响应。 GET：相比于POST，GET请求会将数据捆绑为一个字符串，然后使用该字符串来组成一个URL。该URL包含必须将数据发送到的地址以及数据键和值。类似：https://docs.djangoproject.com/search/?q=forms&amp;release=1 GET和POST通常应用于不同的目的： 任何可能用于更改系统状态的请求应该使用POST，不如更改数据库的请求，GET应该只被用与不也会影响系统状态的请求。 在WEB应用的管理表达那种使用GET请求具有安全隐患：攻击者很容易通过模拟请求来访问系统的敏感数据。 在django中编写一个视图跳过CSRF验证： from django.views.decorators.csrf import csrf_exempt@csrf_exempt def xxx(request): ​ … … ​ return …rn …","categories":[],"tags":[]},{"title":"标签","slug":"TreasureBox/python/Django/3.模板层/2.标签","date":"2022-05-19T01:14:40.376Z","updated":"2023-04-28T09:49:35.416Z","comments":true,"path":"2022/05/19/treasurebox/python/django/3.mo-ban-ceng/2.biao-qian/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/3.mo-ban-ceng/2.biao-qian/","excerpt":"","text":"标签标签比变量更复杂：一些在输出中创建文本，一些通过执行循环或逻辑来控制流，有些将外部信息加载到模板中以供以后的变量使用。{% tag %}` 一些标签需要开始和结束标签。例如： `{% tag %} ... tag contents ... {% endtag %} 官网链接：https://docs.djangoproject.com/zh-hans/2.1/ref/templates/language/ csrf_token 抵挡跨域攻击，用于form表单的post提交时使用。 cycle 每次遇到此标签时，都会产生其参数之一。第一个参数在第一次遇到时产生，第二个参数在第二次遇到时产生，依此类推。一旦所有参数用尽，标记将循环到第一个参数并再次产生它。 12345&gt;{% for o in some_list %} &lt;tr class=\"{% cycle 'row1' 'row2' %}\"&gt; ... &lt;/tr&gt;{% endfor %} 在某些情况下，您可能希望引用循环的当前值而不前进到下一个值。为此，只需使用“ as” 为标签命名，如下所示：{% cycle %} {% cycle 'row1' 'row2' as rowcolors %} 命名之后，可以通过将循环名称作为上下文变量引用，在模板中的任意位置插入循环的当前值。如果要独立于原始cycle标签将循环移动到下一个值，则 可以使用另一个cycle标签并指定变量的名称。因此，以下模板： &lt;tr&gt; &lt;td class=\"{% cycle 'row1' 'row2' as rowcolors %}\"&gt;...&lt;/td&gt; &lt;td class=\"{{ rowcolors }}\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"{% cycle rowcolors %}\"&gt;...&lt;/td&gt; &lt;td class=\"{{ rowcolors }}\"&gt;...&lt;/td&gt; &lt;/tr&gt; 将输出： &lt;tr&gt; &lt;td class=\"row1\"&gt;...&lt;/td&gt; &lt;td class=\"row1\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"row2\"&gt;...&lt;/td&gt; &lt;td class=\"row2\"&gt;...&lt;/td&gt; &lt;/tr&gt; extends表示此模板扩展了父类模板。该标签可以用两种方式使用。 {% extends \"base.html\" %}（带引号）使用文字值 \"base.html\"作为要扩展的父模板的名称。 {% extends variable %}使用的值variable。如果该变量的值为字符串，则Django将使用该字符串作为父模板的名称。如果变量的值是一个Template对象，则Django将使用该对象作为父模板。 在中template.html，以下路径将有效： 123{% extends \"./base2.html\" %}{% extends \"../base1.html\" %}{% extends \"./my/base3.html\" %} firstof 输出第一个不是False的变量。如果所有传递的变量均为False，则不输出任何内容。 1{% firstof var1 var2 var3 %} 1234567{% if var1 %} {{ var1 }}{% elif var2 %} {{ var2 }}{% elif var3 %} {{ var3 }}{% endif %} 如果所有传递的变量均为False，则还可以使用文字字符串作为后备值： 1{% firstof var1 var2 var3 \"fallback value\" %} 您可以使用语法将输出存储在变量中。{% firstof var1 var2 var3 as value %} for 循环访问数组中的每个项目，使该项目在上下文变量中可用。例如，显示以下项中提供的运动员列表 athlete_list： 12345&lt;ul&gt;{% for athlete in athlete_list %} &lt;li&gt;{{ athlete.name }}&lt;/li&gt;{% endfor %}&lt;/ul&gt; 同样可以使用反向遍历列表：","categories":[],"tags":[]},{"title":"自定义过滤器和标签","slug":"TreasureBox/python/Django/3.模板层/4.自定义过滤器和标签","date":"2022-05-19T01:14:40.376Z","updated":"2023-04-28T09:25:47.169Z","comments":true,"path":"2022/05/19/treasurebox/python/django/3.mo-ban-ceng/4.zi-ding-yi-guo-lu-qi-he-biao-qian/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/3.mo-ban-ceng/4.zi-ding-yi-guo-lu-qi-he-biao-qian/","excerpt":"","text":"自定义模板和过滤器Django的模板语言带有多种内置标签和过滤器，用于满足应用程序的逻辑需求。但是，当这些不能满足需求时。您可以通过使用Python定义自定义标签和过滤器来扩展模板引擎，然后使用{% load %}标签在模板中引入。 一、代码布局将Django应用程序添加到INSTALLED_APPS中，它在以下所述的常规位置中定义的所有标签都会自动变为可加载到模板中。该应用程序应该包含一个templatetags目录，在相同的水平 models.py，views.py等等文件。 自定义标签和过滤器将位于templatetags 目录内的模块中。模块文件的名称是以后用来加载标签的名称，因此需要选择一个不会与另一个应用程序中的自定义标签和过滤器冲突的名称。 如果您的自定义标签/过滤器位于名为的文件中 meishi_extras.py，整个目录结构为： 在模板文件中使用{% load meishi_extras%} 放在templatetags包中的模块数量没有限制，使用{% load %}加载的是模块名称，而不是标签/过滤器。 为了成为一个有效的标签库，模块名称必须包含一个名为模块级变量register，该template.Library实例是一个实例，在其中注册了所有的标签和过滤器。因此在模块顶部放置以下内容： 123from django import templateregister = template.Library() 二、编写自定义的模板过滤器自定义的过滤器就是一些有一到两个参数的python函数 （输入的）变量的值，不一定是字符串类型。 参数的值可以有一个默认值，或者被排除在外。 例：在过滤器{{ var|foo:\"bar\" }}中，变量var和参数bar会传递给过滤器foo。 因为在模板语言不提供异常处理机制，所以任何从模板过滤器中抛出的异常都将被视为服务器异常。因此，如果有一个合理的返回值将要被返回的话，过滤器函数应当避免产生异常。万一模板中出现有明显错误的输入，产生异常也仍然比隐藏这个bug要好。 过滤器示例： 123def cut(value, arg): \"\"\"将value中的arg全部替换掉\"\"\" return value.replace(arg, '') 在模板中使用： 1{{ number|cut:\"0\" }} 大部分的过滤器并没有参数。这样的话，只需要把这些参数从函数中去掉就好。例子如下： 123def lower(value): \"\"\"把所有的英文字符转化为小写\"\"\" return value.lower() 三、注册自定义过滤器每当写好自定义的过滤器时候，需要用Library实例去注册它，从而让他对于Django模板语言是可用的。 12register.filter('cut', cut)register.filter('lower', lower) Library.filter()方法有两个参数： 筛选器的名称——字符串 编写的python函数。 可以使用register.filter()装饰器来注册： 1234567@register.filter(name='cut')def cut(value, arg): return value.replace(arg, '')@register.filterdef lower(value): return value.lower() 如果不使用name参数时，如上面第二个示例所示，Django将使用函数的名称作为过滤器的名称。register.filter()函数还接受三个关键字参数，is_safe,needs_autoescape和expects_localtime。 如果编写的模板过滤器仅将字符串作为第一个参数，则应使用decorator stringfilter。在对象传递给函数之前将其转换为字符串值，这样在传入一个整数时，不会导致AttributeError。 123456789from django import templatefrom django.template.defaultfilters import stringfilterregister = template.Library()@register.filter@stringfilterdef lower(value): return value.lower() def lower(value): return value.lower() ###","categories":[],"tags":[]},{"title":"模板继承与加载","slug":"TreasureBox/python/Django/3.模板层/3.模板继承与加载","date":"2022-05-19T01:14:40.376Z","updated":"2023-04-28T09:25:47.165Z","comments":true,"path":"2022/05/19/treasurebox/python/django/3.mo-ban-ceng/3.mo-ban-ji-cheng-yu-jia-zai/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/3.mo-ban-ceng/3.mo-ban-ji-cheng-yu-jia-zai/","excerpt":"","text":"模板继承与加载一、模板继承Django模板引擎中最强大（因此也是最复杂）的部分是模板继承。模板继承可以构建基本的“骨架”模板，该模板包含站点的所有常见元素并定义子模板可以覆盖的块。 例： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;title&gt;{% block title %}My amazing site{% endblock %}&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"sidebar\"&gt; {% block sidebar %} &lt;ul&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/blog/\"&gt;Blog&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; {% endblock %} &lt;/div&gt; &lt;div id=\"content\"&gt; {% block content %}{% endblock %} &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 该模板称为base.html，定义了一个简单的HTML框架文档，可以将其用于一个简单的两列页面。“子”模板的工作是用内容填充空白块。 在此示例中，block标记定义了子模板可以填充的三个块。block标记所做的只是告诉模板引擎子模板可以覆盖模板的那些部分。 子模板可能如下所示： 12345678910{% extends \"base.html\" %}{% block title %}My blog{% endblock %}{% block content %}{% for entry in blog_entries %} &lt;h2&gt;{{ entry.title }}&lt;/h2&gt; &lt;p&gt;{{ entry.body }}&lt;/p&gt;{% endfor %}{% endblock %} extends标签是这里的关键。它告诉模板引擎该模板“扩展”了另一个模板。模板系统评估该模板时，首先会找到父模板，在本例中为“ base.html”。 届时，模板引擎将注意到其中的三个block标记，base.html并用子模板的内容替换这些块。根据的值blog_entries，输出可能类似于： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;title&gt;My amazing blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"sidebar\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/blog/\"&gt;Blog&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"content\"&gt; &lt;h2&gt;Entry one&lt;/h2&gt; &lt;p&gt;This is my first entry.&lt;/p&gt; &lt;h2&gt;Entry two&lt;/h2&gt; &lt;p&gt;This is my second entry.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 请注意，由于子模板未定义sidebar块，因此将使用父模板中的值。 父模板中标签内的内容始终用作后备。{% block %}` 可以根据需要使用任意多个继承级别。使用继承的一种常见方法是以下三个级别的方法： - 创建一个`base.html`包含网站主要外观的模板。 - `base_SECTIONNAME.html`为站点的每个“部分” 创建一个模板。例如`base_news.html`，`base_sports.html`。这些模板全部扩展，`base.html`并包括特定于部分的样式/设计。 - 为每种类型的页面（例如新闻文章或博客条目）创建单独的模板。这些模板扩展了相应的节模板。 这种方法最大程度地提高了代码重用性，并易于将项目添加到共享内容区域，例如部分范围的导航。 以下是使用继承的一些技巧： - 如果在模板中使用，则它必须是该模板中的第一个模板标记。否则模板继承将不起作用。 - 在基本模板更多的标签是更好的。请记住，子模板不必定义所有父块，因此可以在许多块中填写合理的默认值，然后仅在以后定义所需的块。最好有更多的块而不是更少的块。 - 如果发现自己在多个模板中复制内容，则可能意味着您应该将该内容移至父模板中的`{%block %}` - 如果需要从父模板中获取块的内容，则可以使用变量来解决问题。如果要添加到父块的内容而不是完全覆盖它，这将很有用。 - 使用模板标记语法在a外部创建的变量不能在块内部使用。例如，此模板不呈现任何内容：[`{% block %}`](https://docs.djangoproject.com/zh-hans/2.1/ref/templates/builtins/#std:templatetag-block)`as` 12{% trans \"Title\" as title %}{% block content %}{{ title }}{% endblock %} - 对于额外的可读性，您可以选择给一个*名字*到您的 标签。例如：`{% endblock %} 123{% block content %}...{% endblock content %} 注意:不能block在同一模板中定义多个具有相同名称的标签。存在此限制的原因是，块标签在“两个”方向上均起作用。也就是说，block标签不仅提供填充孔，还定义了填充父级孔的内容。如果block模板中有两个名称相似的标签，则该模板的父级将不知道要使用哪个块内容。 二、模板的转义要控制模板的自动转义，请将模板（或模板的特定部分）包装在autoescape标记中，如下所示： 123{% autoescape off %} Hello {{ name }}{% endautoescape %} 该autoescape标签采用两种on或off作为其参数。有时，可能想强制自动转义，否则会被禁用。这是一个示例模板： 12345678910Auto-escaping is on by default. Hello {{ name }}{% autoescape off %} This will not be auto-escaped: {{ data }}. Nor this: {{ other_data }} {% autoescape on %} Auto-escaping applies again: {{ name }} {% endautoescape %}{% endautoescape %} 三、模板的加载加载模板并使用当前上下文呈现它。这是在模板中“包含”其他模板的一种方式。 模板名称可以是变量，也可以是硬编码（带引号）的字符串，用单引号或双引号引起来。 此示例包括模板的内容\"foo/bar.html\"： 1{% include \"foo/bar.html\" %} 通常，模板名称是相对于模板加载器的根目录而言的。字符串参数也可以是以标记开头./或../ 在extends标记中所述的相对路径。 此示例包含名称包含在变量中的模板的内容template_name： 1{% include template_name %} 该变量也可以是带有render()接受上下文的方法的任何对象。 1{% include template_name %} 该变量也可以是带有render()接受上下文的方法的任何对象。","categories":[],"tags":[]},{"title":"字段约束","slug":"TreasureBox/python/Django/1.模型层/4.字段约束","date":"2022-05-19T01:14:40.375Z","updated":"2023-04-28T09:25:47.163Z","comments":true,"path":"2022/05/19/treasurebox/python/django/1.mo-xing-ceng/4.zi-duan-yue-shu/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/1.mo-xing-ceng/4.zi-duan-yue-shu/","excerpt":"","text":"字段约束2、字段约束(1) null：默认为False，当设置为True时，该字段插入数据时可以为空，使用NULL进行填充。 (2) blank：默认为False，为False时在admin后台中表单必须要填内容，为True时可以允许表单为空。一般与null=True或defalut连用。 (3) choices：接收一个可重复的列表或元组（基本单位为二元组）。如果指定了该参数，在实例化该模型时，该变量只能选择列表中的值。 如： 123456789class Person(models.Model): SHIRT_SIZES = ( ('S', 'Small'), ('M', 'Medium'), ('L', 'Large'), ) name = models.CharField(max_length=60) shirt_size = models.CharField(max_length=1,choices=SHIRT_SIZES) (4) default：该变量的值，可以是一个值或者是一个可调用的对象，如果是个可调用的对象，每次实例化模型时都会调用该对象。默认不能是可变对象（模型实例，list，set等），作为该对象的相同实例的引用将被用作在所有新的模型实例的默认值。而是将所需的默认值包装在可调用中。例如，如果要指定一个默认dict的JSONField，使用函数： 123def contact_default(): return {\"email\": \"to1@example.com\"}contact_info = JSONField(\"ContactInfo\", default=contact_default) (5) help_text：额外的帮助文本，将与表单窗口小部件仪器显示，即使字段未在表单上使用，对于文档记录很有帮助。 (6) primary_key：如果设置为True，则该初始设置为该模型的主键。在一个模型中，如果没有对任何一个字段设置primary_key=True选项。Djnago中会自动添加一个IntegerField字段，用于设置为主键，因此除非像重写默认的主键，否则可以不手动设置主键。 (7) unique：如果设置为True，这个细分必须在整个表中保持值唯一。 (8) verbose_name：该字段的易读名称。如果未提供详细名称，则Django将使用字段的属性名称自动创建，将下划线转换为空格。在admin管理后台中会显示该名称。 (9) db_colum：用于此字段的数据库序列名称。如果未指定，Django将使用该字段的名称。 (10) db_index：如果为True，将为此字段创建数据库索引。 (11) db.tablespace：如果该字段已创建索引，则用于该字段的索引为数据库表空间的名称。默认值是项目的DEFAULT_INDEX_TABLESPACE设置（如果已设置），或者 db_tablespace是模型的设置（如果有）。如果后端不支持索引的表空间，则可以忽略。PostgreSQL和Oracle支持表空间。SQLite和MySQL不支持。 (12) editable：如果为False，则该字段将不会显示在管理员或其它任何人中ModelForm。在模型验证期间也将跳过他们。默认值为True。 (13) Error_messages：参数可以覆盖还该字段将引发的默认消息。传递一个包含与您要覆盖的错误消息相匹配的键的字典。错误消息包括：null,blank,invalid,invalid_choice,unique,和unique_for_date。 (14) unique_for_date：将设置为DateField或DateTimeField的日期字段的值是唯一的。当字段为DateTimeField时，仅考虑字段的日期部分。 (15) unique_for_month：要求该字段相对于月份是唯一的。 (16) unique_for_year：要求该字段对于年份是唯一的。 (17)validators：要为此字段运行的验证器列表。验证器示例： 12345678from django.core.exceptions import ValidationErrorfrom django.utils.translation import gettext_lazy as _def validate_even(value): if value % 2 != 0: raise ValidationError( _('%(value)s is not an even number'), params={'value': value}, ) (18)validators:用于方便主表查从表中的数据。可以把引用理解为主从关系，主引用从，即一对多 , 注意外键字段是放在多的一端的，比如一个班级class 有很多同学 students,那么就在students类里面设置class字段值是外键类型从students拿class数据很好拿, studets.class就拿到了。但是从class 拿students数据 就不好拿了,当然也可以拿,默认的方式是class.students_set.all() 也可以拿到不过这样麻烦,简单一点就是设置一个related_name=classs属性直接 class.classs.all() 就可以了。�直接 class.classs.all() 就可以了。","categories":[],"tags":[]},{"title":"QuerySet API","slug":"TreasureBox/python/Django/1.模型层/5.QuerySet API","date":"2022-05-19T01:14:40.375Z","updated":"2023-04-28T09:25:47.156Z","comments":true,"path":"2022/05/19/treasurebox/python/django/1.mo-xing-ceng/5.queryset-api/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/1.mo-xing-ceng/5.queryset-api/","excerpt":"","text":"QuerySet API使用QuerySet可以构造、过滤、切片、和大致的结果而不实际访问数据库。除非执行某些操作来评估查询集，否则实际上不会发生对数据库的查询活动。 (1) 基本属性 迭代 QuerySet是可迭代的，并且在第一次对其迭代是会执行其数据库查询。如： 12for e in Entry.objects.all(): print(e.headline) 切片 可以使用python的数组切片语法对QuerySet集进行切片操作。 len 返回QuerySet列表的长度。 list 使用list()进行强制转化。entry_list = list(Entry.objects.all()) exists 判断结果集中是否存在至少一个结果。Entry.objects.all().exists()。 (2) 查询 filter ​ 条件查找，是一个结果集，多个条件时使用逗号(,)隔开。Entry.objects.filter(id=3,name=’张三’)。 exclude 筛选出与给定查找参数不匹配的结果，是一个结果集，多个条件时使用逗号(,)隔开。Entry.objects.exclude(id=3,name=’张三’)。括号里面的参数属于and关系。当想使用or关系时要写多个exclude()。 annotate 表达式可以是简单值，也可以是对模型（或任何相关模型）上字段的引用，也可以是针对与对象中的对象相关的对象计算出的聚合表达式（平均值，总和等） 12from django.db.models import Countq = Blog.objects.annotate(Count('entry')) order_by ​ 默认情况下可以在Meta给出的ordering排序元组进行排序，可以使用order_by()对ordering的方法进行覆盖，额外对查询结果进行排序。 如： 1Entry.objects.order_by('headline') 在字段名称前加负号(-)代表降序。 如果想要随机排序，可以使用”?”，如下： 1Entry.objects.order_by('?') 注意：order_by(‘?’)查询比较缓慢。 多次使用order_by时会使前边的排序规则失效。 reverse 使用reverse()可以翻转查询集元素的返回顺序。如：检索查询集中”最后”五个项目，可以执行以下操作： 1Entry.objects.order_by('headline').reverse()[:5] distinct 消除重复的行。 12Entry.objects.order_by('pub_date').distinct('pub_date')Entry.objects.order_by('blog').distinct('blog') values 返回QuerySet用作迭代器时返回的字典，而不是模型实例，这些词典中的每一个都代表对象，键对应于模型对象的属性名称。 1234Blog.objects.filter(name__startswith='Beatles')#&lt;QuerySet [&lt;Blog: Beatles Blog&gt;]&gt;Blog.objects.filter(name__startswith='Beatles').values()#&lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&gt; values()方法可以采用可选的位置参数，如果指定字段，则每个字典将仅包含指定的字段的键/值，如果不指定字段，则每个字段将为数据库表忠中的每个字段包含一个键和值。如： 12345Blog.objects.values()#&lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&gt;Blog.objects.values('id', 'name')#&lt;QuerySet [{'id': 1, 'name': 'Beatles Blog'}]&gt; values()子句中的聚合在同一values()子句中的其他参数之前应用。如果需要按另一个值分组，请将其添加到更早的values()子句中。例如： 123456from django.db.models import CountBlog.objects.values('entry__authors',entries=Count('entry'))#&lt;QuerySet [{'entry__authors': 1, 'entries': 20}, {'entry__authors': 1, 'entries': 13}]Blog.objects.values('entry__authors').annotate(entries=Count('entry'))#&lt;QuerySet [{'entry__authors': 1, 'entries': 33}]&gt; values_list 类似于values，但是返回元组形式的数据，每个元组包含来自传递到values_list()中调用的相应字段或表达式的值。 123456 Entry.objects.values_list('id', 'headline')#&lt;QuerySet [(1, 'First entry'), ...]&gt;from django.db.models.functions import Lower Entry.objects.values_list('id', Lower('headline'))#&lt;QuerySet [(1, 'first entry'), ...]&gt; 如果仅传递单个字段，则也可以传递flat参数。如果flat为True，则表示返回的结果是单个值，而不是一个元组。 12345Entry.objects.values_list('id').order_by('id')#&lt;QuerySet[(1,), (2,), (3,), ...]&gt;Entry.objects.values_list('id', flat=**True**).order_by('id')#&lt;QuerySet [1, 2, 3, ...]&gt; 可以通过named=True来获取结果named tuple() 12Entry.objects.values_list('id', 'headline', named=**True**)QuerySet [Row(id=1, headline='First entry'), ...]&gt; 如果不向values_list()中传递任何值，则按照声明的顺序返回模型中的所有字段，通常需要获取某个模型实例的特定字段值，因此需要values_list()配合get()使用。 12Entry.objects.values_list('headline', flat=**True**).get(pk=1)#'First entry' dates dates（field，kind，order =’ASC’），返回结果是一个QuerySet，结果是一个datetime.date对象列表，该对象列表表示的内容中也定种类的所有可用日期QuerySet。 Field应该是DateField类型，kind可以为year，month，week，day。 “year”返回该字段的所有不同年份值的列表。 “month”返回该字段的所有不同年份/月份值的列表。 “week”返回该字段的所有不同年份/星期值的列表。所有日期均为星期一。 “day”返回该字段所有不同年/月/日值的列表。 none 创建一个空的查询集，该查询集不返回任何对象，并且在访问结果时不执行任何操作。 123456Entry.objects.none()&lt;QuerySet []&gt;from django.db.models.query import EmptyQuerySetisinstance(Entry.objects.none(), EmptyQuerySet)True all 查询所有的数据。 raw 执行该查询会进行原始SQL查询。 12for p in Person.objects.raw('SELECT * FROM myapp_person'): print(p) #John SmithJane Jones Q and（&amp;）连接符： from django.db.models import Q 以下为等价查询： 1234Model.objects.filter(x=1) &amp; Model.objects.filter(y=2)Model.objects.filter(x=1, y=2) Model.objects.filter(Q(x=1) &amp; Q(y=2))等效于 SELECT ... WHERE x=1 AND y=2 or(|) 123Model.objects.filter(x=1) | Model.objects.filter(y=2)from django.db.models import QModel.objects.filter(Q(x=1) | Q(y=2)) SQL等效项： SELECT … WHERE x=1 OR y=2; contains 模糊查询，区分大小写。 1Entry.objects.get(headline__contains='Lennon') icontains 模糊查询，不区分大小写。 1Entry.objects.get(headline__icontains='Lennon') in 查询在列表、元组或其他查询集中的数据，也可接收字符串。 123Entry.objects.filter(id__in=[1, 3, 4])Entry.objects.filter(headline__in='abc') ​ 等价于： 123SELECT ... WHERE id IN (1, 3, 4);SELECT ... WHERE headline IN ('a', 'b', 'c'); gt 大于。 1Entry.objects.filter(id__gt=4) gte 大于等于。 1Entry.objects.filter(id__gte=4) lt 小于。 1Entry.objects.filter(id__lt=4) lte 小于等于。 1Entry.objects.filter(id__lte=4) startswith 区分大小写，以….开头 1Entry.objects.filter(headline__startswith='Lennon') istartswidth 不区分大小写，以…开头 1Entry.objects.filter(headline__istartswith='Lennon') endswith 区分大小写，以…结束 1Entry.objects.filter(headline__endswith='Lennon') iendswith 区分大小写，以…结束 1Entry.objects.filter(headline__iendswith='Lennon') range 范围查询。 1234567import datetimestart_date = datetime.date(2005, 1, 1)end_date = datetime.date(2005, 3, 31)Entry.objects.filter(pub_date__range=(start_date, end_date)) F F允许Django在未实际链接数据的情况下，具有对数据库字段的值的引用。通常情况下会在更新数据时先从数据库里对原始数据取出后放在内存里，然后编辑某些属性进行提交。如： 123order = Order.objects.get(orderid='123456789')order.amount += 1order.save() 此时的SQL语句等效为： 12UPDATE core_order SET ..., amount = 22 WHERE core_order.orderid = '123456789' # ...表示Order中的其他值，在这里会重新赋一遍值; 22表示为计算后的结果 当使用F()函数时： 123456from django.db.models import Ffrom core.models import Order order = Order.objects.get(orderid='123456789')order.amount = F('amount') - 1order.save() 此时SQL语句等价于： 1UPDATE core_order SET ..., amount = amount + 1 WHERE core_order.orderid = '123456789' 在使用此种方法跟新数据之后，需要重新加载数据来使数据库中的值与程序中的值对应： 1234order= Order.objects.get(pk=order.pk) # 或者使用更加简单的方法：order.refresh_from_db() (3) 不适用于缓存的查询 count 返回一个整数，该整数表示数据库中与匹配的对象数。 in_bulk 获取字段值（id_list）和filed_name这些值的列表，并返回将每个值映射到具体给定字段值的对象实例的字典。如果id_list未提供，则返回查询集中所有对象。Filed_name必须是唯一字段，并且默认为主键。 123456789101112131415 Blog.objects.in_bulk([1])#{1: &lt;Blog: Beatles Blog&gt;} Blog.objects.in_bulk([1, 2])#{1:&lt;Blog:BeatlesBlog&gt;,2:&lt;Blog:CheddarTalk&gt;}Blog.objects.in_bulk([]){}Blog.objects.in_bulk()#{1: &lt;Blog: Beatles Blog&gt;, 2: &lt;Blog: Cheddar Talk&gt;, 3: &lt;Blog: Django Weblog&gt;}Blog.objects.in_bulk(['beatles_blog'], field_name='slug')#{'beatles_blog': &lt;Blog: Beatles Blog&gt;} 注意： 如果在in_bluk中传递一个空列表，则会得到一个空字典。 latest 根据给定的字段返回列表中的最新对象。例： 1Entry.objects.latest('pub_date') first 返回结果集中匹配到的第一个对象。 1p = Article.objects.order_by('title', 'pub_date').first() last 类似于first，返回结果集中的最后一个。 aggregate 返回计算出的合计值（平均值、总和等）的字典QuerySet。每个参数都指定一个值，该值将包含在返回的字典中。例： 1234from django.db.models import Countq = Blog.objects.aggregate(Count('entry')){'entry__count': 16} get 根据条件查询单条数据，查不到时会报错。如果希望结果集中返回一行，则可以使用get()不加任何参数的行来返回改行的对象： 1entry = Entry.objects.filter(...).exclude(...).get() (4) 保存 create 可以一步创建对象并将其全部保存： 1p = Person.objects.create(first_name=\"Bruce\", last_name=\"Springsteen\") save 123p = Person(first_name=\"Bruce\", last_name=\"Springsteen\")p.save(force_insert=**True**) 或者： 1234P=Person()p.first_name=\"Bruce\"p.last_name=\"Springsteen\"p.save() get_or_create 一种使用给定查找对象的便捷方法kwargs（如果模型的所有字段均具有默认值，则为空），并在必要时创建一个对象。 update_or_create 一种使用给定对象更新对象的便捷方法，该update_or_create方法尝试根据给定的值从数据库中获取对象kwargs。如果找到匹配项，它将更新defaults字典中传递的字段 。 (5) 修改 update 对指定的字段执行SQL更新查询，并返回匹配的行数（如果某些行已经具有新值，则该行数可能不等于更新的行数） 1Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline='This is old') save 使用save方法进行修改。 1234e = Entry.objects.get(id=10)e.comments_on = Falsee.save() (6) 删除 delete 对QuerySet执行删除操作。例： 123Entry.objects.filter(blog=b).delete()#(4, {'weblog.Entry': 2, 'weblog.Entry_authors': 2}) .objects.filter(pub_date__year=2010).update(comments_on=False, headline=’This is old’) 123456789102. **save** 使用save方法进行修改。 ```python e = Entry.objects.get(id=10) e.comments_on = False e.save() (6) 删除 delete 对QuerySet执行删除操作。例： 123Entry.objects.filter(blog=b).delete()#(4, {'weblog.Entry': 2, 'weblog.Entry_authors': 2})","categories":[],"tags":[]},{"title":"URL调度器","slug":"TreasureBox/python/Django/2.视图层/1.URL调度器","date":"2022-05-19T01:14:40.375Z","updated":"2023-04-28T09:25:47.151Z","comments":true,"path":"2022/05/19/treasurebox/python/django/2.shi-tu-ceng/1.url-diao-du-qi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/2.shi-tu-ceng/1.url-diao-du-qi/","excerpt":"","text":"URL调度器一、请求处理流程1from django.urls import path,include 当一个用户请求Django站点的页面时，Django系统按以下流程执行python代码： Django首先确定要使用的根URLconf模块，通常，这是在settings.py中设置的ROOT_URLCONF的值。但是如果传入HttpRequest对象具有urlconf 属性（由中间件设置），则将使用其值代替ROOT_URLCONF设置。 Django加载该Python模块并查找变量 urlpatterns。这是django.urls.path() 和/或django.urls.re_path()实例的Python列表。 Django依次匹配每个URL模式，在与请求的URL匹配的第一个模式停下来。 一旦与其中一个URL模式匹配，Django就会导入并调用给定的视图，该视图是一个简单的Python函数（或基于类的视图）。该视图将传递以下参数： 一个HttpRequest实例。 如果匹配的URL模式未返回命名组，则来自正则表达式的匹配项将作为位置参数。 关键字参数由与路径表达式匹配的任何命名部分组成，并由可选的kwargs参数中指定的任何参数覆盖 。django.urls.path()django.urls.re_path() 如果没有URL模式匹配，或者在此过程中的任何时候引发异常，Django都会调用一个适当的错误处理视图。 二、URL中携带的参数 在URL中传递的参数，要使用尖括号去传递参数。 1path('articles/&lt;int:year&gt;/', views.year_archive), 参数的类型 str 匹配任何非空字符串，但路径分隔符除外’/‘。如果在表达式中不包含转换器，则为默认设置。 int 匹配零或任何正整数。返回一个int。 slug 匹配一个由ASCII字母或数字以及连字符和下划线字符组成的任何条形字符串。 uuid 匹配格式化的UUID。为防止多个URL映射到同一页面，必须包含破折号并且字母必须小写。例如：075194d3-6885-417e-a8a8-6c931e272f00 path 匹配任何非空字符串，包括路径分隔符’/‘。可以匹配完整的URL路径进行匹配，而不仅仅是与URL路径的一部分进行匹配str。 三、使用正则表达式​ 如果路径和转换器不足以定义URL模式时，则还可以使用正则表达式。此时可以使用re_path()代替path()。在python正则表达式中，命名真这个表达式组的语法为(?Ppattern)，name为组的名称，pattern是匹配的某种模式。 12345678910from django.urls import path, re_pathfrom . import viewsurlpatterns = [ path('articles/2003/', views.special_case_2003), re_path(r'^articles/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive), re_path(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$', views.month_archive), re_path(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/(?P&lt;slug&gt;[\\w-]+)/$', views.article_detail),] ‘, views.article_detail),]","categories":[],"tags":[]},{"title":"变量与过滤器","slug":"TreasureBox/python/Django/3.模板层/1.变量与过滤器","date":"2022-05-19T01:14:40.375Z","updated":"2023-04-28T09:25:47.166Z","comments":true,"path":"2022/05/19/treasurebox/python/django/3.mo-ban-ceng/1.bian-liang-yu-guo-lu-qi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/3.mo-ban-ceng/1.bian-liang-yu-guo-lu-qi/","excerpt":"","text":"模板层的使用一、变量变量名称由数字、字母和下划线任意组合组成，但不能以下划线开头。在变量中也可以使用点(.)，代表特殊含义。变量名中不能包含空格或标点符号。 当在模板中遇到点（.）时，会尝试按一下顺序查找 字典查询 属性或方法查找 数值索引查找 二、过滤器通过过滤器对要显示的内容做改变。 default 如果变量为False或为空，则使用给定的默认值，否则，将使用变量的值。 1{{ value|default:\"nothing\" }} filesizeformat 一个可读的文件大小的值。如：”13KB”，”4.1MB”,”102bytes”。 1{{ value|filesizeformat }} 如果value的值为123456789，则输出为：117.7MB。 add 对value值进行加法操作。如果value为4，则结果为6。 1{{ value|add:2 }} 如果想减去某个值，则将add后的数字改为负数。 1{{ value|add:-2 }} 如果想将字符串类型改为整数类型，则进行+0操作。 1{{ value|add:0 }} widthratio 1{% widthratio 5 1 100 %} 该代码表示：5/1*100，返回500，widthratio需要三个参数，他会使用参数1/参数2*参数3，所以进行乘法时，将参数2赋值为1即可。 如果想进行除法时，则将参数三的值赋为1即可。 1{% widthratio 5 100 1 %} 如果想对widthratio函数处理后的值当做变量，可以使用如下方法： 123{% widthratio this_value max_value max_width as width %}{% blocktrans %}The width is: {{ width }}{% endblocktrans %} second 进行加2次操作。如： 1{{ first|add:second }} first为[1,2,3]时，第二次为[4,5,6]，最终的输出为[1,2,3,4,5,6] addlashes 在引号前边加斜杠，在CSV中转义字符串很有用。如： 1{{ value|addslashes }} 如果value是：**”I’m** using Django”，则结果为：“I\\‘m using Django” capfirst 将值的第一个字符大写，如果第一个字符不是大写时，则此过滤器不会生效。 1{{ value|capfirst }} 如果value值为”django”，则输出为”Django”。 center 将值居中在给定宽度的字段中。 1\"{{ value|center:\"15\" }}\" 如果value的值为”django”，则输出为：**”** Django “ cut 从给定的字符串中删除所有的arg的值。如删除字符串中所有的空格 1{{ value|cut:\" \" }} 如果value是”String with spaces“，则输出结果为”Stringwithspaces“ date 根据给定的格式格式化日期。如： 12{{ value|date:\"D d M Y\" }} {{ value|time:\"H:i\" }} default_if_none 当且仅当值为None，则使用给定的默认值，否则使用该值。如果是空字符串时，将不使用默认值。 1{{ value|default_if_none:\"nothing\" }} 如果value是None，则输出为nothing。 dictsort 获取字典列表，并返回按参数中给定键排序的列表。 1{{ value|dictsort:\"name\" }} 如果value是： 12345[ {'name': 'zed', 'age': 19}, {'name': 'amy', 'age': 22}, {'name': 'joe', 'age': 31},] 那么输出结果将是： 12345[ {'name': 'amy', 'age': 22}, {'name': 'joe', 'age': 31}, {'name': 'zed', 'age': 19},] 还可执行更复杂的操作，如： 123{% for book in books|dictsort:\"author.age\" %} * {{ book.title }} ({{ book.author.name }}){% endfor %} 如果books是： 12345[ {'title': '1984', 'author': {'name': 'George', 'age': 45}}, {'title': 'Timequake', 'author': {'name': 'Kurt', 'age': 75}}, {'title': 'Alice', 'author': {'name': 'Lewis', 'age': 33}},] 那么输出是： 123* Alice (Lewis)* 1984 (George)* Timequake (Kurt) 还可以按照指定索引处的元素队列表（或其它实现的对象）进行排序。索引必须作为整数传递，而不能是字符串(‘0’)。如： 1{{ value|dictsort:0 }} 如果value是： 12345[ ('a', '42'), ('c', 'string'), ('b', 'foo'),] 那么输出将是： 12345[ ('a', '42'), ('b', 'foo'), ('c', 'string'),] dictsortreversed 获取字典列表，并返回该列表，该列表按参数中给定的键以相反的顺序排序。与dictsort相同，只是返回值的顺序相反。 divisibleby 根据值是否可被参数整除返回True或False。 1{{ value|divisibleby:\"3\" }} 如果value是21，则输出为True。 escape 转义字符串的HTML，如： &lt; 转换为 &amp;lt; &gt; 转换为 &amp;gt; ' （单引号）转换为 &amp;#39; \" （双引号）转换为 &amp;quot; &amp; 转换为 &amp;amp; 可以在autoescape关闭状态下应用于字段。 123{% autoescape off %} {{ title|escape }}{% endautoescape %} first 返回列表中的第一项，如： 1{{ value|first }} 如果value是列表[‘a’,’b’,’c’]，则输出为：’a’。 floatformat 保留小数位数，如果不带参数时，将浮点数四舍五入到小数点后一位，但小数为0时，则不保留。如： value 模板 输出量 34.23234 {{ value|floatformat}} 34.2 34.00000 {{ value|floatformat}} 34 34.26000 {{ value|floatformat}} 34.3 如果与数字整数参数一起使用，则表示将数字四舍五入到小数点后的位数。例如： value 模板 输出量 34.23234 {{ value|floatformat:3}} 34.232 34.00000 {{ value|floatformat:3}} 34.000 34.26000 {{ value|floatformat:3}} 34.260 传递0（零）作为参数，则将浮点数四舍五入为最接近的整数。 value 模板 输出量 34.23234 {{ value|floatformat:\"0\" }} 34 34.00000 {{ value|floatformat:\"0\" }} 34 39.56000 {{ value|floatformat:\"0\" }} 40 如果传递给的参数为负数，它将把数字四舍五入到小数点后n位，但是只有在有要显示小数部分的情况下有用。例如： value 模板 输出量 34.23234 {{ value|floatformat:\"-3\" }} 34.232 34.00000 {{ value|floatformat:\"-3\" }} 34 34.26000 {{ value|floatformat:\"-3\" }} 34.260 使用floatformat不带参数等效于使用floatformat 带参数-1。 get_digit 给定一个整数，返回所请求的数字，其中1是最右边的数字，2是最右边的第二个数字，依此类推。如果输入或参数不是整数，或者参数小于1,z则返回无效输入的原始值。否则，输出始终是整数。 1{{ value|get_digit:\"2\" }} 如果value是123456789，则输出为8。 iriencode 将IRI（国际化资源标识符）转换为适合包含在URL中的字符串。如果您要在URL中使用包含非ASCII字符的字符串，则这是必需的。 例如： 1{{ value|iriencode }} 如果value是\"?test=1&amp;me=2\"，则输出为\"?test=1&amp;amp;me=2\"。 join 用字符串连接列表，例如Python的 str.join(list) 例如： 1{{ value|join:\" // \" }} 如果value是列表，则输出将为字符串 。['a', 'b', 'c']``\"a //b // c\" join_script Django 2.1的新功能： 将Python对象作为JSON安全地输出，包装在&lt;script&gt;标记中，可以与JavaScript一起使用。 参数：&lt;script&gt;标记的HTML“ id” 。 例如： 1{{ value|json_script:\"hello-data\" }} 如果value是dictionary ，则输出为：{'hello': 'world'} 1&lt;script id=\"hello-data\" type=\"application/json\"&gt;{\"hello\": \"world\"}&lt;/script&gt; 可以使用以下方式在JavaScript中访问结果数据： 1var value = JSON.parse(document.getElementById('hello-data').textContent); 通过转义字符“ &lt;”，“&gt;”和“＆”来缓解XSS攻击。例如，如果value为，则输出为：{'hello': 'world&lt;/script&gt;&amp;amp;'} 1&lt;script id=\"hello-data\" type=\"application/json\"&gt;{\"hello\": \"world\\\\u003C/script\\\\u003E\\\\u0026amp;\"}&lt;/script&gt; 这与禁止页面内脚本执行的严格的内容安全策略兼容。它还可以在被动数据和可执行代码之间保持清晰的分隔。 last 返回列表中的最后一项如： 1{{ value|last }} 如果value是列表[‘a’,’b’,’c’,’d’]，则输出为字符串’d’。 length 返回值的长度，适用于字符串和列表。 1{{ value|length }} 如果value是[1,2,3,4]或”abcd”，则输出为：4。 length_is 如果value长度是参数的值，则返回True，否则返回False。 1{{ value|length_is:\"4\" }} 如果value为['a', 'b', 'c', 'd']或\"abcd\"，则输出为True。 linebreaks 将一段纯文本中的所有换行符转换为HTML换行符（&lt;br&gt;）。 例如： 1{{ value|linebreaksbr }} 如果value是Joel\\n is a slug，则输出为。Joe&lt;br&gt;is a slug linenumbers 显示带有行号的文本。如： 1{{ value|linenumbers }} 如果value是： 123onetwothree 输出将是： 1231. one2. two3. three ljust 将值在给定宽度的字段中左对齐。 参数：字段大小 例如： 1\"{{ value|ljust:\"10\" }}\" 如果value是Django，则输出为。\"Django \" lower 将字符串所有字母转换为小写字母。如： 1{{ value|lower }} safe 关闭自动转义功能。 slice 返回列表的一部分。 1{{ some_list|slice:\":2\" }} 如果some_list是[‘a’, ‘b’, ‘c’]，则输出为[‘a’, ‘b’] upper 将字符串全部转化为大写。 例如： 1{{ value|upper }} 如果value是，则输出为。\"Joel is a slug\"。\"JOEL IS A SLUG\" |lower }} 1234567891011- #### safe 关闭自动转义功能。- #### slice 返回列表的一部分。 ```python {{ some_list|slice:\":2\" }} 如果some_list是[‘a’, ‘b’, ‘c’]，则输出为[‘a’, ‘b’] upper 将字符串全部转化为大写。 例如： 1{{ value|upper }} 如果value是，则输出为。\"Joel is a slug\"。\"JOEL IS A SLUG\"","categories":[],"tags":[]},{"title":"迁移","slug":"TreasureBox/python/Django/1.模型层/1.迁移","date":"2022-05-19T01:14:40.374Z","updated":"2023-04-28T09:25:47.160Z","comments":true,"path":"2022/05/19/treasurebox/python/django/1.mo-xing-ceng/1.qian-yi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/1.mo-xing-ceng/1.qian-yi/","excerpt":"","text":"数据库迁移 迁移前的检测 python manage.py check 生成迁移文件 python manage.py makemigrations 执行迁移 python manage.py migrate 显示用于迁移的SQL语句 python manage.py sqlmigrate 列出项目的迁移及其状态 python manage.py showmigrations 忽略某条迁移文件 python manage.py migrate app_name 0003 –fake","categories":[],"tags":[]},{"title":"Meta选项","slug":"TreasureBox/python/Django/1.模型层/2.Meta选项","date":"2022-05-19T01:14:40.374Z","updated":"2023-04-28T09:25:47.159Z","comments":true,"path":"2022/05/19/treasurebox/python/django/1.mo-xing-ceng/2.meta-xuan-xiang/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/1.mo-xing-ceng/2.meta-xuan-xiang/","excerpt":"","text":"Meta选项 abstract 如果设置为True时，该模型为抽象基类，在创建表时不创建。 abstract = True app_label 如果模型是在INSTALLED_APPS中定义之外的app中，则必须声明其所属的应用用程序 app_label = ‘myapp’ verbose_name 对象的可读名称，在admin后台上单数形式的名称。 verbose_name = ‘新闻’ verbose_name_plural 对象的可读名称，在admin后台上复数形式的名称。 verbose_name_plural = ‘新闻’ db_table 用于模型的数据库表的名称 db_table=’music_album’ ordering 对象的默认排序，用于在获取列表时使用 ordering = [‘-id’] permission 创建额外的权限，将自动为模型创建除了add,change,delete,view之外新的权限。 1permissions = ((\"can_deliver_pizzas\", \"Can deliver pizzas\"),) default_permissions 模型的默认权限，可以重新自定义此列表。例如：如果应用不需要任何默认权限，可以将其设置为空列表。必须在创建模型之前在模型上指定它，以防止创建任何遗漏的权限。('add', 'change', 'delete', 'view') indexes 在模型中定义索引。 1234567891011from django.db import modelsclass Customer(models.Model): first_name = models.CharField(max_length=100) last_name = models.CharField(max_length=100) class Meta: indexes = [ models.Index(fields=['last_name', 'first_name']), models.Index(fields=['first_name'], name='first_name_idx'), ]","categories":[],"tags":[]},{"title":"字段类型","slug":"TreasureBox/python/Django/1.模型层/3.字段类型","date":"2022-05-19T01:14:40.374Z","updated":"2023-04-28T09:25:47.160Z","comments":true,"path":"2022/05/19/treasurebox/python/django/1.mo-xing-ceng/3.zi-duan-lei-xing/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/python/django/1.mo-xing-ceng/3.zi-duan-lei-xing/","excerpt":"","text":"字段类型常用字段源代码连接： https://docs.djangoproject.com/zh-hans/2.1/_modules/django/db/models/fields/ (1) AutoField 自增的整型字段，必填参数primary_key=True,则成为数据库的主键，无该字段时，django会自动创建主键id字段。 (2) BigAutoField 一个64位整数，非常类似与AutoField，但是范围是从1~9223372036854775807。 (3) BigIntegerField 一个64位整数，非常类似于IntegerField，不同之处在于保证可以匹配从-9223372036854775808到9223372036854775807。此字段默认表单小部件是TextInput。 (4) BinaryField 一个用于存储原始二进制数据的字段，可以分配bytes，bytearray或memoryview。默认情况下，BinaryField设置editable为False，在这种情况下，他不能包含在ModelForm中，在django2.1中进行了修改：旧版本不允许设置editable为True。有一个额外的可选参数：max_length，字段的最大长度，以字符为单位。最大长度在django的验证中使用强制执行MaxLengthValidator。 (5) BooleanField 一个真假字段，该字段默认表单控件是CheckboxInput或者NullBooleanSelect。当没有设置default值是，BooleanField的值为None。 (6) IntegerField 整数类型字段，数值范围是—2147483648~2147483647. (7) CharField 字符类型，必须提供max_length参数。代表字符的最大长度。 (8) DateField 日期类型，日期格式为YYYY-MM-DD，相当于python中的datetime.date实例。 参数： auto_now：每次修改保存修改为当前日期时间，对于“最后修改的” 时间戳有用。在使用Model.save()保存时有效，使用QuerySet.update() 时不会自动更新。 auto_now_add：新创建对象时自动添加当前日期时间，用于“创建时间”时使用。 auto_now和auto_now_add和default参数是互斥的，不能同时设置。 (9) DatetimeField 日期时间字段，格式为YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]，相当于Python中的datetime.datetime的实例。 (10) DecimalField 固定精度的十进制数字，在python中由Decimal实例表示。有两个必需的参数：max_digits数字允许的最大位数，此数字必须大于或等于decimal_places。decimal_places表示与数字一起存储的小数位数。例如：要存最大整数为999，小数为两位的数字，可以使用： models.DecimalField(max_digits=5, decimal_places=2) (11) DurationField 一个用于存储时间的字段-用Python在Python中建模timedelta。在PostgreSQL上使用时，使用的数据类型为interval，在Oracle上使用为。否则，将使用微秒。INTERVAL DAY(9) TO SECOND(6)bigint (12) EmailField 使用EmailValidator检测该字段是否为有效的电子邮箱地址。 (13) FileField 文件上传字段，不支持primary_key参数，使用该参数时将引发错误。 有两个可选参数： upload_to：设置上传目录和文件名的方法，并且可以通过两种方法进行设置。将参数附加到MEDIA_ROOT路径中，已形成本地文件系统上将存储上传文件的位置。 storage:一个存储对象，用于处理文件的存储和检索。 注意：在模型中使用FileField或ImageField时，需要执行以下几个步骤： l 在settings.py中定义MEDIA_ROOT为django设置存储上载文件的目录的完整路径（这些文件并未直接存储在数据库中，在数据库中只是存储路径）。定义MEDIA_URL为该目录的基本公共URL，确保该目录可由web服务器的用户账号写入。 l 在模型中添加FileField或ImageField字段时，定义upload_to指定MEDIA_ROOT的路径用于上传文件的目录。 l 存储在数据库中的所有文件都是该文件的路径（相对于MEDIA_ROOT）。如果ImageField调用了，则mug_shot可以使用来获取摸板中图像的绝对路径。 假入MEDIA_ROOT的设置为’/home/media’，并且upload_to设置为’photos/%Y/%m/%d’。所述**’%Y/%m/%d’** 的部分upload_to被strftime()格式化;‘%Y’是四位数的年份，‘%m’是两位数的月份，‘%d’是两位数的日期。如果在2007年1月15日上传文件，该文件将保存在目录/home/media/photos/2007/01/15中。 l FieldFile.name：文件名，包括相对路径。 l FieldFile.url：一个只读属性，访问文件的相对URL。 (14) FloatField 代表在python中由float实例表示的浮点数。 (15) ImageField 继承FileField所有的方法，但还验证上传的对象为有效的图像。除了 可用于特殊属性FileField，一个ImageField也具有height和width 属性。为了便于查询这些属性，ImageField有两个额外的可选参数。在数据库中创建的为varchar列，默认最大长度为100字符。 ImageField.height_field：每次保存模型实例时，模型字段的名称都会自动填充图像的高度。 ImageField.width_field：每次保存模型实例时，模型字段的名称都会自动填充图像的宽度。 (16) IntegerField 一个整数。从-2147483648到2147483647. (17) GenericIPAdressField 字符串格式的IPv4和IPv6地址（如：192.0.2.30或2a02:42fe::4）。默认表单格式为TextInput。 (18) TextField 文本字段。默认表单小部件是Textarea，如果指定max_length属性，将反映在Textarea自动生成的表单字段中。 (19) TimeField 时间，在Python中以datetime.time实例表示。接受与相同的自动填充选项DateField。 (20) URLField 一个CharField一个URL，通过验证 URLValidator。 此字段的默认表单小部件是TextInput。 像所有CharField子类一样，URLField采用可选 max_length参数。如果未指定 max_length，则使用默认值200。 (21) UUIDField 用于存储通用唯一标识符的字段。使用Python的 UUID类。在PostgreSQL上使用时，它存储在uuid数据类型中，否则存储在 中char(32)。 是通用的唯一标识符，可以很好的替代带有的 primary_key的AutoField字段。数据库不会为您生成UUID，因此建议使用default： 12345import uuidfrom django.db import modelsclass MyUUIDModel(models.Model): id=models.UUIDField(primary_key=True,default=uuid.uuid4,editable=False) (22) ForeignKey 多对一关系，需要两个位置参数：与模型相关的类和on_delete选项，如果创建地柜关系（一个与自身具有多对一关系的对象）则使用model.ForeignKey(‘self’,on_delete=models.CASCADE)。如果需要在尚未定义的模型上创建关系，则可以使用模型的名称，而不是模型对象本身。如： 1234567from django.db import modelsclass Car(models.Model): manufacturer = models.ForeignKey('Manufacturer',on_delete=models.CASCADE, )class Manufacturer(models.Model): pass 参数： ForeignKey.on_delete：所有可能的参数都在django.db.models中。当删除由a引用的对象时，Django将模拟on_delete参数指定的SQL约束的行为。例如：如果有一个可为空的字段，并且在删除引用的对象时将其设置为空，如： user = models.ForeignKey( ​ User, ​ models.SET_NULL, ​ blank=True, ​ null=True,) CASCADE：级联删除。Django会在DELETE CASCADE上模拟SQL约束的行为，并删除包含ForeignKey的对象。 DO_NOTHING：不采取行动。 PROTECT：通过引发ProtectedError的子类来防止删引用的对象，是django.db.IntegrityError的子类。 SET_NULL：删除时把外键置为null，当null=True时才可以使用。 SET_DEFAULT：把外键置为默认值，必须要设置默认值时才可以使用。 (23) ManyToManyField 多对多关系表，需要一个位置参数：与模型相关的类，工作原理与ForeignKey完全相同，包括递归和惰性关系。Django会自动创建中间的链接表来表示多对多的关系。 (24) OneToOneField 一对一关系的关系，从概念上与带有unique=True的ForeignKey相似，但是在关系的另一侧（主表数据）直接返回单个对象。 一关系的关系，从概念上与带有unique=True的ForeignKey相似，但是在关系的另一侧（主表数据）直接返回单个对象。","categories":[],"tags":[]},{"title":"linux进阶","slug":"TreasureBox/linux/2.linux进阶","date":"2022-05-19T01:14:40.372Z","updated":"2023-04-28T09:25:47.222Z","comments":true,"path":"2022/05/19/treasurebox/linux/2.linux-jin-jie/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/linux/2.linux-jin-jie/","excerpt":"","text":"linux进阶[TOC] 一、用户管理命令linux是一个多用户的操作系统，允许多个用户同时操作系统中的文件。而windows是一个伪多用户的操作系统，可以存在多个用户，但是同时只允许一个用户操作系统中的文件。 为了更好的管理服务器中的服务，一般会创建不同的用户维护不同的服务。 1、用户管理命令一般情况下都是需要管理员权限才能执行。 命令 描述 useradd 增加一个用户，在系统中创建一个用户 userdel 删除一个用户，将系统中的某个用户删除 passwd 修改指定用户密码 创建用户并添加密码： 123456[root@localhost root]# useradd youzi[root@localhost root]# cd /home[root@localhost home]# lsroot youzi[root@localhost home]# passwd youzi密码有默认的限制规则，会校验是否符合格式，输入密码时一般不回显。输完直接确认。 添加完用户之后即可在远端使用ssh youzi@ip进行远端登录。 删除用户： 默认：删除用户，但是不删除用户数据。 123[root@localhost home]# userdel youzi[root@localhost home]# lsroot youzi 删除用户同时删除用户数据（危险操作）。 一旦删除执行成功了，数据就真的损失了，一般情况下是找不回来的。添加-r参数 123[root@localhost home]# userdel -r xigua[root@localhost home]# lsroot 2、管理员身份在系统操作中，经常会听到使用管理员身份运行，wind系统中可以直接使用鼠标选择管理员方式打开，在unix/linux系统中有一个特殊的命令：sudo，可以让当前正在执的命令，使用管理员身份运行。 在unix/linux系统中，为了严格的管理用户权限，普通用户一般不允许使用管理员身份直接操作系统文件，造成一些不必要的危险操作。 在某些情况一个普通用户确实需要管理员身份，但是又不能直接使用root用户，需要将普通用户提升为管理员账号，可以使用管理员身份运行一些命令，此时需要修改制定的配置文件/etc/sudoers，添加普通用户。 12[root@localhost home]# vi /etc/sudoers模仿上一行数据添加一条用户数据 之后即可使用sudo进行提权： 1[youzi@localhost home]# sudo rm -rf hello 3、切换用户在命令行操作过程中，经常会涉及到多个用户之间的切换操作，系统中提供了对应的命令可以完成不同场景下的用户切换需求。 命令 描述 su 在当前目录中，直接切换到root用户 su 账号 在当前目录中，直接切换到指定账号的用户 su - 切换到root用户，并将当前目录切换到/root中 su - root 和su -效果相同 su - 账号 切换到一个普通用户，并将当前目录切换到/home/账户 二、内容查看命令1、查找文件命令：findfind命令，类似windows中的文件搜索，功能更加强大，在命令执行过程中可以按照文件名、文件大小、文件用户、文件权限、文件修改、访问时间…等等进行检索。 特点是精确查找，实时查找，但是查找速度较慢。 语法格式：find [option] … [查找路径] [查找条件] [处理动作] 查找路径：指定具体目标路径，默认为当前目录 查找条件：指定的查找标准，可以是文件名、大小、类型、权限等，默认为找出指定路径下所有的文件 根据文件名查找： -name “文件名称” (支持使用glob通配 ,?,[],[^]） 例如 find /etc -name “passwd“ -iname “文件名称” (不区分大小写） -regex “PATTEN”: 以PATTEN匹配整个文件路径字符串，而不仅仅是文件名称：根据属主 属组查找 -user USERNAME:查找属主为指定用户的文件 group GROUPNAME:查找属组为指定用户的文件。 -uid UserID:查找属主为指定UID的文件 -gid GroupID:查找属主为指定GID的文件 -nouser:查找没有属主的文件 -nogroup:查找没有属组的文件根据文件类型查找： -type TYPE: f:普通文件 d:目录文件 l:符号链接文件 s:套接字文件 b:块设备文件 c:字符设备文件 p：管道文件 组合条件（与 或 非） a o not根据文件大小来查找： -size [+|-]#UNIT 常用单位：k,M,G UNIT:(#-1,#] -UNIT:(0,#-1] +#UNIT:(#,oo)根据时间戳： 以“天”为单位： -atime: [+|-]# -mtime: -ctime: 以“分钟”为单位: -amin -mmin -cmin根据权限来查找 -perm [+|-]MODE 处理动作：对符合条件的文件做什么操作，默认为标准输出至屏幕。 -print:默认动作，输出至屏幕-ls:类似ls -l命令-delete：查找出然后删除-fls /path/to/somefile-ok COMMAND {} ;对查到的每个文件执行COMMAND命令，对于每个文件执行命令，需交互确认-exec COMMAND {} ;直接处理，不交互。 ｛｝：用于引用查找到的文件名称本身 2、查找内容的命令：grepgrep命令主要用于在一部分内容中，搜索执行的内容是否出现。 案例1：在hello.py中查找是否有hello 1[root@localhost home]#grep hello hello.py 案例2：查找包含sshd内容的进程 1[root@localhost home]#ps -ef| grep sshd 3、展示内容的命令:echoecho命令，windows系统和linux系统中常用的命令，主要是输出打印常用信息，借助文件操作符：&gt; 内容添加符号; &gt;&gt; 内容追加符号，完成创建文件的操作。 12[root@localhost home]#echo \"hello\"hello 案例1：添加hello到hello.py 1[root@localhost home]#echo \"hello\" &gt; hello.py 小知识： linux中，！符号是一个命令语法 !p 代表执行上一个p开头的命令 !! 代表执行上一条命令 4、查看内容的命令：cat/more/less cat全文浏览 语法：cat 文件名称 将文件的所有内容展示到屏幕中。 语法：cat 文件1 文件2 &gt; 文件 将文件1的内容展示出来、将文件2的内容展示出来，将两部分内容添加到&gt;符号后面的文件中。 more分页浏览 如果文件内容过多，不好使用cat进行全部展示，就可以使用more命令分页查看文件内容，打开文件后默认展示第一页。 more 文件：分页查看，默认展示第一页 more +20：分页查看，从第20行开始查看 more+/youzi：分页查看，从第一次出现youzi的行开始查看 文件打开之后的翻页快捷键： 回车：逐行查看，每次回车滚动一行 空格：逐页查看，每次按下空格滚动一页 b：往上翻页，查看文件开头内容 f：往下翻页，查看文件后面的内容 q：浏览文件过程中，按下q键随时终端浏览，退出命令行 less分页浏览 和more命令类似，文件内容不会覆盖显示到屏幕上。 5、查看内容命令：head/tail head命令：查看文件关键信息 查看文件头部信息命令，某些需求下并不需要查看完整的文件内容，只需要查看文件的头部信息。 1[root@localhost home]#head -5 hello.py tail命令：实时监测文件 查看一些特殊文件的时候，文件的内容实时的更新，如果在察看过程中需要新更新的数据同 时能看到，使用实时查看命令 tail 命令，可以动态监测文件内容的变化。 1[root@localhost home]#tail -f hello.py 三、vi/vim编辑器vim编辑器是linux系统中常用的编辑器，是linux系统中自带的，vim分为三种模式： 视图模式：查看内容。 末行模式：输入命令执行特殊操作如搜索，保存等。 插入模式：在文本中插入内容。 输入模式向编辑模式转换——&gt;ESC 编辑模式向末行模式——&gt;： 末行模式向编辑模式转换——&gt;ESC。 1、视图模式 视图模式向编辑模式转换 i：当前光标处输入内容I:在当前光标所在行的行首a：在当前光标所在处的后面A:在当前光标所在行的行尾输入o：在光标所在行的下方新增一行空白行O:在光标所在行的上方新增一行空白行 光标移动 光标移动是为了能在文件中快速找到需要编辑的位置。 h：光标向下移动、等价于左方向键 j：光标向下移动、等价于右方向键 k：光标向上移动 l：光标向右移动 gg：光标直接移动到文件的第一行位置 G：光标直接移动到文件的最后一行位置 H：光标移动到可视窗口的第一行 M：光标移动到可视窗口的中间一行 shift+6——^：光标移动到行首 shift+6——^：光标移动到行末 查看模式下的编辑操作 x：删除光标所在位置的字符 r：替换光标所在位置的字符 dd：删除光标所在的行 d3d：删除光标所在位置向下3行的内容 u：重做，撤销上一次的操作 yy：复制光标所在的一行 y5y：复制光标所在位置向下5行的内容 p：粘贴 翻页操作： ctrl+b：back往回翻整页 ctrl+f：front往前翻整页 ctrl+d：down往下翻整页 ctrl+u：up网上翻半页 2、末行模式在视图模式下，直接输入特定的符号，就可以在文件的末尾输入命令完成特定的功能。 符号 功能 :w 保存文件 :q 不保存，退出文件 :wq 保存退出 :w! 强制保存文件 :q! 强制不保存退出 :wq! 强制保存退出 :x 保存退出 :x! 强制保存退出 :set nu 显示行号 :set nonu 取消显示行号 :n1,n2s/old/new/g 将n1行开始到n2行的内容中出现的old字符替换成new字符old支持正则匹配（正则表达式匹配规则） /str 在文件中从光标位置向下查询str字符串 ?str 在文件中从光标位置向上查询str字符串 3、辑模模式按照正常的文本编辑方式，直接输入内容即可。 光标位置：直接输入字符 换行：直接敲击回车键 移动光标位置：方向键直接移动光标[退出到查看模式hjkl移动光标] 4、VIM中的缩进操作 a. 让光标定位至需要缩进的某一行 b. 按shift+v选择当前行（同时操作多行，可以按上下方向键选择多行） c. 按&gt;向右缩进一个tab位，&lt;符号向左缩进一个tab位。 置：方向键直接移动光标[退出到查看模式hjkl移动光标] 4、VIM中的缩进操作 a. 让光标定位至需要缩进的某一行 b. 按shift+v选择当前行（同时操作多行，可以按上下方向键选择多行） c. 按&gt;向右缩进一个tab位，&lt;符号向左缩进一个tab位。","categories":[],"tags":[]},{"title":"shell编程","slug":"TreasureBox/linux/3.shell编程","date":"2022-05-19T01:14:40.372Z","updated":"2023-04-28T09:25:47.223Z","comments":true,"path":"2022/05/19/treasurebox/linux/3.shell-bian-cheng/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/linux/3.shell-bian-cheng/","excerpt":"","text":"shell编程一、shell编程简介shell编程入门：是unix/linux操作系统中的一种工程自动化操作方式。让我们通过手工操作的繁琐的步骤，使用程序完成自动化的操作。 1、shell编程用途基础配置：系统初始化操作、系统更新、内核调整等等。 安装程序：自动部署LNMP、LAMP、MySQL等 配置变更：Nginx配置、MySQL配置、Redis配置等等 业务部署：配合git、jenkins等实现自动化持续交付 日常备份：脚本对项目或者软件实现全备份或者增量备份等 信息采集：硬件、系统、服务、网络等各种数据的自动采集 日志分析：获取日志、排序、去重、统计、分析 服务扩容：监控服务器信息，脚本程序自动化扩容部署 2、Shell编程的核心shell编程内部就是批量执行Unix/Linux命令的操作，将手工执行多次的命令，转换到脚本程序中通过命令完成一次性执行的效果。 案例：备份文件，编写shell文件back.sh #! /bin/sh echo ——开始文件备份——– echo 打包文件 tar -cvf hw.bak.tar 1.py 2.py 3.py test.py echo 打包完成，开始压缩 gzip hw.bak.tar echo 压缩玩成，开始规范命名 mv hw.bak.tar.gz hw.bak0311.tar.gz echo ———文件备份完成————– 执行shell文件：sh back.sh 二、定时任务定时任务，就是指定了在某个固定的时间点（时刻）或者在某个时间点执行一些任务。 一次性任务：执行某些业务操作时，需要在某个特殊时刻执行一个命令/脚本。 周期性任务：某些指定的时刻，需要执行指定的操作命令/脚本。 1、一次性定时任务Linux系统中，提供了at命令，用于指定时间点，就可以在指定时间点添加多条执行命令，党制定的时刻到达时，就会触发执行的所有命令。 （1）at添加一次性任务at -l：查看任务 at 时间点：指定的时间点上，添加任务 如果时间点早于系统时间，默认第二天执行任务。 如果时间点晚于系统时间，默认当天这个时间实行任务。 Ctrl+D：组合键保存定时任务。 （2）at命令删除一次性任务atrm 任务编号：删除指定编号的命令。 示例：atrm 6。删除编号为6的定时任务。 其他命令可以试用man at查看使用详情。 2、周期性任务当某个任务需要每天执行，或者每隔多长时间执行时，就可以使用周期性定时任务。可以使用crontab操作定时任务，通常情况下该组件是系统的一个内建组件，如果系统中缺少这个组件，可以使用yum install crontab安装。 （1）crontab基本语法通过crontab命令，添加任务、编辑任务、删除任 命令 描述 crontab -l 列出当前用户的所有周期性任务 crontab -e 编辑当前用户的周期性任务 crontab -r 删除当前用户的所有周期性任务【谨慎使用】 以第一个*符号为例，说明上述语法： ① *： 表示每一天的每个小时的每分钟执行一次后面的命令。 ② 10：表示每一天的每个小时的第10分钟，执行一次后面的命令 ③ */5：表示每一天的每个小时中，每隔5分钟，执行一次后面的命令 ④ 5，10，20，30：表示每一天的每个小时中，第5、10、20、30分钟执行后面的命令 ⑤ 10-20：表示每一天的每个小时中，第10分钟开始直到第20分钟结束，每分钟执行命令 （2）crontab案例每天的每分钟执行一次爬虫脚本，并且记录执行结果。 ��例 每天的每分钟执行一次爬虫脚本，并且记录执行结果。","categories":[],"tags":[]},{"title":"git","slug":"TreasureBox/git命令/git","date":"2022-05-19T01:14:40.371Z","updated":"2023-04-28T09:25:47.221Z","comments":true,"path":"2022/05/19/treasurebox/git-ming-ling/git/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/git-ming-ling/git/","excerpt":"","text":"git操作 配置.gitignore文件 作用：可以屏蔽掉某些不需要被管理的文件或文件夹，如日志文件、临时文件等。 git rm -r –cached . git add . git commit -m ‘update .gitignore’ 新建 创建一个新的git仓库。这个版本库的配置、存储等信息会被保存到.git文件中 12345678910111213# 初始化当前项目$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。$ git init --bare &lt;directory&gt;# 下载一个项目和它的整个代码历史# 这个命令就是将一个版本库拷贝到另一个目录中，同时也将分支都拷贝到新的版本库中。这样就可以在新的版本库中提交到远程分支$ git clone [url] 配置 更改设置。可以是版本库的设置，也可以是系统的或者全局的设置： 12345678910111213141516171819# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 输出、设置基本的全局变量$ git config --global user.email$ git config --global user.name$ git config --global user.email \"MyEmail@gmail.com\"$ git config --global user.name \"My Name\"# 定义当前用户所有提交使用的作者邮箱。$ git config --global alias.&lt;alias-name&gt; &lt;git-command&gt;# 为Git命令创建一个快捷方式（别名）。$ git config --system core.editor &lt;editor&gt; 帮助 git的内部帮助命令 1234567891011# 查找可用命令$ git help# 查找所有可用命令$ git help -a# 在文档当中查找特定的命令# git help &lt;命令&gt;$ git help add$ git help commit$ git help init 状态 显示索引文件（也就是当前工作空间）和当前的头指针指向的提交的不同 12345# 显示分支，未跟踪文件，更改和其他不同$ git status# 查看其他的git status的用法$ git help status 信息 获取某些文件，某些分支，某次提交等git信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@{0 day ago}\"# 比较暂存区和版本库差异$ git diff --staged# 比较暂存区和版本库差异$ git diff --cached# 仅仅比较统计信息$ git diff --stat# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog# 查看远程分支$ git br -r# 创建新的分支$ git br &lt;new_branch&gt;# 查看各个分支最后提交信息$ git br -v# 查看已经被合并到当前分支的分支$ git br --merged# 查看尚未被合并到当前分支的分支$ git br --no-merged 添加 添加文件到当前工作空间中。如果你不使用 git add 将文件添加进去，那么这些文件也不会添加到之后的提交之中。 12345678910111213141516171819202122# 添加一个文件$ git add test.js# 添加一个子目录中的文件$ git add /path/to/file/test.js# 支持正则表达式$ git add ./*.js# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p 删除 rm 和上面的 add 命令相反，从工作空间中去掉某个文件 1234567891011# 移除 HelloWorld.js$ git rm HelloWorld.js# 移除子目录中的文件$ git rm /pather/to/the/file/HelloWorld.js# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] 分支 管理分支，可以通过下列命令对分支进行增删改查切换等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 查看所有的分支和远程分支$ git branch -a# 创建一个新的分支$ git branch [branch-name]# 重命名分支# git branch -m &lt;旧名称&gt; &lt;新名称&gt;$ git branch -m [branch-name] [new-branch-name]# 编辑分支的介绍$ git branch [branch-name] --edit-description# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]# 切换到某个分支$ git co &lt;branch&gt;# 创建新的分支，并且切换过去$ git co -b &lt;new_branch&gt;# 基于branch创建新的new_branch$ git co -b &lt;new_branch&gt; &lt;branch&gt;# 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除$ git co $id# 把某次历史提交记录checkout出来，创建成一个分支$ git co $id -b &lt;new_branch&gt;# 删除某个分支$ git br -d &lt;branch&gt;# 强制删除某个分支 (未被合并的分支被删除的时候需要强制)$ git br -D &lt;branch&gt; 检出将当前工作空间更新到索引所标识的或者某一特定的工作空间。 123456# 检出一个版本库，默认将更新到master分支$ git checkout# 检出到一个特定的分支$ git checkout branchName# 新建一个分支，并且切换过去，相当于\"git branch &lt;名字&gt;; git checkout &lt;名字&gt;\"$ git checkout -b newBranch 远程同步远程同步的远端分支 1234567891011121314151617181920212223242526272829303132333435# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 查看远程服务器地址和仓库名称$ git remote -v# 添加远程仓库地址$ git remote add origin git@ github:xxx/xxx.git# 设置远程仓库地址(用于修改远程仓库地址)$ git remote set-url origin git@ github.com:xxx/xxx.git# 删除远程仓库$ git remote rm &lt;repository&gt;# 上传本地指定分支到远程仓库# 把本地的分支更新到远端origin的master分支上# git push &lt;远端&gt; &lt;分支&gt;# git push 相当于 git push origin master$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031323334353637383940414243# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 恢复最后一次提交的状态$ git revert HEAD# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop# 列所有stash$ git stash list# 恢复暂存的内容$ git stash apply# 删除暂存区$ git stash drop commit将当前索引的更改保存为一个新的提交，这个提交包括用户做出的更改与信息 123456789101112131415161718# 提交暂存区到仓库区附带提交信息$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... diff显示当前工作空间和提交的不同 12345678# 显示工作目录和索引的不同$ git diff# 显示索引和最近一次提交的不同$ git diff --cached# 显示工作目录和最近一次提交的不同$ git diff HEAD grep可以在版本库中快速查找 12345678910# 在搜索结果中显示行号$ git config --global grep.lineNumber true# 是搜索结果可读性更好$ git config --global alias.g \"grep --break --heading --line-number\"# 在所有的java中查找variableName$ git grep 'variableName' -- '*.java'# 搜索包含 \"arrayListName\" 和, \"add\" 或 \"remove\" 的所有行$ git grep -e 'arrayListName' --and \\( -e add -e remove \\) log 显示这个版本库的所有提交 123456789101112131415161718192021# 显示所有提交$ git log# 显示某几条提交信息$ git log -n 10# 仅显示合并提交$ git log --merges# 查看该文件每次提交记录$ git log &lt;file&gt;# 查看每次详细修改内容的diff$ git log -p &lt;file&gt;# 查看最近两次详细修改内容的diff$ git log -p -2#查看提交统计信息$ git log --stat merge合并就是将外部的提交合并到自己的分支中 123456# 将其他分支合并到当前分支$ git merge branchName# 在合并时创建一个新的合并后的提交# 不要 Fast-Foward 合并，这样可以生成 merge 提交$ git merge --no-ff branchName mv重命名或移动一个文件12345678910111213# 重命名$ git mv test.js test2.js# 移动$ git mv test.js ./new/path/test.js# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]# 强制重命名或移动# 这个文件已经存在，将要覆盖掉$ git mv -f myFile existingFile tag123456789101112131415161718192021222324252627# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] pull从远端版本库合并到当前分支 123456# 从远端origin的master分支更新版本库# git pull &lt;远端&gt; &lt;分支&gt;$ git pull origin master# 抓取远程仓库所有分支更新并合并到本地，不要快进合并$ git pull --no-ff ci1234567$ git ci &lt;file&gt;$ git ci .# 将git add, git rm和git ci等操作都合并在一起做$ git ci -a$ git ci -am \"some comments\"# 修改最后一次提交记录$ git ci --amend rebase（谨慎使用） 将一个分支上所有的提交历史都应用到另一个分支上 不要在一个已经公开的远端分支上使用 rebase. 12345678# 将experimentBranch应用到master上面# git rebase &lt;basebranch&gt; &lt;topicbranch&gt;$ git rebase master experimentBranch#合并若干次提交为一次# git rebase -i commit_id# 在本地rebase之后，将修改推送到远端git push --force-with-lease reset（谨慎使用）将当前的头指针复位到一个特定的状态。这样可以使你撤销 merge、pull、commits、add 等这是个很强大的命令，但是在使用时一定要清楚其所产生的后果。 1234567891011121314# 使 staging 区域恢复到上次提交时的状态，不改变现在的工作目录$ git reset# 使 staging 区域恢复到上次提交时的状态，覆盖现在的工作目录$ git reset --hard# 将当前分支恢复到某次提交，不改变现在的工作目录# 在工作目录中所有的改变仍然存在$ git reset dha78as# 将当前分支恢复到某次提交，覆盖现在的工作目录# 并且删除所有未提交的改变和指定提交之后的所有提交$ git reset --hard dha78as 其他1234567891011121314151617181920# 生成一个可供发布的压缩包$ git archive# 打补丁$ git apply ../sync.patch# 测试补丁能否成功$ git apply --check ../sync.patch# 查看Git的版本$ git --version```�不改变现在的工作目录# 在工作目录中所有的改变仍然存在$ git reset dha78as# 将当前分支恢复到某次提交，覆盖现在的工作目录# 并且删除所有未提交的改变和指定提交之后的所有提交$ git reset --hard dha78as 其他123456789101112# 生成一个可供发布的压缩包$ git archive# 打补丁$ git apply ../sync.patch# 测试补丁能否成功$ git apply --check ../sync.patch# 查看Git的版本$ git --version","categories":[],"tags":[]},{"title":"git2","slug":"TreasureBox/git命令/git2","date":"2022-05-19T01:14:40.371Z","updated":"2023-04-28T09:25:47.220Z","comments":true,"path":"2022/05/19/treasurebox/git-ming-ling/git2/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/git-ming-ling/git2/","excerpt":"","text":"0、.gitignore文件 当版本库中的某个文件不想进行版本控制时，可以通过.gitignore文件进行设置。 git rm -r –cached .git add .git commit -m ‘update .gitignore’ 1、创建Git仓库 &gt;(1)新建一个文件夹，进入文件夹执行 git init初始化Git仓库， (2)添加文件到Git仓库，git add 文件名 ，可反复多次使用，添加多个文件 (3) git commit -m \"更改介绍\" 2、时光机穿梭 &gt;(1)git status 查看仓库状态 git diff 查看修改内容 &gt; &gt;(2)git log 查看历史记录或者 git log --pretty=oneline &gt; &gt;(3)git reset --hard HEAD^ (^代表上一个版本，HEAD~100,代表第上100个版本) &gt; &gt;(4)git reset --hard （commit_id） 在git历史中穿梭 &gt; &gt;(5)git log 查看被提交历史，git reflog 查看命令历史，以便确定回到哪个版本 &gt; &gt;(6)只有git add之后的版本才能被git commit &gt; &gt;(7)场景1：直接丢弃工作区的修改：git checkout -- file 让file回到最近一次git commit或git add时的状态。 &gt;场景2：若是已经添加到暂存区：先撤回到工作区git reset HEAD &lt;file&gt;，然后再按场景1进行 &gt;场景3：已经提交了不合适的修改到版本库时，想要撤销需要版本回退。 &gt; &gt;(8)git rm删除一个文件，git checkout 实际是用版本库里的版本替换工作区的版本 3、本地库与网上库的连接 (1)本地Git链接网上git仓库git remote add origin https://github.com/liuhuanxg/learngit.git (2)将本地库与网上库链接git push -u origin master (3)将本地master分支的最新修改推送至GitHubgit push origin master (4)将网上仓库复制到本地git clone https://github.com/liuhuanxg/gitskills.git (5)git remote -v 查看远程库的信息 4、分支管理 将本地dev分支与远程dev分支关联git branch –set-upstream origin/远程分支名 本地新建分支名 (1)git checkout -b dev 创建并切换分支相当于：git branch dev（创建分支） + git checkout dev（切换分支） (2)git branch 列出所有分支 当前分支前边会有* (3)git merge dev 合并分支到当前分支 (4)git branch -d dev 删除dev分支 (5)当分支冲突时：可以查看分支合并的情况git log –graph –pretty=oneline –abbrev-commit 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。git merge –no-ff -m “merge with no-ff” dev (6)分支未完成不能提交但是需要去完成另一个分支时：先git stash然后去创建别的分支，再git stash pop (7)开发一个新功能，最好新创建一个分支，如果丢弃一个没有被合并的分支：通过git branch -D 强行删除 5、多人协作 &gt;(1)查看远程库信息，使用git remote -v； &gt; &gt;(2)本地新建的分支如果不推送到远程，对其他人就是不可见的； &gt; &gt;(3)从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； &gt; &gt;(4)在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； &gt; &gt;(5)建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； &gt; &gt;(6)从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 6、标签管理 (1)切换到需要打标签的分支上：git tag v1.0 (2)查看所有标签：git tag (3)git tag v0.9 (commit id) (4)git show 查看所有标签信息 (5)git tag -a v0.1 -m “version 0.1 released” commit id 创建带有说明的标签 (6)删除标签：git tag -d (7)推送某个标签到远程：git push origin (8)删除某个远程标签:git push origin :refs/tags/h origin (8)删除某个远程标签:git push origin :refs/tags/","categories":[],"tags":[]},{"title":"基础命令","slug":"TreasureBox/linux/1.基础命令","date":"2022-05-19T01:14:40.371Z","updated":"2023-04-28T09:25:47.223Z","comments":true,"path":"2022/05/19/treasurebox/linux/1.ji-chu-ming-ling/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/linux/1.ji-chu-ming-ling/","excerpt":"","text":"[TOC] 一、基础命令 重启网络服务 1sytemctl restart network 查看IP 1ipconfig 二、系统常见命令 常见命令——ls 命令 描述 ls 查看当前文件夹/路径/目录中的所有文件，list file，列表展示文件。-a：查看所有文件，包括隐藏文件linux中以.开头的文件默认为隐藏文件-l：按照列表的方式，展示文件信息-R：递归使用树形的方式展示文件夹中的所有文件 系统常见命令——cd 命令 描述 cd 改变当前文件夹的命令，进入指定的文件夹，英文：change directory——cdcd path/：表示命令行中切换到path/路径/文件夹/目录中cd：直接回车进入当前用户的家目录中root用户进入/root/waltz用户，进入/home/waltzcd /：进入根目录cd /etc：进入根目录下的etc路径cd test：进入当前目录下的test路径 系统常见命令——pwd 命令 描述 pwd 查看当前命令执行的路径英文：print working directory 系统常见命令——系统关闭/重启 命令 描述 shutdown 系统关闭的命令shutdown -h now 立刻关闭系统shutdown -h 15:30 指定时间关闭系统shutdown -h 5 5分钟后关闭系统shutdown -h 10 “系统即将关闭” 10分钟后关闭系统，通知用户shutdown -r now 立刻重启系统shutdown -c 取消关闭系统的行为 reboot 重启系统 poweroff 关闭系统 sync 同步内存数据到磁盘，保证关闭时系统不会造成数据丢失 系统常见命令——网络信息/任务管理器/进程查看/端口占用 命令 描述 ifconfig 查看Unix/linux系统中的网络信息展示网卡连接网络的信息、本机回环地址信息 top 查看Unix/linux系统中的所有运行程序的信息类似windows中的任务管理器 ps 查看和筛选正在运行的某个进程ps -ef|grep sshed 查看sshd程序是否正在运行ps -aux|grep firewalld 查看防火墙程序是否正在运行 lsof -i 用来显示符合条件的进程情况,lsof（list open files）lsof -i :端口号 查看某一端口的占用情况 系统常见命令——软件更新/系统更新 命令 描述 yum 联网的方式，在线安装软件yum list：查看当前系统中已经安装过的软件列表yum search 名称：查看包含关键字名称的可以安装的软件yum install 软件全名称：安装某个指定名称的软件yum remove 软件名称：卸载某个指定名称的软件 rpm 离线的方式，安装rpm离线软件包rpm -i 离线软件包：rpm安装一个软件包rpm -e 软件名称：卸载一个rpm方式安装的软件rpm -qa 列出所有使用rpm方式安装过的软件 系统更新 更新软件源：yum update 找到有哪些软件可以更新的信息更新系统yum upgrade pkg 指定更新软件信息 系统操作命令——帮助命令 命令 描述 man 查看某个命令的说明文档如：man ls –help 所有命令的通用选项，查看当前命令的操作手册如：ls –help whereis 查看某个名称的命令文件出现在哪些文件夹中如：whereis ls which 查看某个命令，可执行文件在哪个文件夹中 基础操作命令——文件操作 命令 描述 touch 创建一个空白文件语法：touch 文件名称 rm 删除一个文件-r选项：删除文件夹语法：rm -rf * 删除当前文件夹下所有文件语法：rm -rf / 危险操作，删除所有内容 mkdir 创建一个文件夹语法：mkdir 文件夹名称语法：mkdir -p 文件夹/文件夹 循环创建文件夹 rmdir 删除一个非空文件夹，很少使用一般用rm -rf替代 cp 复制一个文件到目标路径—cp：复制cp 原文件 目标文件：将一个原文件复制到目标路径中 mv 移动一个文件到目标路径—mv：movemv 原文件 目标路径：将一个原文件移动到目标路径中（剪贴） 基础操作命令——文件权限命令 权限的描述：rwx 分别描述了只读、只写、执行三种权限，在计算机中为了更好的更简单的 表示权限，可以使用十进制整数表示不同的权限组合： 每个文件的权限由三部分组成：当前用户权限(user)，当前用户所属组的权限(group)，其他用户权限(other) 权限说明 字符描述方式(r w x) 二进制描述方式(r w x) 十进制描述方式(r w x) 没有权限 — — — 0 0 0 0(0+0+0) 只读权限 r — — 1 0 0 4(4+0+0) 读写权限 r w — 1 1 0 6(4+2+0) 所有权限 r w x 1 1 1 7(4+2+1) 命令 描述 chmod 授权命令 当创建一个文件时，默认的权限为：rw- r– r– 案例1：给当前用户授权—添加执行权限 chmod u+x demo.py 说明：+代表添加权限 案例2：给当前用户rw权限，用户组rw权限，其他用户r权限 chmod u=rw,g=rw,o=r demo.py 案例3：给当前用户rwx权限，用户组rw权限，其他用户rw权限 chmod 766 demo.py 案例4：收回权限 chmod u-x,o-w demo.py 说明：- 代表减少权限 基础操作命令——压缩归档命令当需要传送多个文件时，需要对文件进行压缩操作，linux中有两种操作方式： （1）归档：将多个文件整理到一个文件夹中 常用的操作命令：tar，打包后的文件后缀名约定为.tar，tar命令只是将多个文件打包到一块，并没有进行压缩。 命令 描述 tar 归档命令、打包命令-c 打包(compress)-x 拆包-t 查包(text)-v 显示处理信息(verbose)-f 处理过程不进行询问(confirm) 案例打包：将demo.py,demo1.py,demo2.py打包成一个压缩文件 1tar -cvf python_demo.tar demo.py demo1.py demo2.py 案例查包 1tar -tvf python_demo.tar 案例解包 1tar -xvf python_demo.tar （2）压缩：linux/unix提供压缩解压命令，对合并后的tar包进行压缩节省硬盘空间。 命令 描述 gzip 压缩解压命令压缩文件gzip 文件名称.tar：压缩tar包，得到压缩文件 文件名称.tar.gz解压文件gzip -d 文件名称.tar.gz：解压文件得到tar包 文件名称.tar-d选项：decompress 解压缩 bzip2 压缩解压命令 zip/unzip zip用于压缩文件，得到：文件名称.zipunzip用于解压缩zip文件 xz 压缩xz -z 文件.tar 压缩后的文件 文件.tar.xz解压xz -d 文件.tar.xz 解压缩后的文件 文件.tar z 文件.tar 压缩后的文件 文件.tar.xz解压xz -d 文件.tar.xz 解压缩后的文件 文件.tar |","categories":[],"tags":[]},{"title":"java编辑工具说明","slug":"TreasureBox/Java/java编辑工具说明","date":"2022-05-19T01:14:40.370Z","updated":"2023-04-28T09:25:47.207Z","comments":true,"path":"2022/05/19/treasurebox/java/java-bian-ji-gong-ju-shuo-ming/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/java-bian-ji-gong-ju-shuo-ming/","excerpt":"","text":"1、关于java的集成开发环境【集成开发环境简称：IDE】 1.1、什么是集成开发环境？ * 集成开发环境可以让软件开发变得更简单、更高效。 * 没有IDE工具： - 需要安装JDK、需要配置环境变量、需要手动编译java文件。 - java源程序出错之后没有提示 - 没有自动提示功能 *有IDE工具： - 不需要独立安装JDK【IDE中已经集成】 - 不需要手动配置环境变量 - 不需要使用javac命令编译java源文件 - 并且java源程序编写错误会直接提示 - 使用IDE工具有很多代码不用编写，自动生成了 1.2、java有哪些IDE呢 * eclipse(免费)、myeclipse(收费)【最多】 * myeclipse * Intellij IDEA * NetBeans * JBuilder 1.3、eclipse快捷键： Ctrl+1 快速修复(最经典的快捷键,就不用多说了) Ctrl+D: 删除当前行 Ctrl+Alt+↓ 复制当前行到下一行(复制增加) Ctrl+Alt+↑ 复制当前行到上一行(复制增加) Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) Alt+↑ 当前行和上面一行交互位置(同上) Alt+← 前一个编辑的页面 Alt+→ 下一个编辑的页面(当然是针对上面那条来说了) Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性 Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后) Shift+Ctrl+Enter 在当前行插入空行(原理同上条) Ctrl+Q 定位到最后编辑的地方 Ctrl+L 定位在某行 (对于程序超过100的人就有福音了) Ctrl+M 最大化当前的Edit或View (再按则反之) Ctrl+/ 注释当前行,再按则取消注释 Ctrl+O 快速显示 OutLine Ctrl+T 快速显示当前类的继承结构 Ctrl+W 关闭当前Editer Ctrl+K 参照选中的Word快速定位到下一个 Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) Ctrl+/(小键盘) 折叠当前类中的所有代码 Ctrl+×(小键盘) 展开当前类中的所有代码 Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替) Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没 有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了) Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) Ctrl+Shift+F4 关闭所有打开的Editer Ctrl+Shift+X 把当前选中的文本全部变为大写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Ctrl+Shift+F 格式化当前代码 Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) 下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开头的了) Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力) Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用) Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候) Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能) Alt+Shift+I 合并变量(可能这样说有点不妥Inline) Alt+Shift+V 移动函数和变量(不怎么常用) Alt+Shift+Z 重构的后悔药(Undo)��构的后悔药(Undo)","categories":[],"tags":[]},{"title":"常用类","slug":"TreasureBox/Java/3.高阶用法/1.常用类","date":"2022-05-19T01:14:40.370Z","updated":"2023-04-28T09:25:47.211Z","comments":true,"path":"2022/05/19/treasurebox/java/3.gao-jie-yong-fa/1.chang-yong-lei/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/3.gao-jie-yong-fa/1.chang-yong-lei/","excerpt":"","text":"常用类一、正则表达式(理解)二、Math(理解)三、Random(理解)四、System(理解)五、BigInteger/BigDecimal(理解)六、Date/DateFormat/Calendar(掌握)","categories":[],"tags":[]},{"title":"方法重载(overload)和递归函数","slug":"TreasureBox/Java/2.java面向对象/7.方法重载(overload)和递归函数","date":"2022-05-19T01:14:40.369Z","updated":"2023-04-28T09:25:47.210Z","comments":true,"path":"2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/7.fang-fa-chong-zai-overload-he-di-gui-han-shu/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/7.fang-fa-chong-zai-overload-he-di-gui-han-shu/","excerpt":"","text":"方法重载和递归方法一、方法重载方法重载：两个方法的功能虽然不同，但是实现的功能类似，让程序员调用的时候就像调同一个方法。 （1）方法重载示例：12345678910111213141516171819202122232425262728293031323334353637383940/* 体验方法重载的优点： * 程序员调用方法的时候比较方便 前提：功能相似，功能不同时需要编写不同的方法。*/public class OverloadTest02{ public static void main(String[] args){ // 调用方法 int result1 = sum(1,2); System.out.println(result1); // 调用方法 double result2 = sum(1.0,2.0); System.out.println(result2); // 调用方法 long result3 = sum((long)1,(long)2); System.out.println(result3); } // 定义一个方法，计算两个int类型数据的和 public static int sum(int a, int b){ return a+b; } // 定义一个方法，计算两个double类型数据的和 public static double sum(double a, double b){ return a+b; } // 定义一个方法，计算两个long类型数据的和 public static long sum(long a, long b){ return a+b; }} （2）深入解析方法重载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*方法重载： 1、方法重载又被称为overload 2、什么时候考虑使用方法重载方法名相同 * 功能相似的时候，尽可能让方法名相同 * 功能不同时要让方法名不同 3、什么条件满足之后构成了方法重载 * 在同一个类中 * 方法名相同 * 参数列表不同： - 数量不同 - 类型不同 - 顺序不同 4、方法重载和什么有关系，和什么没关系？ * 方法重载和方法名+参数列表有关系 * 和返回值的类型没关系 * 和修饰符列表无关*/public class OverloadTest03{ public static void main(String[] args){ m1(3); m1(); m1(3,5); m1(1.0,3); } public static void m1(int a){} public static void m1(){} public static void m1(int a,int b){} public static void m1(double a,int b){} // 编译报错 /* public static void x(){} public static int x(){} */} （3）方法重载示例1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 方法重载的具体应用*/public class OverloadTest04{ public static void main(String[] args){ U.p(\"10\"); U.p(10); U.p(20.0); U.p('1'); }}class U{ public static void p(byte a){ System.out.println(a); } public static void p(short a){ System.out.println(a); } public static void p(int a){ System.out.println(a); } public static void p(long a){ System.out.println(a); } public static void p(double a){ System.out.println(a); } public static void p(boolean a){ System.out.println(a); } public static void p(char a){ System.out.println(a); } public static void p(String a){ System.out.println(a); }} 二、递归方法（1）递归方法详解12345678910111213141516171819202122232425262728293031323334/* 关于方法的递归调用 1、什么是递归？ 方法自身调用自身。 a(){ a(); } 2、递归是很耗费内存的，递归算法可以不用的时候尽量别用 3、以下程序会造成\"栈内存溢出\"错误： Exception in thread \"main\" java.lang.StackOverflowError 栈内存溢出错误 错误无法挽回，JVM停止工作。 4、递归必须要有结束条件，没有结束条件一定会发生内存溢出错误。*/public class RecursionTest01{ public static void main(String[] args){ System.out.println(\"main begin\"); doSome(); System.out.println(\"main over\"); } public static void doSome(int num){ // System.out.println(\"doSome begin\"); doSome(); // 这行代码不结束，下一行程序是不执行的 System.out.println(\"doSome over\"); }} （2）递归方法示例123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 1、使用递归实现斐波那契数列 2、使用递归实现1~N的和 3、计算阶乘*/public class RecursionTest02{ public static void main(String[] args){ int resultFeb = Feb(5); System.out.println(resultFeb); int resultSum = sum(3); System.out.println(resultSum); int resultCheng = cheng(5); System.out.println(resultCheng); } // 1、 Feb那契数列 public static int Feb(int a){ if(a ==1 || a==2){ return 1; } return Feb(a-1)+Feb(a-2); } // 2、使用递归计算1~N的和 public static int sum(int n){ if(n==1){ return 1; } return n + sum(n-1); } // 3、计算阶乘 public static int cheng(int n){ if (n==1) { return 1; } return n*cheng(n-1); }} =1){ return 1; } return n + sum(n-1); } // 3、计算阶乘 public static int cheng(int n){ if (n==1) { return 1; } return n*cheng(n-1); } }","categories":[],"tags":[]},{"title":"对象的创建和构造方法","slug":"TreasureBox/Java/2.java面向对象/8.对象的创建和构造方法","date":"2022-05-19T01:14:40.369Z","updated":"2023-04-28T09:25:47.209Z","comments":true,"path":"2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/8.dui-xiang-de-chuang-jian-he-gou-zao-fang-fa/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/8.dui-xiang-de-chuang-jian-he-gou-zao-fang-fa/","excerpt":"","text":"对象的创建 类和对象的区别 1234567891011121314151617181920212223242526272829303132333435363738面向对象【java语言的核心机制，最重要的内容，java语言的特色】 * 面向过程和面向对象的区别 -- 面向过程：主要关注点是：实现的具体过程，因果关系 -- 面向对象：主要关注对象【独立体】能完成哪些功能。 优点：耦合度低，扩展力强。 缺点：前期投入成本较高，需要进行独立体的抽取，大量的系统设计 -- c语言是纯面向过程的、C++半面向对象、java纯面向对象 * 面向对象的三大特性 —— 封装 —— 继承 —— 多态 面向对象的分析：OOA 面向对象的设计：OOD 面向对象的编程：OOP * 类和对象的概念 * 什么是类？ —— 类是一个概念，又名类型，代表了一类事物 —— 在现实世界当中，对象A与对象B具有共同特征，进行抽象总结出的模板 * 对象？ —— 是实际存在的个体。现实当中实际存在 类——&gt;【实例化】——&gt;对象 对象又被称为实例/instance 对象——&gt;【抽象】——&gt;类 * 一个类主要描述什么信息呢？ 一个类主要描述的是状态+动作。 * 类的定义 语法结构： [修饰符列表] class 类名{ } java虚拟机内存分配 123456789101112131415161718192021222324252627282930311、JVM(Java虚拟机)主要包括三块内存空间，分别是：栈内存、堆内存、方法区内存2、堆内存和方法区内存各有一个，一个线程一个栈内存。3、方法调用的时候，该方法所需要的的内存空间在栈中分配，称为压栈。方法结束之后， 该方法所属内存空间释放，称为弹栈。4、栈中主要存储的是方法体当中的局部变量。5、方法的代码片段以及整个类的代码片段都被存储在方法区内存当中，在类加载的时候， 这些代码片段会载入。6、在程序执行过程中使用new运算符创建的java对象,存储在堆内存中.对象内部有实例, 所以实例变量存在堆内存中.7、变量分类： - 局部变量【方法体中声明】 - 成员变量【方法体外声明】 实例变量【前边修饰符没有static】 静态变量【前边修饰符中有static】8、静态变量存储在方法区内存当中9、三块内存变化最频繁的是栈内存，最先有数据的是方法区内存，垃圾回收器主要针对堆内存。10、垃圾回收器【自动垃圾回收机制，GC机制】 * 当堆内存当中的java对象成为垃圾数据的时候，会被垃圾回收器回收。 * 什么时候会变成垃圾呢？ 没有更多的引用指向它的时候 这个对象无法被访问，因为访问对象只能通过引用的方式 对象的创建和使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* 对象的创建和使用*/public class OOTest01{ public static void main(String[] args){ // 通过一个类可以实例化N个对象 // 实例化对象语法：new 类名(); // new是java语句当中的一个运算符 // new运算符的作用是创建对象，在JVM堆内存中开辟新的内存空间 // 方法区内存在；类加载的时候，.class字节码文件被加载到该内存空间当中 // 栈内存（局部变量）：方法代码片段执行的时候，会给该方法分配内存空间，在栈中压栈 // 堆内存：new产生的对象 // Student是一个引用数据类型 // s是一个局部变量，存储在栈内存中 // new Studnet()是一个学生对象 // s是一个局部变量，存储对象的内存地址 Student s = new Student(); // 什么是对象？new运算符在堆内存中开辟的内存空间称为对象 // 什么是引用？引用是一个变量，只不过这个变量保存了内存地址 // 访问变量实例的语法格式 // 读取数据：引用.变量名 // 修改数据：引用.变量名 = 值 int stuNo = s.no; int stuAge = s.age; String stuName = s.name; boolean stuSex = s.sex; System.out.println(\"姓名:\"+stuNo); System.out.println(\"年龄:\"+stuAge); System.out.println(\"姓名:\"+stuName); System.out.println(\"性别:\"+stuSex); s.name = \"张三\"; System.out.println(\"姓名：\"+stuName); System.out.println(\"姓名：\"+s.name); // stu也是一个引用,存储新实例的内存地址 Student stu = new Student(); System.out.println(stu); // 编译报错： // 通过实例才能访问实例变量，不能直接通过类名的格式访问 // System.out.println(Student.no); }}/* 局部变量在栈内存中存储 成员变量中的实例变量在堆内存的java对象内部存储 实例变量是一个对象一份，100个对象有100份*/ 123456789101112// 学生类public class Student{ // 不创建对象，变量的内存空间是不存在的 // 创建完对象之后，对象存储在堆内存中 String name; // String类型的成员变量不赋值默认为null int age; int no; boolean sex;} java中的构造方法（1）构造方法综述 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package test003;/** * 关于java中的构造方法： * 1、构造方法又被称为构造函数/构造器/Constructor * * 2、构造方法语法结构： * [修饰符列表] 构造方法名(形式参数列表){ * 构造方法体; * } * * 3、普通方法 * [修饰符列表] 返回值类型 方法名(形参列表){ * 方法体; * } * 4、对于构造方法来说，返回值类型不需要指定，并且也不能写 * void，只要有void就是普通方法了 * * 5、对于构造方法来说，构造方法的方法名必须和类名保持一致 * * 6、构造方法的作用： * 构造方法存在的意义是通过构造方法的调用，可以创建对象 * * 7、构造方法怎么调用？ * -- 普通方法调用：修饰符有static时候，类名.方法名； * 没有static时候，引用.方法名 * -- 构造方法：new 构造方法名(实参列表) * * 8、构造方法的返回值: * 每一个构造方法实际上执行结束之后都有返回值，但是这个\"return 值\";这样的语句不需要写。 * 构造方法结束的时候Java程序自动返回值。 * 并且返回值类型是构造方法所在类的类型。由于构造方法的返回值类型就是类本身，所以返回值类型不需要写。 * * 9、当一个类中没有任何构造方法的话，系统会默认产生一个无参数的构造方法，这个构造方法被称为缺省构造器。* * 10、建议开发中手动为当前类提供无参数构造方法* * 11、构造方法支持重载机制，在一个类当中编写多个构造方法。** 12、构造方法不能使用*/public class ConstructorTest01 { public static void main(String[] args) { // 创建User对象; // 只要构造方法调用，就会创建对象，以下创建两个对象，在堆内存中 User u = new User(3); new User(); new User(\"hello\"); // 带有static的方法有两种调用形式 u.doSome(); User.doSome(); // 不带static的方法要使用引用.方法，名调用 u.doOther(); } （2）、构造方法的作用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package test003;/** * 构造方法的作用： * 1、创建对象 * 2、创建对象的同时，初始化实例变量的内存空间 * * 成员变量之实例变量，属于对象级别的变量，这种变量必须现有对象才能有实例变量。 * 实例变量的内存空间是在构造方法的执行过程中完成开辟的 * 系统在默认赋值的时候，也是在构造方法执行过程中完成赋值的。 * * 实例变量是存储在JVM的堆内存内部 * */public class ContructorTest02 { public static void main(String[] args) { Account a = new Account(); System.out.println(a); Account a1 = new Account(\"110\"); System.out.println(a1); System.out.println(\"账户是：\"+a1.getActno()); } }// 账户类public Account { // 账户 private String actno; private double balance; public Account() { // 初始化实例变量的内存空间 // actno = null; // balance = 0.0 } public Account(String s) { actno = s; } public String getActno() { return actno; } public void setActno(String actno) { this.actno = actno; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } } 12345678910111213141516171819202122232425262728293031package test003;/** * 这是一个User类 * */public class User { public User() { System.out.println(\"无参数的User构造器\"); } // 定义有参数的构造方法 public User(int age) { System.out.println(\"带有Int类型参数的构造器\"); } public User(String s) { System.out.println(\"带有String参数的构造器\"); } public static void doSome() { System.out.println(\"带有static的方法\"); } public void doOther() { System.out.println(\"不带static的方法\"); }} .out.println(“带有String参数的构造器”); } public static void doSome() { System.out.println(“带有static的方法”); } public void doOther() { System.out.println(“不带static的方法”); } }","categories":[],"tags":[]},{"title":"封装、继承和多态","slug":"TreasureBox/Java/2.java面向对象/9.封装、继承和多态","date":"2022-05-19T01:14:40.369Z","updated":"2023-04-28T09:25:47.208Z","comments":true,"path":"2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/9.feng-zhuang-ji-cheng-he-duo-tai/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/9.feng-zhuang-ji-cheng-he-duo-tai/","excerpt":"","text":"封装、继承和多态一、封装（1）封装的好处1234567891011121314151617181920212223242526272829303132333435363738394041/* * 用户测试类 * 对象可以随便修改属性 * * * 封装的好处： * 1、封装之后，看不到事物复杂的一面，对外提供简单的入口。 * * 2、封装之后才会形成真正的“对象”，真正的独立体 * * 3、封装就意味着程序可以重复使用，并且事物的适应性比较强，在任何场所都可以用 * * 4、事物封装之后，安全性提升。 */public class UserTest { public static void main(String[] args) { //创建对象 User user = new User(); // 访问age System.out.println(\"用户年龄为：\"+ user.age); // 修改用户年齡 user.age = 20; System.out.println(\"用户年龄为：\"+ user.age); // age属性暴露出来，导致数据出现不合适的数据 // 不建议这样，建议User类型进行封装，建议在外部程序不能随意修改 user.age = -100; System.out.println(\"用户年龄为：\"+user.age); }}class User { int age;} （2）封装的步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * 封装的步骤： * 1、所有属性私有化，使用private关键字进行修饰，private表示私有的，修饰的所有数据只能在本类中访问。 * * 2、对外提供简单的操作入口，以后再想访问只能通过这些入口进行访问： * -- 对外提供两个公开的方法，分别是set方法和get方法 * -- 想修改age属性，调用set方法 * -- 想读取age属性，调用get方法 * * 3、set方法的命名规范： * public void setAge(int a){ * age =a; * } * public 返回值类型 getAge(){ * return age; * } * * 需要熟记： * setter and getter方法没有static关键字 * 有static关键字修饰的方法调用：类名.方法名(实参) * 没有static关键字修饰的方法调用：引用.方法名(实参) * * */public class User { // 属性私有化 private int age; // 形参名称不能跟属性名相同 public void setAge(int a) { // 在此处对传的参数做限制 if (a&lt;0 || a&gt;150) { System.out.println(\"您输入的年龄不合法\"); return; } age = a; } public int getAge() { return age; } } 二、继承（1）类的继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 关于java语言中的继承： * 1、继承是面向对象的三大特征之一，三大特征分别是：封装、继承、多态 * * 2、继承的基本作用是：代码复用。继承最重要的作用是：有了继承之后才有了以后的方法覆盖和多态机制。 * * 3、继承语法格式 * [修饰符列表] class 类名 extends 父类名{ * 类体 = 属性 + 方法 * } * * 4、java语言中只支持单继承，一个类中不能同时继承很多类，只能继承一个类 * * 5、关于继承的一些术语： * B类继承A类，其中： * A类称为：父类、基类、超类、superclass * B类称为：子类、派生类、subclass * * 6、在java语言中，子类继承父类都继承哪些数据呢？ * ① 私有的不支持继承 * ② 构造方法不支持继承 * ③ 其他数据都可以继承 * * 7、虽然java语句中只支持单继承，但是一个类也可以间接继承其他类，例如： * C extends B{ * } * B extends A{ * } * A extends T{ * } * C直接继承B，但是也间接继承T、A类 * * 8、java语言中假设一个类没有显示的继承任何类，该类默认集成JavaSE库中的java.lang,Object类 * java语言中任何一个类都有Object类的特征 * * */ public class ExtendsTest { public static void main(String[] args) { ExtendsTest et = new ExtendsTest(); String s = et.toString(); System.out.println(s); CreditAccount act = new CreditAccount(); act.setActno(\"act-01\"); System.out.println(act.getActno()); }} 1234567package test12;// 银行账户public class Account {} 1234567package test12;// 信用账户public class CreditAccount extends Account { } 面试题：在java中定义一个不做事且没有参数的构造方法的作用？ Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类中加一个不做事且没有参数的构造方法。 （2）方法的覆盖/重写 区别点 重载方法 重写方法 发生范围 同一个类 子类 中 参数列表 必须修改 一定不能修改 返回类型 可修改 一定不能修改 异常 可修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问修饰符 可修改 一定不能做更严格的限制（可以降低限制） 发生阶段 编译期 运行期 1234567891011121314151617181920212223242526272829303132333435363738394041424344package test13;/** * * 关于方法的覆盖， * 1、方法覆盖又被称为方法重写，英语单词：override[官方的]/overwrite * * 2、什么时候使用方法覆盖？ * 当父类的中的方法已经无法满足当前子类的业务需求。 * 子类有必要将父类继承过来的方法进行重新编写。 * 这个子类中重新编写的方法称为方法重写/覆盖。 * * 3、什么时候发生方法重写？ * 方法重写发生在有继承关系的父子类之间 * 方法重写的时候：方法名相同，返回值类型相同，形参列表相同 * 方法重写的时候：访问权限不能更低，只能更高public/private/proteced * 方法重写的时候：抛出异常不能更多，可以更少 * * 4、建议方法重写的时候直接复制粘贴，避免出错！！！ * * 5、注意： * 私有方法不能继承，所以不能覆盖 * 构造方法不能继承，所以不能覆盖 * 静态方法不存在覆盖 * 覆盖只针对方法，不谈属性 * * */public class OverrideTest01 { public static void main(String[] args) { Animal a = new Animal(); a.move(); Cat c = new Cat(); c.move(); Bird b = new Bird(); b.move(); YingWu yw =new YingWu(); yw.move(); }} 123456789package test13;public class Animal { public void move() { System.out.println(\"动物在移动\"); }} 12345678package test13;public class Bird extends Animal{ public void move() { System.out.println(\"鸟儿在飞翔\"); }} 三、多态 多态的基础语法 多态主要指编译形态和运行形态的两种形态，主要涉及类型之间的转换： 向上转型(upcasting)： 父类型引用子类型对象 向下转型(downcasting) 只有访问子类中的特有的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package com.bjpower.javase.test001;/** * 关于java语言中的多态 * 1、Animal、Cat、Bird三个类之间的关系 * Animal是父类 * Cat和Bird都继承Animal类 * Cat和Bird都重写父类的move方法 * * 2、面向对象三大特征分别为：封装、继承、多态 * * 3、关于多态中设计到的概念： * —— 向上转型 (upcasting) * 子类型 --&gt; 父类型 * 又被称为：自动类型转换 * * —— 向下转型 (downcasting) * 父类型——&gt; 子类型 * 又被称为：强制类型转换【需要加强制类型转换符】 * * —— 需要记忆：不论是向上转型，还是向下转型，两种类型之间必须要有继承关系 * 没有继承关系，程序无法编译通过。 * * */public class Test { public static void main(String[] args) { Animal a1 = new Animal(); a1.move(); Cat c = new Cat(); c.move(); Bird b1 = new Bird(); b1.move(); // 使用多态语法继承机制 /** * 1、Animal和Cat之间存在继承关系，Animal是父类，Cat是子类 * * 2、Cat is a Animal * * 3、new Cat()创建的对象的类型是Cat，a2这个引用的数据类型是Animal，可见他们进行了类型转换 * 子类型转换成父类型，称为向上转型/upcasting，或者成为自动类型转换 * * 4、Java中允许这种语法：父类型引用指向子类型对象 * * * */ Animal a2 = new Cat(); /** * 1、java程序永远都分为编译阶段和运行阶段 * * 2、先分析编译，再分析运行阶段，编译无法通过，根本无法运行 * * 3、编译阶段编译器检查a2这个引用的数据类型为Animal，由于Animal.class字节码中有move()方法， * 所以编译编译通过了。这个过程称为静态绑定、编译阶段绑定。 * 只有静态绑定成功之后才有后续的运行 * * 4、在程序运行阶段，JVM虚拟堆内存中真实创建的对象是Cat对象， * 那么以下程序在运行阶段一定会调用Cat对象的move()方法， * 此时发生了程序的动态绑定，运行阶段绑定 * * 5、无论是Cat类有没有重写move方法，运行阶段一定调用的是Cat对象的move方法， * 因为底层真实对象是Cat对象。 * * 6、父类型引用指向子类型对象这种机制导致程序存在编译阶段绑定和运行阶段绑定两种不同的形态。 * 这种机制可以称为一种多态语法机制。 * * */ // 只有子类和父类都有的方法才能调用 a2.move(); // 编译阶段没有在Animal中找到catchMouse()方法，导致静态绑定失败，没有绑定成功 // a2.catchMouse(); // 编译报错，因为catchMouse在父类中没有 /** * 需求：想让以上对象执行catchMouse方法 * 将a2从Animal类型强制类型转换为Cat类型，称为向下转型(downcasting) * * * 注：强制类型转换需要加强制类型转换符 * * 什么时候需要向下转型？ * 当调用的方法是子类型中特有的，在父类型中不存在，必须向下转型 * */// Cat a3 = (Cat)a2; // 强制类型转换// a3.catchMouse(); // long l = 100L; // int i = (int)l; /** * 1、以下程序编译是没有问题的，因为编译器检查到a3引用的数据类型是Animal * Animal和Cat存在继承关系，并且Animal是父类型，Cat是子类型 * 父类型转换成子类型叫做向下转型，语法合格 * * 2、程序虽然编译通过了，但是程序在运行阶段会出现异常，因为JVM堆内存中真实存在的是Bird类型， * Bird类型 无法转换成Cat类型，因为两种类型之间不存在任何继承关系，此时会出现异常： * java.lang.ClassCastException * 类型转换异常，这种异常总是发生在\"向下转型\"时 * */ Animal a3 = new Bird();// Cat c3 = (Cat)a3; /** * 1、以上异常只有在强制类型转换时候发生，也就是\"向下转型\"时存在隐患（编译过了，运行报错） * * 2、向上转型只要编译通过，运行一定不会出现问题，Animal a = new Cat(); * * 3、向下转型编译通过，运行可能出现错误；Animal a3 = new Bird(); Cat c3 = (Cat)a3; * * 4、向下转型怎么避免java.lang.ClassCastException异常？ * 使用instanceof运算符 * * 5、instanceof运算符怎么使用？ * 5.1、语法格式 * (引用 instanceof 数据类型名) * 5.2、以上运算符的执行结果类型是布尔类型，结果可能是true/false * 5.3、关于运算结果true/false * 假设：(a instanceof Animal) * true表示： * a这个引用执行的是Animal类型 * false表示： * a这个引用不是一个Animal类型 * * 6、Java语法规范中要求：在进行强制类型转换之前，建议采用instanceof运算符进行判断， * 避免ClassCastException * * */ if(a3 instanceof Cat) { // a3是一个Cat类型的对象 Cat c3 = (Cat)a3; c3.move(); }else if(a3 instanceof Bird) { // a3是一个Bird类型的对象 Bird c3 = (Bird)a3; c3.move(); }; }} 123456789101112package com.bjpower.javase.test001;// 动物类public class Animal { public void move() { System.out.println(\"动物在移动！\"); }} 12345678910111213141516171819package com.bjpower.javase.test001;// 猫类public class Cat extends Animal{ // 重写父类的move()方法 public void move() { System.out.println(\"猫在走猫步！\"); } // 猫类特有的方法 public void catchMouse() { System.out.println(\"猫抓老鼠\"); } } 123456789101112package com.bjpower.javase.test001;// 鸟类public class Bird extends Animal{ public void move() { System.out.println(\"鸟儿在飞翔\"); } } 多态知识点总结 1234567891011121314151617181920212223package com.bjpower.javase.test001;public class Test02 { public static void main(String[] args) { // 父类型引用指向子类型对象 // 向上转型 Animal a1 = new Cat(); Animal b2 = new Bird(); // 向下转型 if(b2 instanceof Bird) { Bird b3 = (Bird)b2; b3.move(); }else if(b2 instanceof Cat) { Cat b3 = (Cat)b2; b3.move(); }; }} 多态在开发中的作用 以人喂养宠物为例，Cat和Dog和Snake都继承Pet，人在喂养时针对Pet，不关注具体传的对象是哪一个。 123456789101112131415161718192021222324252627282930313233package com.bjpower.javase.test002;/** * 多态在实际开发中的作用 * 1、分析：主人喂养宠物这个场景实现需要进行类型的抽象： * —— 主人【类】 * —— 主人可以喂养宠物，所以主人有喂养的动作 * —— 宠物【类】 * —— 宠物可以吃东西，所以宠物有吃东西这个动作 * 2、面向对象编程的核心，定义好类，然后将实例化为对象，给一个环境驱使一下，让各个对象之间形成一个系统 * * 3、多态的作用是什么？ * 降低程序的耦合度，提高程序的能力 * 能使用多态尽量使用多态 * 父类型的引用指向子类型 * * 核心：面向抽象编程，尽量不要面向具体编程 * * */public class Test { public static void main(String[] args) { Master zhangsan = new Master(); Cat tom = new Cat(); Dog erHa = new Dog(); Snake snake = new Snake(); zhangsan.feed(tom); zhangsan.feed(erHa); zhangsan.feed(snake); }} 123456789101112131415package com.bjpower.javase.test002;/** * 人类 * */// 降低程序的耦合度【解耦合】，提高程序的扩展能力【软件开发的一个很重要的目标】public class Master { // 提倡：面向对象编程，不要面向具体编程 public void feed(Pet c) { c.eat(); }} 宠物类： 12345678package com.bjpower.javase.test002;public class Pet { public void eat() { System.out.println(\"吃\"); }} 12345678910111213package com.bjpower.javase.test002;/** * 宠物小猫 * */public class Cat extends Pet{ // 小猫爱吃鱼 public void eat() { System.out.println(\"小猫在吃鱼\"); }} 1234567891011package com.bjpower.javase.test002;/** * 宠物小狗 * */public class Dog extends Pet{ public void eat() { System.out.println(\"小狗吃骨头\"); }} 1234567891011package com.bjpower.javase.test002;/** * 蟒蛇宠物 * */public class Snake extends Pet{ public void eat() { System.out.println(\"蛇吞象\"); }} bjpower.javase.test002; /** 宠物小猫 */public class Cat extends Pet{ // 小猫爱吃鱼 public void eat() { System.out.println(“小猫在吃鱼”); } } 12345678910111213```javapackage com.bjpower.javase.test002;/** * 宠物小狗 * */public class Dog extends Pet{ public void eat() { System.out.println(\"小狗吃骨头\"); }} 1234567891011package com.bjpower.javase.test002;/** * 蟒蛇宠物 * */public class Snake extends Pet{ public void eat() { System.out.println(\"蛇吞象\"); }}","categories":[],"tags":[]},{"title":"Java面向对象","slug":"TreasureBox/Java/2.java面向对象/Java面向对象","date":"2022-05-19T01:14:40.369Z","updated":"2023-04-28T09:25:47.211Z","comments":true,"path":"2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/java-mian-xiang-dui-xiang/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/java-mian-xiang-dui-xiang/","excerpt":"","text":"Java面向对象一、类和对象 面向对象和面向过程的区别？ 面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。 面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。 面向过程 ：面向过程性能比面向对象高？？ 123这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。 构造器Constructor是否可被overide？ Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 在Java中定义一个不做事且没有参数的构造方法的作用？ Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 成员变量和局部变量的区别有哪些？ 从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。 创建一个对象用什么运算符？对象实体与对象引用有何不同？ new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正常执行吗？为什么？ 主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。 构造方法有哪些特性？ 名字与类名相同。 没有返回值，但不能用 void 声明构造函数（带void声明的代表是普通方法）。 生成类的对象时自动执行，无需调用。 在调用子类构造方法之前会先调用父类没有参数的构造方法，目的是什么？ 帮助子类做初始化工作 对象相等与指向他们的引用相等，两者有什么不同？ 对象相等比的是内存中存放的内容是否相等，而引用相等比的是指向的内存地址是否相等。 二、面向对象三大特征 封装 封装指把一个对象的状态信息（也就是属性），隐藏在对象的内部，不允许外部直接访问对象的内部信息，但是可以提供一届可以被外界访问的方法来操作属性，就好像我们看不到空调的内部组件（也就是属性），但是可以使用遥控器(方法)来控制空调，如果属性不想被外界访问，就可以不提供方法给外界。但是如果一个类没有提供给外界的方法，name这个类就没什么意义了。 123456789101112131415161718192021222324public class Student { private int id;//id属性私有化 private String name;//name属性私有化 //获取id的方法 public int getId() { return id; } //设置id的方法 public void setId(int id) { this.id = id; } //获取name的方法 public String getName() { return name; } //设置name的方法 public void setName(String name) { this.name = name; }} 继承 不同的对象，相互之间经常有一定数量的共同点。例如，小茗同学，小红，小刚等都共享学生的特性，同时，每一个对象可能还有不同的特性，比如小明数学好，小红性格好，小刚力气大等。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承，可以快速的创建新的类，提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高开发效率。 关于继承需要牢记： 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类无法访问，只是拥有。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法（重写/orveride）。 多态 多态，表示一个对象具有多种状态。具体表现为父类的引用指向子类的实例，让对象在编译器和运行期具有不同的状态。 多态的特点： 对象类型和引用类型之间具有继承（类）/实现（接口）的关系； 对象类型不可变，引用类型可变； 方法具有多态性，属性不具有多态性； 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 三、修饰符 在一个静态方法中调用一个非静态成员为什么是非法的？ 由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他的非静态变量，也不可以访问非静态变量的成员。 静态方法和实例方法有什么不同？ 在外部调用静态方法时，可以试用“类名.方法名”的方式，也可以使用“对象名.方法名的方式”（不推荐，静态方法跟具体的对象已经没有关系），而实例方法只能使用后面的方式。也就是：调用静态方法不需要创建对象 静态方法在访问本类成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法。实例方法则无此限制。 常见的关键字总结，this，static，final，super： this：用于引用类的当前实例，不能用在静态方法中。此关键字可选。 static关键字主要有以下四种使用场景： 12345671、修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()2、静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.3、静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。4、静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 final关键字主要用在三个地方：变量、方法、类。 123451、对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。2、当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。3、使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final super关键字用于从子类访问父类的变量和方法。 1234567891011121314public class Super { protected int number; protected showNumber() { System.out.println(\"number = \" + number); }}public class Sub extends Super { void bar() { super.number = 10; super.showNumber(); }} 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。 四、接口类和抽象类 接口和抽象类的区别是什么？ 接口的方法默认是public，所有方法在接口中不能有实现（Java 8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了static、final变量，不能有其他变量，而抽象类中则不一样。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被抽血所以不能使用private关键字修饰） 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 备注： 在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:https://github.com/Snailclimb/JavaGuide/issues/146。 jdk9 的接口被允许定义私有方法 。 总结一下 jdk7~jdk9 Java 中接口概念的变化： 在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。 jdk8 的时候接口可以有默认方法和静态方法功能。 Jdk 9 在接口中引入了私有方法和私有静态方法 五、其他 String，StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？ 简单来说：String类中使用final关键字修饰字符数组来保存字符串private final char value[],所以String`对象是不可变的。 补充：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte[] value; 而StringBuilder与StringBuffer都继承自AbstractStringBulder类，在AbstractStringBuilder中也是使用字符数组保存字符串char[] value，但是没有用final关键字修饰，所以这两种对象都是可变的。 StringBuilder与StringBuffer的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的。 线程安全性： String中的对象是不可变，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能： 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 三者的总结： 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer Object类常见方法总结 (1)是类层次结构的根类，所有类都直接或者间接的继承自该类。 (2)构造方法： 有一个无参构造方法。 (3)成员方法： 12345678910111213141516171819public final native Class&lt;?&gt; getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念 ==与equals(重要) **==：作用主要是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象（基本数据类型==比较的是值，引用数据类型==**比较的是内存地址）。 equals()：作用也是判断两个对象是否相等。但它一般有两种使用情况。 情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于使用”==”比较。 情况2：类覆盖了equals()方法。一般，我们覆盖equals()方法来比较两个对象的内容是否相等；若他们的内容相等，则返回true(即认为两个对象相等)。 示例： 12345678910111213141516171819202122232425public class Test001 { public static void main(String[] args) { String a = new String(\"ab\"); // a为一个引用， String b = new String(\"ab\"); // b为另一个引用，对象的内容一样 String aa = \"ab\"; // 放在常量池中 String bb = \"ab\"; // 从常量中查找 if (aa == bb) { // true System.out.println(\"aa==bb\"); } if (a == b) { // false，非同一个对象 System.out.println(\"a==b\"); } if (a.equals(b)) { // true System.out.println(\"a equals b\"); } if (42 == 42.0) { // true System.out.println(\"true\"); } }} 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 hashCode与equals（重要） 重写过hashcode和equals么？为什么重写equal时需要重写hashCode方法？ hashCode()介绍 hashCode作用是获取哈希码，也成为了散列码；实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object。java中，这也意味着Java的任何类都包含有hashCode()函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode asd asd asd asd 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode asd asd asd asd","categories":[],"tags":[]},{"title":"包的使用和Object类介绍","slug":"TreasureBox/Java/2.java面向对象/11.包的使用和Object类介绍","date":"2022-05-19T01:14:40.368Z","updated":"2023-04-28T09:25:47.208Z","comments":true,"path":"2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/11.bao-de-shi-yong-he-object-lei-jie-shao/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/11.bao-de-shi-yong-he-object-lei-jie-shao/","excerpt":"","text":"包的使用和Object类介绍一、包的概念12345678910111213141516171819202122232425262728293031323334/* 关于java语言中的包机制 1、包又称为package，java中引入package这种语法机制主要为了方便程序的管理 不同功能的类被分门别类放到不同的软件包中，查找比较方便，管理比较方便，易维护 2、怎么定义package？ —— 在java源程序的第一行上编写package语句 —— package只能编写一个语句 —— 语法结构： package 包名; 3、包名的命名规范 公司的域名倒序 + 项目名 + 模块名 + 功能名; 采用这种方式的重名几率比较低，因为公司域名具有全球唯一性 例如： com.bjpowernode.oa.user.service org.apach.tomcat.core 4、包名要求全部小写，包名也是标识符，必须遵守标识符命名规则 5、一个包将来对应一个目录 6、使用步骤，以com.bjpowernode.javase.day11为例： 第一种方式： 先使用javac Test01.java编译生成javac字节码：指定编码加：-encoding utf-8 手动创建com/bjpowernode/javase/day11文件夹 运行：java com.bjpowernode.javase.day11.Test01 第二种方式： javac -d 编译之后存放路径 java源文件的路径*/package com.bjpowernode.javase.day11; // 对应四个目录public class Test01{ public static void main(String[] args){ } } 1234567891011121314package com.bjpowernode.javase.day11; // 对应四个目录class Test02 { public static void main(String[] args) { com.bjpowernode.javase.day11.Test01 t = new com.bjpowernode.javase.day11.Test01(); System.out.println(t); //com.bjpowernode.javase.day11.Test01@15db9742 // Test01和Test02在同一个包下，默认在当前包下找，可以使用这种方式 Test01 tt = new Test01(); System.out.println(tt); //com.bjpowernode.javase.day11.Test01@6d06d69c }} 12345678910111213141516171819202122232425262728293031package org.apache;/* import语句用来导入其他类，同一个类下的类不需要导入 不在同一个包下的类需要导入 import 包名 import 包名.*结论：什么时候需要import导入 不在同一个包中 不在java.lang包下*/import com.bjpowernode.javase.day11.Test01;class Test04 { public static void main(String[] args) { com.bjpowernode.javase.day11.Test01 t = new com.bjpowernode.javase.day11.Test01(); System.out.println(t); //com.bjpowernode.javase.day11.Test01@15db9742 Test01 tt = new Test01(); System.out.println(tt); //com.bjpowernode.javase.day11.Test01@15db9742 // java.lang.*不需要导入，系统自动引入 // lang：language语言包，是java的核心类，不需要手动导入 String str = \"name\"; }} 二、Java中自带的包 Object类常见方法总结： (1)是类层次结构的根类，所有类都直接或者间接的继承自该类。 (2)构造方法： 有一个无参构造方法。 (3)成员方法： 12345678910111213141516171819public final native Class&lt;?&gt; getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念 过该方法一直等待，没有超时时间这个概念 ```","categories":[],"tags":[]},{"title":"Scanner和String类的使用","slug":"TreasureBox/Java/2.java面向对象/12.Scanner和String类的使用","date":"2022-05-19T01:14:40.368Z","updated":"2023-04-28T09:25:47.207Z","comments":true,"path":"2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/12.scanner-he-string-lei-de-shi-yong/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/12.scanner-he-string-lei-de-shi-yong/","excerpt":"","text":"Scanner和String的使用一、Scanner的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Scanner的使用 * 1、JDK5以后，帮助实现键盘录入数据 * * 2、构造方法： * public Scanner(InputStream is) * Scanner sc = new Scanner(System.in); * * 3、成员方法： * A：hasNextXxx() 判断是否是xxx类型的元素 * B：nextXxx() 获取xxx类型的元素 * * 4、常用的三个方法 * nextInt(): 获取一个int类型的数据 * next()/nextLine(): 获取一个String类型的数据 * * 5、注意的小问题： * int ---&gt; int * String ---&gt; String * String ---&gt; int * int ---&gt; String * * 如何解决： * A：所有数据都用String接收，将来要什么，就转换为什么 * B：重新创建一个新的Scanner对象 * */import java.util.Scanner;public class ScannerTest001 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); if(sc.hasNextInt()) { int number = sc.nextInt(); System.out.println(\"number\"+number); }else { String str1 = sc.nextLine(); System.out.println(\"str1\"+str1); } int x = sc.nextInt(); sc = new Scanner(System.in); String y = sc.nextLine(); // 把回车换行给了这里 System.out.println(x); System.out.println(y); }} 二、String类 String的构造方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * 1、字符串：由多个字符组成的一串数据 * * 2、构造方法有： * public String():创建String对象 * public String(byte[] bytes):把字节数组转成字符串 * public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 * public String(char[] value):把字符数组转成字符串 * public String(char[] bytes,int index,int length):把字符数组的一部分转成字符串 * public String(byte[] bytes):把字节数组转成字符串 * public String(String original):把字符串转成字符串 * * 3、问题： * 1、输出语句输出任何对象名称的时候，默认调用的是该对象的toString()方法。 * toString()方法默认输出的是包名...类名@哈希值的十六进制 * 如果输出一个对象名称的时候，发现不是这个格式，说明该类重写了toString()方法 * 2、返回字符串的长度 * public int length() * * 面试题：数组有length()吗？String有length()吗？ * 没有 有 * * 4、字符串是常量，它的值创建之后不能更改 * * 5、String s = new String(\"hello\");和String s = \"hello\";的区别 * ==：比较的引用类型时比较的是地址 * equals()：默认比较的是地址值。String类重写了equals()方法，该方法的作用是比较字符串的内容是否相等 * * */public class StringTest001 { int number=1; public static void main(String[] args) { // public String() 创建String对象 String s1 = new String(); System.out.println(\"s1:\"+s1); System.out.println(\"s1.length():\"+s1.length()); System.out.println(\"--------------------------\"); // public String(byte[] bytes):把字节数组转成字符串。 byte[] bytes = { 97, 98, 99, 100, 101 }; String s2 = new String(bytes); // 把数值转成对应的字符值 System.out.println(\"s2:\" + s2); System.out.println(\"s2.length():\" + s2.length()); System.out.println(\"--------------------------\"); // public String(byte[] bytes,int index,int length):把字节数组中的一部分转成字符串 // String s3 = new String(bytes, 1, 2); String s3 = new String(bytes, 0, bytes.length); System.out.println(\"s3:\" + s3); System.out.println(\"s3.length():\" + s3.length()); System.out.println(\"--------------------------\"); // public String(char[] value):把字符数组转成字符串 char[] chs = { 'a', 'b', 'c', 'd', 'e', '林', '青', '霞' }; String s4 = new String(chs); System.out.println(\"s4:\" + s4); System.out.println(\"s4.length():\" + s4.length()); System.out.println(\"--------------------------\"); // public String(char[] value,int index,int count):把字符数组的一部分转成字符串 // 需求：我要输出的字符串是:de林青 String s5 = new String(chs, 3, 4); System.out.println(\"s5:\" + s5); System.out.println(\"s5.length():\" + s5.length()); System.out.println(\"--------------------------\"); // public String(String original):把字符串转成字符串 String s6 = new String(\"helloworld\"); System.out.println(\"s6:\" + s6); System.out.println(\"s6.length():\" + s6.length()); System.out.println(\"--------------------------\"); // Java 程序中的所有字符串字面值（如 \"abc\" ）都作为此类的实例实现。 String s7 = \"helloworld\"; System.out.println(\"s7:\" + s7); System.out.println(\"s7.length():\" + s7.length()); // 字符串创建之后不能修改，但是可以修改变量的引用 String s8 = \"hello\"; s8 += \"\\tworld\"; System.out.println(\"s8:\"+s8); } // 可以重写toString,输出实例化的对象时，会输出对应的额内容 public String toString() { return \"111\"; }} ==和equals的用法 **==：作用主要是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象（基本数据类型==比较的是值，引用数据类型==**比较的是内存地址）。 equals()：作用也是判断两个对象是否相等。但它一般有两种使用情况。 情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于使用”==”比较。 情况2：类覆盖了equals()方法。一般，我们覆盖equals()方法来比较两个对象的内容是否相等；若他们的内容相等，则返回true(即认为两个对象相等)。 123456789101112131415161718192021222324/** * ==和equals的区别 * */public class StringTest003 { public static void main(String[] args) { // ==和equal的区别 String s1 = new String(\"abc\"); String s2 = new String(\"abc\"); System.out.println(s1==s2); // false System.out.println(s1.equals(s2)); // true String s3 = \"abc\"; String s4 = \"abc\"; System.out.println(s3==s4); // true System.out.println(s3.equals(s4)); // true String s5 = \"abc\"; String s6 = new String(\"abc\"); System.out.println(s5==s6); // false System.out.println(s5.equals(s6)); // true }} 练习：看程序说结果 12345678910111213141516171819202122232425/** * 看程序写结果 * 字符串变量相加：先开空间，再加内容 * 字符串常量相加：先加，再找，没有开辟空间 * */public class StringTest004 { public static void main(String[] args) { String s1 = \"Hello\"; String s2 = \"World\"; String s3 = \"HelloWorld\"; String s4 = s1 + s2; String s5 = \"Hello\" + \"World\"; System.out.println(s4); System.out.println(s5); System.out.println(s3==s4); // false System.out.println(s3==\"Hello\"+\"World\");// true System.out.println(s3==s5); // true System.out.println(s3.equals(s4)); // true System.out.println(s3.equals(s5)); // true }} String类的判断功能 1234567891011121314151617181920212223242526272829303132/** * String类的判断功能 * boolean equals(Object obj):比较字符串的内容是否相同，严格区分大小写 * boolean equalsIgnoreCase(String str):比较字符串的内容是否相同，不考虑大小写 * boolean contains(String str):判断是否包含指定的小串，区分大小写 * boolean startsWith(Stirng str):判断是否以指定的字符串开头 * boolean endsWith(String str):判断是否以指定的字符串结尾 * boolean isEmpty():判断字符串的内容是否为空 * * */public class StringDemo { public static void main(String[] args) { String s = \"helloworld\"; System.out.println(s.equals(\"helloworld\")); // true System.out.println(s.equals(\"Helloworld\")); // false System.out.println(s.equalsIgnoreCase(\"helloworld\")); // true System.out.println(s.equalsIgnoreCase(\"Helloworld\")); // true System.out.println(s.contains(\"world\")); // true System.out.println(s.contains(\"Hello\")); // false System.out.println(s.startsWith(\"hello\")); // true System.out.println(s.endsWith(\"wrold\")); // false String s1 = \"\"; System.out.println(s1.isEmpty()); // true System.out.println(s1 == \"\"); // true }} 案例练习： 123456789101112131415161718192021222324252627282930313233343536373839/** * 字符串案例练习： * 用户有三次机会输入用户名和密码，系统给提示剩余机会 * */import java.util.Scanner;public class StringTest001 { public static void main(String[] args) { String username = \"admin\"; String password = \"admin\"; System.out.println(\"--------------------------\"); System.out.println(\"欢迎来到蜃楼商城\"); System.out.println(\"您有三次机会输入账号和密码\"); System.out.println(\"机会用完之后需要等账号解锁\"); System.out.println(\"祝您好运！\"); System.out.println(\"--------------------------\"); int i = 3; while(i&gt;0) { Scanner sc = new Scanner(System.in); String sc_username = sc.next(); System.out.println(sc_username); if (sc_username.equals(username)) { String sc_password = sc.next(); if (sc_password.equals(password)) { System.out.println(\"登录成功\"); break; } } i-=1; if (i==0) { System.out.println(\"机会已经用完，请联系管理员\"); }else { System.out.println(\"您还有\"+i+\"次机会\"); } } } } String类的获取功能 1234567891011121314151617181920212223242526272829/** * String类的获取功能： * int length():获取字符串的长度 * char charAt(int index):返回字符串中指定位置的字符 * int indexOf(int ch):返回字符在字符串中第一次出现的位置 * int indexOf(Stirng str):返回指定字符串在字符串中第一次出现的位置 * int indexOf(String str,int fromIndex):返回指定字符串从指定位置开始在字符串中第一次出现的位置 * String substring(int start):返回从指定位置开始到末尾的子串 * String substring(int start,int end):放回从指定位置开始到指定位置结束的子串，注意：前包后不包 * * */public class StringDemo { public static void main(String[] args) { String str1 = \"hello\"; System.out.println(str1.length()); // 5 System.out.println(str1.charAt(1)); // e // System.out.println(str1.charAt(10)); // index of range System.out.println(str1.indexOf('h')); // 0 System.out.println(str1.indexOf(\"h\")); // 0 System.out.println(str1.indexOf('l',3)); // 3 System.out.println(str1.substring(0)); // hello System.out.println(str1.substring(0,3)); // hel }} 练习1：遍历每个小字符串 123456789101112131415/** * 字符串中的遍历： * 遍历每个子字符串 * * */ public class StringTest001 { public static void main(String[] args) { String s1 = \"HelloWorld\"; for(int index=0;index&lt;s1.length();index++) { System.out.println(\"下标为\"+index+\"的是\"+s1.charAt(index)); } } } 练习2：统计字符串个数 1234567891011121314151617181920212223242526272829303132333435/** * 用户从键盘输入一串字符串：分别统计： * 大写字符个数 * 小写字母个数 * 数字个数 * * */ import java.util.Scanner; public class StringTest002 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.next(); int bigCount= 0; int smallCount= 0; int intCount= 0; for(int i=0;i&lt;s.length();i++) { char ch = s.charAt(i); if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') { bigCount+=1; }else if(ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') { smallCount+=1; }else if(ch &gt;= '0' &amp;&amp; ch &lt;= '9') { intCount+=1; } } System.out.println(\"大写字母有:\"+bigCount); System.out.println(\"小写字母有:\"+smallCount); System.out.println(\"数字有:\"+intCount); } } String类的转换功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.bj.study.test006;/** * String的转换功能 * byte[] getBytes():把字符串转换为字节数组 * char[] toCharArray():把字符串转换为字符数组 * static String valueOf(char[] chs):把字符数组转换成字符串 * static String valueOf(int i):把int类型的数据转成字符串 * 把任意类型转换为字符串的方法。 * String toLowerCase():把字符串转小写 * String toUpperCase():把字符串转大写 * String concat(String str):字符串的连接 * * */public class StringDemo { public static void main(String[] args) { String s = \"abcde\"; // byte[] getBytes():把字符串转换为字节数组 byte[] bys = s.getBytes(); for (int x = 0; x &lt; bys.length; x++) { System.out.println(bys[x]); } // char[] toCharArray():把字符串转换为字符数组 char[] chs = s.toCharArray(); System.out.println(chs); for (int x = 0; x &lt; chs.length; x++) { System.out.println(chs[x]); } // static String valueOf(char[] chs):把字符数组转成字符串 String s2 = String.valueOf(chs); System.out.println(\"s2:\" + s2); System.out.println(\"----------------\"); // static String valueOf(int i):把int类型的数据转成字符串 int number = 100; String s3 = number + \"\"; String s4 = String.valueOf(number); System.out.println(\"s3:\" + s3); System.out.println(\"s4:\" + s4); System.out.println(\"----------------\"); // String toLowerCase():把字符串转小写 // String toUpperCase():把字符串转大写 System.out.println(\"toLowerCase():\" + \"HelloWorld11张三\".toLowerCase()); System.out.println(\"toUpperCase():\" + \"HelloWorld11张三\".toUpperCase()); System.out.println(\"----------------\"); // String concat(String str):字符串的连接 String s5 = \"hello\"; String s6 = \"world\"; String s7 = s5.concat(s6); String s8 = s5 + s6; System.out.println(\"s7:\" + s7); System.out.println(\"s8:\" + s8); }} 练习：字符串转换 12345678910111213141516171819/** * 练习：用户从键盘输入一串字符串： * 将首字母转换成大写，其余转换成小写 * * */import java.util.Scanner;public class StringTest001 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.next(); String first = s.substring(0,1).toUpperCase(); String end = s.substring(1).toLowerCase(); String newWords = first+end; System.out.println(newWords); }} String替换、去除空格、比较 12345678910111213141516171819202122232425262728293031323334353637383940/** * 字符串替换 * String replace(char old,char new) * String replace(String old,String new) * * 字符串去除空格： * String trim()：去除两边的空格 * * 按字典顺序比较两个字符串：a-z * int compareTo(String str) * int compareToIgnoreCase(String str) * * */public class StringDemo { public static void main(String[] args) { String s = \"helloworld\"; String s2 = s.replace('l', 'b'); System.out.println(\"s:\" + s); System.out.println(\"s2:\" + s2); String s3 = s.replace(\"owo\", \"ak47\"); String s4 = s.replace(\"j\", \"h\"); System.out.println(\"s3:\" + s3); System.out.println(\"s4:\" + s4); String s5 = \" hello \"; System.out.println(\"s5:\" + s5); System.out.println(\"s5.trim:\" + s5.trim()); String s6 = \"hello\"; System.out.println(s.compareTo(\"hello\")); // 0 System.out.println(s.compareTo(\"Hello\")); // 32 System.out.println(s.compareTo(\"mello\")); // -5 System.out.println(s.compareTo(\"hgllo\"));//第一个不同字母之差 -2 }} 练习1：把数组中的数据按指定格式拼接成字符串 1234567891011121314151617181920212223/** * 练习：把数组中的数据按照指定格式拼接成一个字符串 * 举例：int[] arr = {1,2,3} * 输出：[1,2,3] * * */public class StringDemo2 { public static void main(String[] args) { int[] arr = {1,2,3}; String s = \"[\"; for(int i=0;i&lt;arr.length;i++) { if(i==arr.length-1) { s += arr[i]; }else { s += arr[i]+\",\"; } } s += \"]\"; System.out.println(s); }} 练习2：反转字符串 123456789101112131415161718192021/** * 练习：对用户输入的字符串进行反转 * 例：输入abc * 输出：cba * */import java.util.Scanner;public class StringDemo3 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); String result = \"\"; for (int i=s.length()-1;i&gt;=0;i--) { result += s.charAt(i); } System.out.println(result); }} 练习3：查找长字符串中小字符串的出现次数 12345678910111213141516171819202122232425262728293031323334353637383940/** * 练习4：统计长的字符串中某个小字符串出现的次数 * */public class StringDemo4 { public static void main(String[] args) { String maxString = \"woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun\"; String minString = \"java\"; int count = getCount(maxString, minString); System.out.println(count); System.out.println(\"hello\".indexOf(\"z\",0)); } // 写功能实现： // 形式参数:String maxString,String minString; // 返回值类型:int public static int getCount(String maxString, String minString) { // 定义统计变量 int count = 0; // 先查找一次 int index = maxString.indexOf(minString); // 定义一个变量，用于记录每次最新的查找位置 int startIndex = 0; // 判断位置是不是-1，如果是，就不继续了 while (index != -1) { // 统计变量加1 count++; // 计算最新的查找位置 startIndex = index + minString.length(); // 从最新的查找位置，再查一次小串在大串中出现的位置 index = maxString.indexOf(minString, startIndex); } return count; }} 练习5：比较两个字符串是否相等 12345678910111213141516171819202122232425262728293031323334package com.bj.study.test007;/** * 案例5：自己写一个方法，判断两个字符串是否相等 * * 分析： * A：给出两个字符串 * B:比较长度是否相等，不同返回false * C:把字符串转换成字符数组 * D：比较数组中每一个位置的值 * */public class StringDemo5 { public static void main(String[] args) { String s1 = \"abcdef\"; String s2 = \"abcd\"; boolean result = checkString(s1,s2); System.out.println(result); } private static boolean checkString(String s1, String s2) { if (s1.length() == s2.length()) { for(int i=0;i&lt;s1.length();i++) { if(s1.charAt(i) == s2.charAt(i)) { return true; } } return false; } return false; } } �组 D：比较数组中每一个位置的值 */ public class StringDemo5 { public static void main(String[] args) { String s1 = “abcdef”; String s2 = “abcd”; boolean result = checkString(s1,s2); System.out.println(result); } private static boolean checkString(String s1, String s2) { if (s1.length() == s2.length()) { for(int i=0;i&lt;s1.length();i++) { if(s1.charAt(i) == s2.charAt(i)) { return true; } } return false; } return false; } }","categories":[],"tags":[]},{"title":"StringBuffer和Array","slug":"TreasureBox/Java/2.java面向对象/13.StringBuffer和Array","date":"2022-05-19T01:14:40.368Z","updated":"2023-04-28T09:25:47.210Z","comments":true,"path":"2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/13.stringbuffer-he-array/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/13.stringbuffer-he-array/","excerpt":"","text":"StringBuffer、数组排序，Integer、Character类一、StringBuffer/StringBuilder(掌握) StringBuffer/StringBuilder区别 StringBuffer是线程安全的可变字符串 StringBuilder是县城不安全的可变字符串。 和StringBuffer的功能一样。就是效率高一些，但是不安全。 构造方法 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * StringBuffer：线程安全的可变字符串 * 可以改变内容和长度 * * StringBuffer和String的区别？ * A：StringBuffer的长度可变 * B：String的长度不可变 * * 构造方法： * StringBuffer():构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符 * StringBuffer(int capacity):构造一个不带字符，但具有指定初始容量的字符串缓冲区 * StringBuffer(String str):构造一个字符串缓冲区，并将其内容初始化为自定的字符串长度 * * 成员方法： * public int length():返回长度(字符数)实际值 * public int capacity():返回当前容量理论值 * * */public class StringBufferTest001 { public static void main(String[] args) { // StringBuffer():构造一个不带字符的字符串缓冲区，初始容量为16个字符 StringBuffer strb = new StringBuffer(); System.out.println(\"strb:\"+strb); System.out.println(\"strb.length:\"+strb.length()); // 0 System.out.println(\"strb.capacity:\"+strb.capacity());// 16 // StringBuffer(int capacity):构造一个不带字符，但带有指定初始容量的字符串缓冲区 StringBuffer sb2 = new StringBuffer(20); System.out.println(\"sb2:\"+sb2); System.out.println(\"sb2.length:\"+sb2.length()); // 0 System.out.println(\"sb2.capacity:\"+sb2.capacity()); // 20 // StringBuffer(String str):构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。 StringBuffer sb3 = new StringBuffer(\"helloworld\"); System.out.println(\"sb3:\" + sb3); System.out.println(\"sb3.length():\" + sb3.length()); System.out.println(\"sb3.capacity():\" + sb3.capacity()); } } 成员方法 添加 12345678910111213141516171819202122232425262728293031/** * 添加功能： * public StringBuffer append(String str):追加数据，往已有的数据后面添加 * public StringBuffer insert(int offset,String str):往指定位置添加数据 * (超出下标报错) * */public class StringBufferTest002 { public static void main(String[] args) { // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); StringBuffer sb2 = sb.append(\"s\"); System.out.println(sb2); // s System.out.println(sb2==sb); // true System.out.println(\"sb2:\"+sb2); // s System.out.println(\"sb:\"+sb); // s sb.append(\"hello\"); sb.append(\"world\"); System.out.println(sb2==sb); // true System.out.println(sb2); // shelloworld // 链式编程 sb.append(\"hello\").append(\"world\").append(\"java\"); System.out.println(sb2==sb); // true StringBuffer st2 = new StringBuffer(); st2.insert(0, \"baLeiTe\"); // 超出内容最大下标会报错 System.out.println(st2); }} 删除 1234567891011121314151617181920212223/** * 删除功能： * public StringBuffer deleteCharAt(int index):删除指定位置的字符 * public StringBuffer delete(int start,int end):删除start到end的数据，前包后不包 * 超出下标报错 * */public class StringBufferTest003 { public static void main(String[] args) { StringBuffer sb = new StringBuffer(); sb.append(\"hello\").append(\"world\"); System.out.println(sb); StringBuffer s = sb.deleteCharAt(0); // 超出下标会报错 System.out.println(sb); // elloworld System.out.println(s); // elloworld sb.delete(0, 1); // 超出下标报错 System.out.println(sb); // lloworld }} 替换 1234567891011121314/** * 字符串替换 * public StringBuffer replace(int start,int end,String str) * 用给定的字符串替换从指定位置开始到指定位置结束的数据 * 超出下标会报错 * */public class StringBufferTest004 { public static void main(String[] args) { StringBuffer buffer = new StringBuffer(\"HelloWorld\"); buffer.replace(0, 1, \"hello\"); System.out.println(buffer); // helloelloWorld }} 反转 1234567891011/** * 字符串反转 * public StringBuffer reverse() * */public class StringBufferTest005 { public static void main(String[] args) { StringBuffer buffer = new StringBuffer(\"helloworld\"); buffer.reverse(); System.out.println(buffer); // dlrowolleh }} 截取 12345678910111213141516171819202122package com.bj.study.StringBuffer;/** * 截取功能：返回值是String类型，本身没有发生改变 * public String substring(int start) * 从指定位置开始到末尾，超出字符串长度会报错 * * public String substring(int start,int end) * 从指定位置开始到指定位置结束 * * */public class StringBufferTest006 { public static void main(String[] args) { StringBuffer buffer = new StringBuffer(\"helloworld\"); String s = buffer.substring(0); System.out.println(s); // helloworld String s1 = buffer.substring(0,1); System.out.println(s1); // h }} 练习 StringBuffer和String相互转换 1234567891011121314/** * StringBuffer 和 String转换 * */public class StringBufferTest007 { public static void main(String[] args) { StringBuffer buffer = new StringBuffer(\"hello\"); String s = new String(buffer); String s1 = new String(\"hello\"); StringBuffer sb = new StringBuffer(s1); }} 数组转换成字符串 123456789101112131415161718192021222324252627/** * 练习：把数组拼接成字符串 * */public class StringBufferTest008 { public static void main(String[] args) { int[] arr = {11,22,33,44,55}; String result = arrayToString(arr); System.out.println(result); } private static String arrayToString(int[] arr) { StringBuffer sb = new StringBuffer(); sb.append(\"[\"); for (int i=0;i&lt;arr.length;i++) { if(i==arr.length) { sb.append(arr[i]); }else { sb.append(arr[i]+\",\"); } } sb.append(\"]\"); return new String(sb); }} 判断字符串是不是回文字符串 123456789101112131415161718/** * 判断字符串是不是回文字符串： * 如：aba，anmbmna * */public class StringBufferTest009 { public static void main(String[] args) { String s = \"anmbmn\"; StringBuffer buffer = new StringBuffer(s); buffer.reverse(); String s1 = new String(buffer); if(s.equals(s1)) { System.out.println(true); }else { System.out.println(false); } }} 看程序写结果 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.bj.study.StringBuffer;/** * 1、String和StringBuffer和StringBuilder的区别 * A:String是固定长度，StringBuffer和StringBuilder长度可变 * B:StringBuffer线程安全，效率低。StringBuilder线程不安全，效率高 * * 2、StringBuffer和数组的区别 * A:StringBuffer的长度可变，可以存储任意数据类型，最终结果都是一个字符串 * B:数组长度固定，存储同一种数据类型的元素 * * 3、看程序写结果 * String作为参数传递和StringBuffer作为参数传递的区别 * * String是一种引用数据类型，在作为参数传递时，可以当做基本类型来看。因为传递的是常量值 * * */public class StringBufferTest010 { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"world\"; System.out.println(s1 + \"---\" + s2); // hello---world change(s1, s2); System.out.println(s1 + \"---\" + s2);// hello---world StringBuffer sb1 = new StringBuffer(\"hello\"); StringBuffer sb2 = new StringBuffer(\"world\"); System.out.println(sb1 + \"---\" + sb2);// hello---world change(sb1, sb2); System.out.println(sb1 + \"---\" + sb2);// hellossss---worldoooo } private static void change(StringBuffer sb1, StringBuffer sb2) { sb1.append(\"ssss\"); sb2.append(\"oooo\"); } private static void change(String s1, String s2) { s1 += \"ssss\"; s2 += \"oooo\"; }} 二、数组排序 冒泡排序 1234567891011121314151617181920212223242526272829303132/** * 冒泡排序 * 外层循环控制比较次数，每次比较相邻的两个元素，第一次排序完之后最大的值一定在最后 * */public class ArrayBubbleSort { public static void main(String[] args) { int[] arr = {13, 69, 80, 81, 101 }; for(int i=1;i&lt;arr.length;i++) { // 设置标志位，如果某一次没有任何数据交换，说明数据有序 boolean flag = true; for(int j=0;j&lt;arr.length-i;j++) { if (arr[j]&gt;arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = false; } } // 测试：当数组本身有序时，一次排序就结束程序 System.out.println(111111); if(flag) { break; } } for(int i=0;i&lt;arr.length;i++) { System.out.println(arr[i]); } }} 选择排序 123456789101112131415161718192021222324252627282930313233/** * 选择排序： * 每一次先定义一个初识的最小值下标 * 然后在剩余部分选出未排序数组中最小的值，如果最小值的下标与初识定义的不同，就交换位置 * 第一次排完序之后最小的一定在最前边 * * */public class ArraySelectSort { public static void main(String[] args) { int[] arr = {24,13,30,69,80,3}; for(int i=0;i&lt;arr.length-1;i++) { int index = i; for (int j =i+1;j&lt;arr.length;j++) { if(arr[j]&lt;arr[index]) { index = j; } } // 最小值下标与最开始定义的不同 if(index!=i) { int temp = arr[index]; arr[index] = arr[i]; arr[i] = temp; } } for (int k=0;k&lt;arr.length;k++) { System.out.println(arr[k]); } }} 插入排序 12345678910111213141516171819202122232425262728package com.bj.study.Array;/** * 使用插入排序： * 每次从未排序的数组中拿出第一个元素跟已排序的列表的最后一个比较 * 如果位置错误就交换位置。 * */public class InsertSort { public static void main(String[] args) { int[] arr = {24,13,30,69,80,3};; for(int i=1;i&lt;arr.length;i++) { for(int j=i;j&gt;0;j--) { if(arr[j]&lt;arr[j-1]) { int s = arr[j]; arr[j] = arr[j-1]; arr[j-1] = s; }else { break; } } } for(int i=0;i&lt;arr.length;i++) { System.out.printn(arr[i]); } }} 顺序查找 12345678910111213141516171819202122232425262728package com.bj.study.Array;/** * 基本查找：数组无序，按循序进行查找 * 折半查找：数组有序，每次比较数组中间值 * * */public class ArrayFindTest001 { public static void main(String[] args) { /**数组无序，顺序查找*/ int[] arr1 = {8,10,20,11,23,40}; int number1 = 8; boolean flag = false; for(int i=0;i&lt;arr1.length;i++) { if(number1==arr1[i]) { flag = true; System.out.println(flag); break; } } if(!flag) { System.out.println(flag); } }} 折半查找 1234567891011121314151617181920212223242526package com.bj.study.Array;/** * 折半查找:数组有序 * */public class ArrayFindTest002 { public static void main(String[] args) { int[] arr = {1,2,3,4,5,6,7,8,9,10,11,12,13,14}; int number = 4; int start = 0; int end = arr.length-1; while(start&lt;=end) { if(number == arr[(start+end)/2]) { System.out.println((start+end)/2); break; }else if(number &lt; arr[(start+end)/2]) { end = (start+end)/2 - 1; }else { start = (start+end)/2 + 1; } } }} 数组自带排序和查找 12345678910111213141516171819202122232425262728293031package com.bj.study.Array;/** * Arrays：针对数组进行操作的工具类。提供了排序，查找等功能 * * 成员方法： * public static String toString(int[] a):数组转换成字符串 * public static void sort(int[] a):排序(快速排序) * public static void binarySearch(int[] a,int key):二分查找 * * 注意： * 如果数组本身是无序的，不能直接使用二分查找 * */import java.util.Arrays;public class ArrayTest { public static void main(String[] args) { int[] arr = {20, 30, 10, 29, 89}; System.out.println(arr); String s = Arrays.toString(arr); System.out.println(s); System.out.println(s.length()); // 20 Arrays.sort(arr); System.out.println(Arrays.toString(arr)); System.out.println(Arrays.binarySearch(arr,10)); }} 三、Integer类 进制转换 123456789101112131415161718192021222324252627282930313233package com.bj.study.Integer;/** * 需求1：我给出了一个数据，我要判断这个数据是不是在int范围呢?肿么办呢? * 需求2：我给出一个数据100，我要得到它的二进制，八进制，十六进制? 三进制，五进制，七进制??? * 那么，有没有比较简单的方式让我们来实现这样的需求呢?有。 * 而基本类型是做不到的，因为基本类型没有功能可以使用。所以，这种的操作最好是能有功能实现。 * 然后我们调用功能即可。 * 为了简化我们针对基本类型数据的更复杂的操作，java就针对每种基本类型提供了一个包装类类型，基本类型包装类。 * byte Byte * short Short * int Integer * long Long * float Float * double Double * char Character * boolean Boolean * */public class IntegerTest001 { public static void main(String[] args) { // public static final int MAX_VALUE // public static final int MIN_VALUE // if(数据&gt;=Integer.MIN_VALUE &amp;&amp; 数据&lt;=Integer.MAX_VALUE){} // public static String toBinaryString(int i) System.out.println(Integer.toBinaryString(100)); // public static String toOctalString(int i) System.out.println(Integer.toOctalString(100)); // public static String toHexString(int i) System.out.println(Integer.toHexString(100)); }} 构造方法 1234567891011121314151617181920212223package com.bj.study.Integer;/** * Integer的构造方法： * Integer(int value)： 把int类型的值包装成Integer类型 * Integer(String s): 把数字类型的字符串转换成Integer类型 */public class IntegerTest002 { public static void main(String[] args) { // 方式1 int number = 100; Integer i = new Integer(number); System.out.println(\"i:\" + i); // 100 // 方式2 String s = \"100\"; // String s = \"abc\"; // NumberFormatException:因为你给定的数据不是数字形式的字符串数据 Integer i2 = new Integer(s); System.out.println(\"i2:\" + i2); // 100 }} int和String类型转换 123456789101112131415161718192021222324252627282930313233343536373839package com.bj.study.Integer;/** * int和String类型的相互转换。 * * int -- String * String.valueOf(number) * Integer.toString(number) * * String -- int * Integer.parseInt(s); */public class IntegerTest003 { public static void main(String[] args) { // int -- String int number = 100; // 方法1 String s1 = number + \"\"; //方式2 String s2 = String.valueOf(number); //方式3 //int -- Integer -- String Integer i = new Integer(number); String s3 = i.toString(); //方式4 String s4 = Integer.toString(number); System.out.println(\"--------------\"); String s = \"100\"; //方式1 //String -- Integer -- int Integer ii = new Integer(s); //public int intValue() int num = ii.intValue(); //方式2 //public static int parseInt(String s) int num2 = Integer.parseInt(s); }} 进制转换 12345678910111213141516171819202122232425262728293031323334353637383940package com.bj.study.Integer;/** * 常用的基本进制转换 * public static String toBinaryString(int i) * public static String toOctalString(int i) * public static String toHexString(int i) * 十进制到其他进制 * public static String toString(int i,int radix) * 其他进制到十进制 * public static int parseInt(String s,int radix) * */public class IntegerTest004 { public static void main(String[] args) { // public static String toString(int i,int radix): // 进制的范围是2-36 System.out.println(Integer.toString(100, 2)); // 1100100 System.out.println(Integer.toString(100, 8)); // 144 System.out.println(Integer.toString(100, 16)); // 64 System.out.println(Integer.toString(100, 1)); // 100 System.out.println(Integer.toString(100, 100)); // 100 System.out.println(Integer.toString(100, 50)); // 100 System.out.println(Integer.toString(100, 25)); // 40 System.out.println(Integer.toString(100, 37)); // 100 System.out.println(Integer.toString(100, 32)); // 34 System.out.println(Integer.toString(100, 35)); // 2u System.out.println(Integer.toString(100, 36)); // 2s System.out.println(Integer.toString(100, 7)); // 202 System.out.println(\"----------------------\"); // 其他进制到十进制 // public static int parseInt(String s,int radix) System.out.println(Integer.parseInt(\"100\", 2)); // 4 System.out.println(Integer.parseInt(\"100\", 8)); // 64 System.out.println(Integer.parseInt(\"100\", 16));// 256 System.out.println(Integer.parseInt(\"300\", 12));// 432 }} 底层原理 12345678910111213141516171819202122232425262728package com.bj.study.Integer;/** * JDK5新特性： * 自动装箱：int -- integer * 底层方法：public static Integer valueOf(int i) * 自动拆箱：Integer -- int * 底层方法：public int intValue() * * 注意：对象不能为null * 开发原则： * 只要是对象做操作，肯定先判断对象是否为null，如果不为null，才能继续操作 * * */public class IntegerTest005 { public static void main(String[] args) { // Integer i = new Integer(100); Integer i = 100; // 自动装箱 // Integer i = Integer.valueOf(100); i += 200; // i = i + 200 // i = Integer.valueOf(i.intValue() + 200); System.out.println(i); }} 练习:看程序说结果 1234567891011121314151617181920212223242526272829303132333435package com.bj.study.Integer;/** * 看程序写结果 * */public class IntegerTest006 { public static void main(String[] args) { Integer i1 = new Integer(127); Integer i2 = new Integer(127); System.out.println(i1 == i2);// false System.out.println(i1.equals(i2));// true Integer i3 = new Integer(128); Integer i4 = new Integer(128); System.out.println(i3 == i4);// false System.out.println(i3.equals(i4));// true Integer i5 = 127; Integer i6 = 127; System.out.println(i5 == i6);// true System.out.println(i5.equals(i6));// true Integer i7 = 128; Integer i8 = 128; System.out.println(i7 == i8);// false System.out.println(i7.equals(i8));// true // 要想知道为什么，就必须看源码。 // public static Integer valueOf(int i) //char ch = 127; //Integer i = Integer.valueOf(ch); // 通过查看源码我们知道如果数据在-128到127之间，是从一个缓存数组中返回的。 // 如果不在这个范围内，就是重新创建的new出来的对象。 }} 四、Character类 构造方法和类型转换 1234567891011121314151617181920212223242526272829303132333435363738394041package com.bj.study.Character;/** * Character 类在对象中包装一个基本类型char的值； * 此外，该类还提供了几种方法： * 确定字符的类别（小写字母，数字等等），并将字符从大写转换成小写 * */public class CharacterDemo { public static void main(String[] args) { // 构造方法 Character ch = new Character('a'); System.out.println(ch); /** 字符转换*/ // public static boolean isUpperCase(char ch) System.out.println(Character.isUpperCase('a')); // false System.out.println(Character.isUpperCase('A')); // true System.out.println(Character.isUpperCase('0')); // false // public static boolean isLowerCase(char ch) System.out.println(Character.isLowerCase('a')); // true System.out.println(Character.isLowerCase('A')); // false System.out.println(Character.isLowerCase('0')); // false // public static boolean isDigit(char ch) System.out.println(Character.isDigit('a')); // false System.out.println(Character.isDigit('A')); // false System.out.println(Character.isDigit('0')); // true // public static char toUpperCase(char ch) System.out.println(Character.toUpperCase('a')); // A System.out.println(Character.toUpperCase('A')); // A // public static char toLowerCase(char ch) System.out.println(Character.toLowerCase('a')); // a System.out.println(Character.toLowerCase('A')); // a }} ntln(Character.isLowerCase(‘A’)); // false System.out.println(Character.isLowerCase(‘0’)); // false // public static boolean isDigit(char ch) System.out.println(Character.isDigit(‘a’)); // false System.out.println(Character.isDigit(‘A’)); // false System.out.println(Character.isDigit(‘0’)); // true // public static char toUpperCase(char ch) System.out.println(Character.toUpperCase(‘a’)); // A System.out.println(Character.toUpperCase(‘A’)); // A // public static char toLowerCase(char ch) System.out.println(Character.toLowerCase(‘a’)); // a System.out.println(Character.toLowerCase(‘A’)); // a } }","categories":[],"tags":[]},{"title":"Java中的方法","slug":"TreasureBox/Java/1.java基础/6.Java中的方法","date":"2022-05-19T01:14:40.367Z","updated":"2023-04-28T09:25:47.212Z","comments":true,"path":"2022/05/19/treasurebox/java/1.java-ji-chu/6.java-zhong-de-fang-fa/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/1.java-ji-chu/6.java-zhong-de-fang-fa/","excerpt":"","text":"Java中的方法一、方法的介绍方法，把某些需要重复使用的代码段放在一块，可供重复调用。 方法的好处：代码得到了重复使用 方法本质： 方法就是一段代码片段，并且这段代码片段： 可以完成某个特定的功能，可以被重复的使用 方法，对应英语单词：Method方法在C语言中叫做函数/Function 方法定义在类体之中，在一个类当中可以定义多个方法，方法编写的位置没有先后顺序，可以随意 方法体当中不能再定义方法！！！！ 方法体由java语句构成，方法体中的代码遵循自上而下执行 1234567891011121314151617181920public class MethodTest02{ public static void main(String[] args){ //调用函数，计算两个int类型数据的和 MethodTest02.sumInt(10,20); MethodTest02.sumInt(666,888); MethodTest02.sumInt(1000,2022); } // 单独定义一个方法 // 该方法完成计算两个int类型数据的和，并且将结果输出 public static void sumInt(int a,int b){ int c = a+b; System.out.println(a+\"+\"+b+\"=\"+c); }} 二、方法的描述123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/* 关于java语言中的方法： 1、方法怎么定义，语法结构： [修饰符列表] 返回值类型 方法名(形式参数列表){ 方法体; } 2、对以上的语法结构进行解释 2.1、关于修饰符列表 * 可选项，不是必须的 * 目前统一写成：public static * 方法的修饰符列表中有static关键字的话，调用时： 类名.方法名(实际参数列表); 2.2、返回值类型 * 什么是返回值？ 一个方法是可以完成某个特定功能的，这个功能结束之后大多数都是需要返回 最终执行结果的，执行结果可能是一个具体存在的数据。而这个具体存在的数据就是返回值 * 返回值类型？ 返回值是一个具体存在的数据，数据都是有类型的，此时需要指定的是返回值的具体类型 * 返回值类型都可以指定哪些类型呢？ java任意一种类型都可以，包括基本数据类型和引用数据类型 *也可能这个方法执行结束之后不返回任何数据，java中规定，当一个方法执行结束之后不返回任何数据的话，返回值类型位置必须编写：void关键字 * 返回值类型： byte、short、int、long、float、double、char、boolean * 返回值类型若不是void，表示这个方法执行结束之后必须返回一个具体的数据 当方法执行结束没有返回任何数据的话，编译器报错。 return \"值\";并且要求“值”的数据类型必须和方法的返回值类型一致。 * 返回值类型是void的时候，在方法体内不能编写“return 值;”这样的语句 可以编写“return;”这样的语句 * 只要带有return关键字的语句执行，return语句所在的方法结束，强行终止当前方法 2.3、方法名： * 只要是合法的标识符就行 * 方法名最好见名知意 * 方法名最好是动词 * 方法名首字母小写，后面每个单词首字母大写 2.4、形式参数列表：简称形参 * 形参是局部变量：int a;double b;String s; * 形参的个数可以是0~N个 * 多个形参之间用\"逗号\"隔开 * 形参中起决定作用的是形参的数据类型，形参的名字就是局部变量的名字 * 方法调用时，实际给方法传递的真是数据，被称为：实际参数，简称实参 * 实参列表和形参列表必须满足数量相同，类型对应想同 例如： 方法定义 public static int sum(int a,int b){ } 方法调用 sum(\"abc\",\"a\");编译器报错 2.5、方法体必须由大括号括起来，自上而下执行， 由java语句构成，每一个java语句以\";\"结尾。 3、方法怎么调用？ 方法只有在调用的时候才会执行 语法规则：&lt;方法的修饰符列表当中有static&gt; 类名.方法名(实参列表);*//*public 表示公开的class表示定义类MethodTest03是一个类名*/public class MethodTest03{ // 类体 // 类体中不能直接编写java语句，除声明变量之外 // 方法出现在类体当中 // 方法 // public表示公开的 // static表示静态的 // void表示方法执行不返回任何数据 // main是方法名：主方法 // (String[] args)：形式参数列表，其中String[]是一种固定的写法 // 所以以下只有args这个局部变量名是随意的 // 主方法固定写法 public static void main(String[] args){ //调用sum方法 MethodTest03.sum(10,20); } // 自定义方法，不是程序的入口 // 方法作用：计算两个int类型数据的和，不要求返回结果 // 修饰符列表：public static // 返回值类型：void // 方法名：sum // 形参列表：(int a,intb) // 方法体 public static void sum(int a,int b){ int c = a+b; System.out.println(c); } // 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值) public void f1() { System.out.println(\"无参数无返回值的方法\"); } /** * 有参数无返回值的方法 * 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开 */ public void f2(int a, String b, int c) { System.out.println(a + \"--&gt;\" + b + \"--&gt;\" + c); } // 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型） public int f3() { System.out.println(\"有返回值无参数的方法\"); return 2; } // 有返回值有参数的方法 public int f4(int a, int b) { return a * b; } // return在无返回值方法的特殊使用 public void f5(int a) { if (a&gt;10) { return;//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行 } System.out.println(a); }} 三、方法的调用顺序方法的调用不分顺序，只要在同一个类体中都可以调用，其中main方法是程序的进口，从main方法开始执行。 123456789101112131415161718192021222324252627/* 方法的调用不一定在main方法中，只要是程序可以执行到的位置， 都可以调用其他方法*/public class MethodTest04{ public static void sum(int a,int b){ int c = a+b; System.out.println(c); //调用dosome方法 MethodTest04.dosome(); } public static void main(String[] args){ //调用some方法 MethodTest04.sum(10,20); } public static void dosome(){ System.out.println(\"Hello World!\"); }} 四、方法的传参123456789101112131415161718public class MethodTest05{ public static void main(String[] args){ // 传参错误 // MethodTest05.sum(); // 正确 MethodTest05.sum(10,20); // 转换数据类型 MethodTest05.sum((long)3.0,20); } public static void sum(long a,long b){ System.out.println(a+b); }} 为什么java中只有值传递？ 首先了解程序语言设计中有关将参数传递给方法（或函数）的专业术语： 按值调用（call by value）：表示方法接受的是调用者提供的值 引用调用（call by reference）：表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 Java程序语言设计总是采用按值调用。也就是说：方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 123456789101112131415161718public static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\"num1 = \" + num1);// num1=10 System.out.println(\"num2 = \" + num2);// num2=20}public static void swap(int a, int b) { int temp = a; a = b; b = temp; System.out.println(\"a = \" + a); // a=20 System.out.println(\"b = \" + b); // b=10} 1234567891011public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]);//1 change(arr); System.out.println(arr[0]); //0}public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0;} 12345678910111213141516171819public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Student s1 = new Student(\"小张\"); Student s2 = new Student(\"小李\"); Test.swap(s1, s2); System.out.println(\"s1:\" + s1.getName()); // 小张 System.out.println(\"s2:\" + s2.getName()); // 小李 } public static void swap(Student x, Student y) { Student temp = x; x = y; y = temp; System.out.println(\"x:\" + x.getName()); // 小李 System.out.println(\"y:\" + y.getName()); // 小张 }} 下面再总结一下 Java 中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 五、方法的调用规则1234567891011121314151617181920212223242526272829303132333435363738394041/* 方法调用： 1、方法的修饰符列表当中有static关键字，完整的调用方式是：类名.方法名(实参列表); 2、但是，有的时候“类名.”可以省略 * 在当前类中调用时，类名可以不写 * 在其他类中调用时必须要写 3、建议一个java源文件只定义一个class*/public class MethodTest06{ public static void main(String[] args){ //调用 m(); } public static void m(){ System.out.println(\"m method execute!\"); m2(); A.m2(); } public static void m2(){ System.out.println(\"m2 method execute!\"); }}class A { public static void main(String[] args){ // 调用其他类中的方法 MethodTest06.m(); } public static void m2(){ System.out.println(\"A's method execute!\"); } } 六、方法的内存分配方法调用时候，分配的内存空间在栈内存中，进行压栈操作，当栈中的内存过多时，会报栈溢出错误。 12345678910111213141516171819202122232425262728293031323334353637383940/* 分析以下程序的输出结果*/public class MethodTest07{ /* main begin m1 begin m2 begin m3 begin m3 over m2 over m1 over main over 当前main方法结束之后整个程序才结束 */ public static void main(String[] args){ System.out.println(\"main begin\"); m1(); System.out.println(\"main over\"); } public static void m1(){ System.out.println(\"m1 begin\"); m2(); System.out.println(\"m1 over\"); } public static void m2(){ System.out.println(\"m2 begin\"); m3(); System.out.println(\"m2 over\"); } public static void m3(){ System.out.println(\"m3 begin\"); System.out.println(\"m3 over\"); }} m1(); System.out.println(“main over”); } public static void m1(){ System.out.println(\"m1 begin\"); m2(); System.out.println(\"m1 over\"); } public static void m2(){ System.out.println(\"m2 begin\"); m3(); System.out.println(\"m2 over\"); } public static void m3(){ System.out.println(\"m3 begin\"); System.out.println(\"m3 over\"); } }","categories":[],"tags":[]},{"title":"this、static、final和访问控制修饰符","slug":"TreasureBox/Java/2.java面向对象/10.this、static、final和访问控制修饰符","date":"2022-05-19T01:14:40.367Z","updated":"2023-04-28T09:25:47.209Z","comments":true,"path":"2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/10.this-static-final-he-fang-wen-kong-zhi-xiu-shi-fu/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/2.java-mian-xiang-dui-xiang/10.this-static-final-he-fang-wen-kong-zhi-xiu-shi-fu/","excerpt":"","text":"this、static、final和修饰符一、this的使用（1）this使用概述123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 关于java语言中的this关键字： * 1、this 是一个关键字，翻译为：这个 * 2、是一个引用，保存在堆内存中对象的内部，指的是对象自身 * 3、创建100个java对象，每一个对象都有一个this，也就是有100个不同的this * 4、this可以出现在实例方法中，this指向当前正在执行这个动作的对象 * 5、this多数情况下可以不写 * 6、this不能使用在带有static的方法中 * **/public class Customer { String name; // 实例变量 public Customer() { } public static void main(String[] args) { } // 不带有static关键字的方法 // 比如顾客的购物行为 // 每一个顾客购物的结果不同 // 所以购物行为属于对象级别的行为 // 由于每一个对象在执行购物这个动作的最终结果不同，所以购物这个动作必须有对象参与 // 重点：没有static关键字的方法被称为实例方法 // 重点：没有static关键字的变量称为实例变量 // 注意：当一个行为/动作执行的过程当中是需要对象参与的，name这个方法一定要定义为实例方法，不要带static // 以下方法定义为实例方法，因为每个顾客在真正购物时候，最终的结果都是不同的 public void shopping() { // 由于name是一个实例变量，所以这个name访问的时候一定访问的是当前对象的实例变量 // System.out.println(name+\"在购物\"); System.out.println(this.name+\"在购物\"); } // static方法不需要对象，直接使用类名调用，所以执行过程中没有对象 public static void doSome() { // 执行过程中没有当前对象，因为带有static的方法是通过类名.方法名访问的 // 或者说这个上下文中没有当前对象，自然也不存在this // doSome方法调用不是对象去调用，是一个类名去调用 // name是一个实例变量，以下代码没有实例，所以会编译报错 // System.out.println(name); } public static void doOther() { // 想访问时，需要先创建对象 Customer c = new Customer(); // 这里访问的name不再是当前调用的实例的name，而是c实例的name System.out.println(c.name); } } this内存图分配： （2）this在哪里使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * this可以使用在哪里？ * 1、可以使用在实例方法当中，代表当前对象 * 2、可以使用在构造方法中，通过当前的构造方法调用其他的构造方法 *重点【记忆】：this()只能放在有效代码的第一行 * */public class Date { private int year; private int month; private int day; // 无参构造器 /* 需求：当调用时，默认日期为1970,1,1 * */ public Date() { /* this.year = 1970; this.month = 1; this.day = 1; */ // 函数可以通过调用下边的构造方法 // 前提是不能创建新的对象,以下代码代表创建新的对象 // new Date(1960,1,1); // 需要采用这种方法进行调用，调用构造方法的另一种方式 this(1970,1,1); } // 有参构造器 public Date(int year, int month, int day) { this.year = year; this.month = month; this.day = day; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getMonth() { return month; } public void setMonth(int month) { this.month = month; } public int getDay() { return day; } public void setDay(int day) { this.day = day; } public void print() { System.out.println(this.year+\"年\"+this.month+\"月\"+this.day+\"日\"); } } （3）案例练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test { public static void main(String[] args) { // 完整方法和省略方法分别调用method1和method2 Test.method1(); method1(); Test t = new Test(); t.method2(); t.method1(); } public static void method1() { System.out.println(\"method1 调用\"); // 完整方法调用 Test.doSome(); // 省略方法调用 doSome(); // 完整方法调用 Test t = new Test(); t.doOther(); // 完整访问i System.out.println(\"完整的i：\"+t.i); } public void method2() { System.out.println(\"method2 调用\"); Test.doSome(); doSome(); this.doOther(); doOther(); System.out.println(\"完整的i:\"+this.i+\"缩写的：\"+i); } int i; public static void doSome() { System.out.println(\"do some!\"); } public void doOther() { System.out.println(\"do Other!\"); }} 二、static的使用（1）static用法概述带有static时候表示静态的，不管是方法还是变量都上升为类级别的，跟具体的对象无关。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * 什么时候成员变量声明为实例变量呢？ * 所有对象都有这个属性，但是这个属性随着对象的变化而变化 * * 什么时候成员变量声明为静态变量呢？ * 所有对象都有这个属性，但是这个属性不随着对象的变化而变化 * * 静态变量在类加载的时候，存储在方法区内存中 * * 所有静态的数据，都可以用“类名.”或“引用.”的方式访问 * 采用“引用.”访问时，及时引用为null，也不会出现空指针异常 * * * 关于java的static关键字： * 1、static的英语为静态的 * 2、static修饰的方法是静态方法，访问使用\"类名.\"方法名的方式访问 * 3、static修饰的变量是静态变量 * 4、所有static修饰的都为静态的，都可以使用“类名.”的方式调用 * 5、static修饰的元素都是类级别的特征，跟具体的对象无关。 * */public class Chinese { // 身份证号【每一个对象身份证号不同】 int id; // 姓名【每一个对象姓名不同】 String name; // 国籍【每一个对象由于都是chinese实例化的，所以每一个中国人的国籍都是中国】 // 无论通过Chinese类实例化多少对象，这些对象国籍都是“中国” // 带static代表静态变量，内存在方法区内存中 static String Country = \"中国\"; public Chinese(int id, String name) { this.id = id; this.name = name; } public static void doSome() { System.out.println(\"Chinese doSome\"); }} 12345public class Chinese2 { public static void doSome() { System.out.println(\"Chinese2 doSome\"); }} 1234567891011121314151617public class ChinestTest { public static void main(String[] args) { Chinese zhangsan = new Chinese(1,\"zhangsan\"); System.out.println(\"身份证号：\"+zhangsan.id+\"，姓名：\"+zhangsan.name+\"，国籍：\"+Chinese.Country); Chinese lisi = new Chinese(2,\"lisi\"); System.out.println(\"身份证号：\"+lisi.id+\"，姓名：\"+lisi.name+\"，国籍：\"+Chinese.Country); Chinese2 wangwu = new Chinese2(); wangwu = null; wangwu.doSome(); }} （2）方法什么时候定义为静态的？12345678910111213141516171819202122232425262728293031/* * 方法什么时候定义为静态的？ * 方法描述的是动作，当所有对象执行这个动作的时候，最终产生的影响是一样的， * 那么这个动作已经不再属于一个对象动作了，可以将这个动作提升为类级别的动作，模板级别的动作。 * * * 静态方法无法直接访问实例变量和实例方法 * * 大多数方法都定义为实例方法，一般一个行为或者一个动作在发生的时候，都需要对象的参与 * 但是也有例外，例如：大多数“工具类”中的方法都是静态的，因为工具类中的方法不需要实例，直接用“类名 *.”的方式调用 * * */public class StaticTest { // 实例变量 int i =10; // 实例方法 public void doSome() { } public static void main(String[] args) { System.out.println(MathUtil.sumInt(10, 20)); } } 工具类示例： 12345678public class MathUtil { public static int sumInt(int a, int b) { // TODO Auto-generated method stub return a+b; }} （3）静态代码快和实例代码块 静态代码块 123456789101112131415161718192021222324252627282930/* * 可以使用static关键字定义\"静态代码块\" * 1、语法格式 * static{ * java语句 * } * * 2、静态代码快在类加载的时候执行，并且只执行一次 * * 3、静态代码块在一个类中可以编写多个，并且遵循自上而下的顺序依次执行 * * 4、静态代码块的作用： * - 和具体的需求有关，例如项目中在类加载的时刻，或者时机执行代码完成日志的记录。 * - 那么这段记录日志的代码可以放在静态代码块中，完成日志记录 * — 静态代码块是java为程序员准备的一个特殊的时刻，这个特殊的时刻被称为：类加载时刻 * */public class StaticTest01 { static { System.out.println(\"static1\"); } static { System.out.println(\"static2\"); } public static void main(String[] args) { }} 实例代码块 12345678910111213141516171819202122232425/* * 实例代码块 * 1、实例代码块也可以编写多个，也是遵循自上而下的顺序执行 * 2、实例代码块在构造方法执行之前执行，构造方法执行一次，实例代码执行一次 * 3、实例代码块也是java语言为程序员准备的一个特殊时刻，这个特殊时刻被称为：对象初始化时机。 * * */ public class Test { public Test(){ System.out.println(\"Test类构造函数\"); } { System.out.println(\"1\"); } { System.out.println(\"2\"); } public static void main(String[] args) { System.out.println(\"main begin\"); Test t = new Test(); Test t1 = new Test(); }} 三、final关键字123456789101112131415161718192021222324252627282930313233/** * 关于java语言中的final关键字 * 1、final是一个关键字，表示最终的，不可变的 * 2、final修饰的类无法被继承 * 3、final修饰的方法无法被覆盖 * 4、final修饰的变量一旦赋值之后不可重新赋值 * 5、final修饰的实例变量：必须手动赋值，不能使用系统的默认值 * final int age = 20; * * 6、final修饰的引用： * final User user = new User(30);user=null; // 报错 * 一旦指向某个对象之后，不能再指向其他对象，那么被指向的对象无法被垃圾回收机制回收 * final User user = new User(30);user.id = 50; // 正确 * 虽然指向某个对象之后不能指向其他对象，但是所指向的对象内部的内存是可以修改的 * 7、final修饰的实例变量一般都要和static连用，被称为常量： * 常量定义的语法格式是：public static final 类型 常量名 = 值; * Java语法规范要求所有的常量的名字全部大写，每个单词之间使用下划线链接 * 常量示例：public static final String GUO_JI = \"中国\"; * * */public class FinalTest01 { public static void main(String[] args) { final int i = 10;// i = 20; // 编译报错，无法为final修饰的变量赋值 System.out.println(i); final int m; m = 20; // 编译通过，不能二次赋值 System.out.println(m); }} 四、访问控制修饰符123456789101112131415161718192021222324package com.bjpower.javase.test005;/** * 访问控制修饰符 * 1、访问控制修饰符来控制元素的访问范围 * 2、访问控制修饰符包括： * public 公开的，在任何位置都可以访问 * protected 同包，子类中可以访问 * 缺省(无修饰符) 同包可以访问 * private 只能在本类中访问 * 3、访问控制修饰符可以修饰类、变量、方法。。。 * 4、当某个数据只希望子类使用：protected进行修饰 * 5、修饰符范围： * private &lt; 缺省 &lt; protected &lt; public * 6、类只能定义public或者缺省 * * */public class Test01 { public static void main(String[] args) { }} 12345678910package com.bjpower.javase.test005;public class User { // 受保护的 protected int i = 20; // 缺省的 int j = 20;} ��使用：protected进行修饰 5、修饰符范围： private &lt; 缺省 &lt; protected &lt; public 6、类只能定义public或者缺省 */public class Test01 { public static void main(String[] args) { } } 123456789101112```javapackage com.bjpower.javase.test005;public class User { // 受保护的 protected int i = 20; // 缺省的 int j = 20;}","categories":[],"tags":[]},{"title":"运算符","slug":"TreasureBox/Java/1.java基础/3.运算符","date":"2022-05-19T01:14:40.366Z","updated":"2023-04-28T09:25:47.212Z","comments":true,"path":"2022/05/19/treasurebox/java/1.java-ji-chu/3.yun-suan-fu/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/1.java-ji-chu/3.yun-suan-fu/","excerpt":"","text":"运算符运算符包括： 算术运算符 比较运算符 逻辑运算符 赋值运算符 特殊的“+”运算符 三元运算符/三目运算符 一、Java语言中的算术运算符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* 关于java编程中运算符：算术运算符 + 求和 — 求差 * 乘积 / 商 % 求余数【取模】 ++ 自加1 -- 自减1 注意： 一个表达式中有多个运算符，运算符有优先级，不确定的加小括号，优先级得到提升*/public class OperatorTest01{ public static void main(String[] args){ int i = 10; int j = 3; System.out.println(i + j); //13 System.out.println(i - j); //7 System.out.println(i * j); //30 System.out.println(i / j); //3 System.out.println(i % j); //1 //1、关于++运算符【自加1】 int k = 10; //运算符可以出现在变量后面【单目运算符】 k++; System.out.println(k); //11 int x = 10; //++运算符可以出现在变量之前【单目运算符】 int y = 10; ++y; System.out.println(y); //11 //小结：++运算符可以出现在变量前，也可以出现在变量后，无论是变量前还是变量后 //只要++运算结束，该变量值一定会自加1 //++出现在变量后 //规则：先做赋值运算，再对变量中保存的值进行自加1 int a = 100; int b = a++; System.out.println(a); //101 System.out.println(b); //100 //++ 出现在变量前 //规则：先进行自加1运算，然后在进行赋值运算 int m = 20; int n = ++m; System.out.println(m); //21 System.out.println(n); //21 //运算后加1 int w = 10; System.out.println(w++); //10 System.out.println(w); //11 //先进行自加1操作 int v = 20; System.out.println(++v); //21 System.out.println(v); //21 //2、关于--的操作 int p = 11; System.out.println(p--); //11 int q = 11; System.out.println(--q); //10 }} 二、Java中的比较运算符12345678910111213141516171819202122232425262728/** 逻辑运算符 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 == 等于 != 不等于 = 一个等号代表赋值 == 两个等号判断是否相等*/public class OperatorTest02{ public static void main(String[] args){ int a = 10; int b = 10; System.out.println(a &gt; b); //false System.out.println(a &lt; b); //false System.out.println(a == b); //true System.out.println(a &gt;= b); //false System.out.println(a &lt;= b); //false System.out.println(a != b); //false }} 三、Java中的逻辑运算符1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* 逻辑运算符： &amp; 逻辑与（两边的算子都为真，结果才是真） | 逻辑或（两边的算子只要有一个是true，结果就为true） ! 逻辑非（取反，!false就是true，!true就是false，这是一个单目运算符） ^ 逻辑异或（两边的算子只要不一样，结果就是true） &amp;&amp; 短路与 || 短路或 1、逻辑运算符要求两边的算子都是布尔类型，并且最终的运算结果也是布尔类型 2、短路与和逻辑与最终的运算结果是相同的，只不过短路与存在短路现象。 3、短路或和逻辑或最终的运算结果是相同的，只不过短路或存在短路现象。 4、什么情况下发生短路现象？ 5、什么时候选择使用逻辑与运算符？什么时候选择使用短路与运算符？*/public class OperatorTest03{ public static void main(String[] args) { System.out.println(5&gt;3 &amp; 5&gt;2); //true System.out.println(5&gt;3 &amp; 5&gt;6); //false System.out.println(5&gt;3 | 5&gt;6); //true System.out.println(\"--------\"); //逻辑与 System.out.println(true &amp; true); //true System.out.println(true &amp; false); //false System.out.println(\"--------\"); //逻辑或 System.out.println(true | false); //true System.out.println(\"--------\"); //逻辑非 System.out.println(!true); //false System.out.println(!false); //true System.out.println(\"---------\"); //逻辑异或 System.out.println(true ^ false); //true System.out.println(false ^ false); //false System.out.println(true ^ true); //false System.out.println(\"---------\"); //逻辑与和短路与 int x = 10; int y = 8; //逻辑与：表达式的两边都会走 System.out.println(x&lt;y &amp; ++x&lt;y); //false System.out.println(x); //11 System.out.println(\"---------\"); //短路与：第一个表达式不成立，第二个表达式就不再执行 int a = 3; int b = 5; System.out.println(b&lt;a &amp;&amp; ++b&lt;a); //false System.out.println(b); //5 /* 从某个角度来看，短路与更智能，由于后边的表达式可能不执行， 所以执行效率比较高。这种方式在实际的开发中使用较多。 短路与比逻辑与使用的多。短路与更常用。 但是：在某些特殊的业务当中，要求运算符两边的算子必须全部执行， 此时必须使用逻辑与，不能使用短路与，使用短路与可能导致右边的表达式不执行。 */ /* 什么情况下发生短路或？ 第一个表达式执行结果是true，会发生短路或 什么情况下发生短路与？ 第一个表达式执行结果是false，会发生短路与。 */ }} 四、java语言中的赋值运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* 关于java中的赋值运算符： 赋值类运算符包括两种： * 基本的赋值运算符 = * 扩展的赋值运算符 += -= *= /= %= 1、赋值类的运算符优先级：先执行等号右边的表达式，将执行结果赋值给左边 2、注意以下代码： byte i = 10; i += 5;等同于：i = (byte)(i+5); int k = 10; k += 5;等同于：k = (int)(k+5) long x = 10L; int y = 20; y += x; 等同于：y = (int)(y+x) 3、扩展类的赋值运算符不改变运算结果类型，假设最初的类型是byte， 无论怎么追加或者追减，最终的数据类型仍然为byte。超出范围时 可能会损失精度 */public class Operator01{ public static void main(String[] args){ //基本的赋值运算符 int i =10; System.out.println(i); //10 i = i + 5; System.out.println(i); //15 //扩展的赋值运算符【+= 运算符可以翻译为】 i += 5; //等同于：i=i+5; System.out.println(i); //20 i -= 5; //等同于：i = i - 5 System.out.println(i); //15 i *= 2; //等同于：i = i*2 System.out.println(i); //30 i /= 4; //等同于：i = i/4 System.out.println(i); //7 i %= 2; //等同于：i=i % 2 System.out.println(i); //1 System.out.println(\"-----------\"); byte b = 10; //编译错误， //编译器只检查语法，不运行程序，编译器发现b+5的类型是int类型 //大容量向小容量转换需要加强制类型转换，所以以下程序编译报错 //b =b + 5; //纠正错误 b = (byte)(b+5); System.out.println(b); //15 byte x = 10; x += 5; //等同于：x = (byte)(x+5); System.out.println(x); //15 byte z = 0; z += 128; //等同于：z=(byte)(z+128); System.out.println(z); //-128 }} 五、关于java语言中的“+”运算符12345678910111213141516171819202122232425262728293031/* 关于java中的\"+\"运算符： 1、+运算符在java中有两个作用 * 加法作用 * 字符串的链接运算 2、当“+”运算符两边的数据都是数字的话，一定是进行加法运算。 3、当“+”运算符两边的数据只要有一个数据是字符串，一定会进行字符串的拼接运算。 并且，链接之后的结果还是是一个字符串类型。 数字 + 数字 -----&gt; 数字【求和】 数字 + “字符串” -------&gt; “字符串”【字符串拼接】 4、在一个表达式当中可以出现多个“+”，在没有小括号时，按照从左到右的顺序执行*/public class Operator02{ public static void main(String[] args){ //要求：在屏幕中输出10+20=30 int i = 10; int j = 20; System.out.println(i+\"+\"+j+\"=\"+(i+j)); //字符串用法 String username = \"zhangsan\"; System.out.println(\"欢迎\"+username+\"回家！\"); String name = \"lisi\"; System.out.println(\"欢迎\"+name+\"回家！\"); }} 六、java语言中的三元运算符123456789101112131415161718192021222324252627282930313233/* 三元运算符/三目运算符/条件运算符 1、语法规则： 布尔表达式 ? 表达式1 : 表达式2 2、三元运算符的执行原理？ 当布尔表达式的结果是true时，选择表达式1作为整个表达式的结果 当布尔表达式的结果是false的时候，选择表达式2作为整个表达式的执行结果*/public class Operator03{ public static void main(String[] args){ // 编译报错：不是完整的语句 // 10; // 编译报错：不是完整的语句 // '男'; // 编译报错：不是完整的语句 // boolean sex = true; // sex ? '男':'女'; //编译通过 boolean sex = true; char c = sex ? '男':'女'; System.out.println(c); // 男 // 错误: 不兼容的类型: 条件表达式中的类型错误 // char m = sex ? \"男\":'女'; // 纠正 System.out.println(sex ? '男':\"女的\"); //男 }} sex = true; // sex ? ‘男’:’女’; //编译通过 boolean sex = true; char c = sex ? '男':'女'; System.out.println(c); // 男 // 错误: 不兼容的类型: 条件表达式中的类型错误 // char m = sex ? \"男\":'女'; // 纠正 System.out.println(sex ? '男':\"女的\"); //男 } }","categories":[],"tags":[]},{"title":"分支语句","slug":"TreasureBox/Java/1.java基础/4.分支语句","date":"2022-05-19T01:14:40.366Z","updated":"2023-04-28T09:25:47.213Z","comments":true,"path":"2022/05/19/treasurebox/java/1.java-ji-chu/4.fen-zhi-yu-ju/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/1.java-ji-chu/4.fen-zhi-yu-ju/","excerpt":"","text":"分支语句分支语句又称选择语句，当满足某个条件时，就进行某种操作。Java中有三种选择结构： if…else if..else while… do…while 一、java语言中的if分支语句java语言中有if，else if和else三个if语法，与python不同的是没有elif的用法，只有else if。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* 关于java语言中的if语句，属于选择结构，if语句又被称为分支语句/条件控制语句 1、if语句的语法结构：四种编写方式 第一种： if(布尔表达式){ java语句; java语句; ... } 第二种： if(布尔表达式){ java语句; java语句; ... }else{ java语句; java语句; ... } 第三种： if(布尔表达式){ java语句; java语句; ... }else if(布尔表达式){ java语句; java语句; ... }else if(布尔表达式){ java语句; java语句; ... }else if(布尔表达式){ java语句; java语句; ... }...... 第四种： if(布尔表达式){ java语句; java语句; ... }else if(布尔表达式){ java语句; java语句; ... }else{ java语句; java语句; ... } 2、重点：对于java中的if语句来说，只要一个分支执行，整个if语句全部结束 3、注意：以上的第二种编写方式和第四种编写方式都带有else分支， 可以百分百保证一定会有分支执行。 4、所有的控制语句都是可以嵌套使用的，只要是合理嵌套都行 if(){ if(){ if(){ } } }else{ if(){ if(){ } } } 注意：嵌套使用的时候代码格式要保证完美【该缩进的时候就要缩进】 5、if语句的分支中有且只有一条语句时，大括号可以省略不写。 if(true/false){ java语句; } 可以写成： if(true/false) 一条java语句; 这种方式不推荐使用，能看懂就行*/public class iftest01{ public static void main(String[] args){ //1、需求所在位置的五公里之内有肯德基的话，去KFC吃午饭 double distance = 4.0; if(distance&lt;5){ System.out.println(\"去吃肯德基。\"); } }} 练习1、：用户输入年龄，判断位于哪个年龄段：12345678910111213141516171819202122232425262728293031323334353637383940414243/* 需求：从键盘输入一个整数 [0-5] 幼儿 [6-10] 少儿 [11-18] 青少年 [19-35] 青年 [36-55] 中年 [56-150] 老年*/public class iftest02{ public static void main(String[] args){ //1、接收键盘输入：年龄 java.util.Scanner s = new java.util.Scanner(System.in); System.out.print(\"请输入您的年龄：\"); //输入提示信息 int age = s.nextInt(); //停下来等待用户输入，输入之后自动换行 //2、根据需求进行业务逻辑判断 String str = \"老年\"; if(age&lt;0 || age&gt;150){ str = \"您输入的年龄不合法，年龄需要在【0-150】之间\"; System.out.println(str); }else{ if(age&lt;=5){ str = \"幼儿\"; }else if(age&lt;=10){ str = \"少儿\"; }else if(age&lt;=18){ str = \"青少年\"; }else if(age&lt;=35){ str = \"青年\"; }else if(age&lt;=55){ str = \"中年\"; }else if(age&lt;=150){ str = \"老年\"; } System.out.println(\"您现在处于\"+str+\"阶段\"); } }} 练习2：输入天气和性别进行判断123456789101112131415161718192021222324252627282930313233343536373839404142/* 需求：从键盘输入一个整数 [0-5] 幼儿 [6-10] 少儿 [11-18] 青少年 [19-35] 青年 [36-55] 中年 [56-150] 老年*/public class iftest02{ public static void main(String[] args){ //1、接收键盘输入：年龄 java.util.Scanner s = new java.util.Scanner(System.in); System.out.print(\"请输入您的年龄：\"); //输入提示信息 int age = s.nextInt(); //停下来等待用户输入，输入之后自动换行 //2、根据需求进行业务逻辑判断 String str = \"老年\"; if(age&lt;0 || age&gt;150){ str = \"您输入的年龄不合法，年龄需要在【0-150】之间\"; System.out.println(str); }else{ if(age&lt;=5){ str = \"幼儿\"; }else if(age&lt;=10){ str = \"少儿\"; }else if(age&lt;=18){ str = \"青少年\"; }else if(age&lt;=35){ str = \"青年\"; }else if(age&lt;=55){ str = \"中年\"; }else if(age&lt;=150){ str = \"老年\"; } System.out.println(\"您现在处于\"+str+\"阶段\"); } }} 3、if后只有一条语句的用法1234567891011121314151617181920212223242526public class iftest05{ public static void main(String[] args){ boolean sex = true; if(sex){ System.out.println(\"男\"); }else{ System.out.println(\"女\"); } sex = false; if(sex) System.out.println(\"男\"); else System.out.println(\"女\"); //----------------------------------------- //以下代码会报错：错误: 有 'if', 但是没有 'else' //原因：if后边可以不加大括号，紧跟着的那句话包含在if里面， //导致if跟else之间有其他语句 /* if (sex) System.out.println(\"男\"); System.out.println(\"1111111111111\"); else System.out.println(\"女\"); */ }} 二、switch语句的用法练习1：使用switch判断日期：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* 关于switch语句： 1、switch语句也属于选择结构，也是分支语句 2、switch语句的语法结构，case标签内容不能重复： 一个完整的switch语句应该这样编写： switch(int或String类型的字面值或变量){ case int或String类型的字面值或变量: java语句; ... break; case int或String类型的字面值或变量: java语句; ... break; case int或String类型的字面值或变量: java语句; ... break; default: java语句; .... } 3、switch语句执行原理： switch后面小括号当中的\"数据\"和case后面的\"数据\"进行一一匹配，匹配成功的分支执行 按照自上而下的顺序依次匹配。 4、匹配成功的分支执行，分支当中有break语句时，整个switch语句终止。 5、匹配成功的分支执行，分支当中没有break语句时，直接进入下一个分支执行（不进行匹配）。 这种现象称为case穿透现象。【为防止穿透现象每个case语句都需要提供break语句】 6、所有的case都不匹配，有default时，走default分支的内容。 7、switch后面和case后面只能是int或String类型的数据，不能探测其他类型。 * byte、short、char也可以直接写到switch和case后面，因为他们可以进行自动类型转换。 byte、short、char可以自动转换成int类型。 * JDK6的，switch和case后面只能探测int类型 * JDK7之后包括7，引入新特性，switch关键字和case关键字后面可以探测int或String类型。 8、case可以合并： int i =10; switch(i){ case 1: case 2: case 3: System.out.println(\"Hello World!\") }*/public class switchTest01{ public static void main(String[] args){ //当输入10时，这种情况就是case穿透，没有遇到break时会一直向下运行 /* java.util.Scanner i = new java.util.Scanner(System.in); System.out.print(\"请输入年龄：\"); int age = i.nextInt(); switch(age){ case 10: System.out.println(\"未成年！\"); case 20: System.out.println(\"已经成年\"); } */ //较完整的switch语句 /* 接收一个用户输入： 1表示星期一 2表示星期二 ... 7表示星期日 */ java.util.Scanner s = new java.util.Scanner(System.in); System.out.print(\"请输入数字：\"); int num = s.nextInt(); String str = \"输入有误\"; switch (num){ case 1: str = \"星期一\"; break; case 2: str = \"星期二\"; break; case 3: str = \"星期三\"; break; case 4: str = \"星期四\"; break; case 5: str = \"星期五\"; break; case 6: str = \"星期六\"; break; case 7: str = \"星期日\"; break; default: str = \"输入有误\"; break; } System.out.println(str); // case合并 switch (num){ case 1: case 0: str = \"星期一\"; break; case 2: str = \"星期二\"; break; case 3: str = \"星期三\"; break; case 4: str = \"星期四\"; break; case 5: str = \"星期五\"; break; case 6: str = \"星期六\"; break; case 7: str = \"星期日\"; break; default: str = \"输入有误\"; break; } System.out.println(str); }} 练习2：判断String类型：123456789101112131415161718192021222324public class switchTest02{ public static void main(String[] args){ //从键盘输入 java.util.Scanner s = new java.util.Scanner(System.in); System.out.print(\"请输入星期几：\"); String dayOfweek = s.next(); //可以传字符串，case和default的位置不会影响结果 switch(dayOfweek){ case \"星期一\": System.out.println(1); break; default: System.out.println(\"输入不合法\"); break; case \"星期二\": System.out.println(2); break; } }} 练习3：判断字符型123456789101112131415161718192021222324public class switchTest03{ public static void main(String[] args){ //char a = 'A'; char b = 'B'; //char c = 'C'; switch(b){ case 'A': System.out.println(\"A\"); break; case 66: System.out.println(\"B\"); break; case 'C': System.out.println(\"C\"); break; default: System.out.println(\"输入错了\"); break; } }} 练习4：使用switch搭建简易计算器：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* 实现计算器当中的 + - * / % 实现思路： 1、所有数据从键盘输入 2、使用switch语句记性判断 3、需要从控制台输入三次 * 第一个数字 * 运算符 * 第二个数字 最终效果： 欢迎使用简易计算器系统： 请输入第一个数字：10 请输入运算符：+ 请输入第二个数字：20 运算结果：10 + 20 = 30*/public class switchTest04{ public static void main(String[] args){ System.out.println(\"欢迎使用简易计算机系统：\"); java.util.Scanner f = new java.util.Scanner(System.in); System.out.print(\"请输入第一个数字：\"); int num1 = f.nextInt(); System.out.print(\"请输入运算符：\"); String operator = f.next(); System.out.print(\"请输入第二个数字：\"); int num2 = f.nextInt(); int result = 0; switch(operator){ case \"+\": result = num1+num2; break; case \"-\": result = num1-num2; break; case \"*\": result = num1*num2; break; case \"/\": result = num1/num2; break; case \"%\": result = num1%num2; break; default: System.out.println(\"输入有误\"); } System.out.println(num1 + operator + num2 + \"=\" + result); }} 练习5：使用switch判断成绩区间123456789101112131415161718192021222324252627282930313233343536373839/* 假设系统给定考生成绩，请判断该考生的成绩等级： 1、有效成绩范围：【0-100】 2、考试成绩可能带有小数 3、考试成绩和等级之间对照关系： [90-100] A [80-90] B [70-80] C [60-70] D [0-60] E*/public class switchTest05{ public static void main(String[] args){ java.util.Scanner s = new java.util.Scanner(System.in); System.out.print(\"请输入成绩：\"); // 除以10得到范围 int score = s.nextInt()/10; System.out.println(score); String result = \"输入有误\"; switch(score){ case 9: case 10: result = \"A\"; case 8: result = \"B\"; case 7: result = \"C\"; case 6: result = \"D\"; default: result = \"E\"; } System.out.println(result); }} public static void main(String[] args){ java.util.Scanner s = new java.util.Scanner(System.in); System.out.print(\"请输入成绩：\"); // 除以10得到范围 int score = s.nextInt()/10; System.out.println(score); String result = \"输入有误\"; switch(score){ case 9: case 10: result = \"A\"; case 8: result = \"B\"; case 7: result = \"C\"; case 6: result = \"D\"; default: result = \"E\"; } System.out.println(result); } }","categories":[],"tags":[]},{"title":"循环语句","slug":"TreasureBox/Java/1.java基础/5.循环语句","date":"2022-05-19T01:14:40.366Z","updated":"2023-04-28T09:25:47.215Z","comments":true,"path":"2022/05/19/treasurebox/java/1.java-ji-chu/5.xun-huan-yu-ju/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/1.java-ji-chu/5.xun-huan-yu-ju/","excerpt":"","text":"循环语句循环结构： 在程序当中总有一些需要反复执行的代码，假设没有循环结构，这些重复执行的代码需要重复编写，代码无法得到重复使用。所以多数编程语言都是支持循环结构的，将来把需要反复执行的代码片段放到“循环体”，再联合计数器，共同控制这段需要反复执行的代码。 在Java中循环结构分为三种： for循环 while循环 do…while循环 一、for循环 for循环基础语法 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 1、当前示例主要讲解for循环。for循环的语法结构如下： 语法结构： for(初始化表达式;布尔表达式;更新表达式){ //需要重复执行的代码片段【由java语句构成】 } 2、for循环的执行过程/执行原理【*****】 1、初始化表达式、布尔表达式、更新表达式都不是必须的。【两个分号(;)必须要有】 2、初始化表达式最先执行，并且在整个for循环当中只执行一次。 3、布尔表达式必须是true/false,不能是其他值 4、for循环的执行过程： * 先执行初始化表达式，并且该表达式只执行一次 * 判断布尔表达式的结果是true还是false - 布尔表达式true * 执行循环体 * 执行更新表达式 - 布尔表达式true * 执行循环体 * 执行更新表达式 * 判断布尔表达式 - 布尔表达式false 循环结束 - 布尔表达式false 循环结束*/public class ForTest01{ public static void main(String[] args){ //使用循环结构代替所有需要反复执行的代码块 //使用循环语句可以使代码量减少 for(int i=0;i&lt;=10;i++){ System.out.println(i); } // 无限循环 for(;;){ System.out.println(\"无限循环\"); } }} for循环中变量的作用域 1234567891011121314151617181920212223242526272829303132/* for循环变量的作用域*/public class ForTest02{ public static void main(String[] args){ // 以下循环中，i变量的作用域仅限于当前循环的内部使用 for(int i=1;i&lt;=10;i++){ System.out.println(\"i----------&gt;\"+i); } // System.out.println(i); //编译错误：找不到i // j变量作用于整个main函数 int j = 0; for(;j&lt;=10;j++){ System.out.println(\"j++++++&gt;\"+j); } System.out.println(\"j---------&gt;\"+j); //11 // k变量也作用域整个main函数 int k; for(k=0;k&lt;=10;k++){ System.out.println(\"k------\"+k); } System.out.println(\"k+++++++\"+k); }} for循环练习 1234567891011121314151617181920212223242526272829303132333435public class ForTest03{ public static void main(String[] args){ // 输出1-10中所有的奇数 for(int i=1;i&lt;=10;i+=2){ System.out.println(\"i++++++\"+i); //1 3 5 7 9 } // 输出1-10中所有的偶数 for(int i=2;i&lt;=10;i+=2){ System.out.println(\"i---------\"+i); //2 4 6 8 10 } // 递减输出 10-1 for(int i=10;i&gt;0;i--){ System.out.println(\"i======&gt;\"+i); //10 9 8 7 6 5 4 3 2 1 } for(int i=100;i&gt;=50;i-=10){ System.out.println(\"i--------&gt;\"+i); } // 以下两个不一样 for(int i=1;i&lt;10;){ System.out.println(\"i--------&gt;\"+i); i++; } for(int i=1;i&lt;10;){ i++; System.out.println(\"i--------&gt;\"+i); } }} for循环案例练习 12345678910111213141516171819202122232425/* 循环语句和判断语句嵌套使用【for if】 1、判断奇数的两种方法； 优先使用循环次数少的方法*/public class ForTest04{ public static void main(String[] args){ for(int i=1;i&lt;=10;i+=2){ System.out.println(i+\"是奇数\"); } System.out.println(\"-----------------\"); // 找出1~10中所有的奇数 for(int i=1;i&lt;=10;i++){ if(i%2==1){ System.out.println(i+\"是奇数\"); } } }} 输出100以内奇数的和 12345678910111213141516public class ForTest05{ public static void main(String[] args){ int j = 0; for(int i=1;i&lt;=100;i+=2){ // i一定是奇数 // 累加求和 j += i; } // 整个循环结束之后，输出和的值 System.out.println(\"100以内奇数的和为：\"+j); }} 双重循环输出9*9乘法表 123456789101112public class ForTest05{ public static void main(String[] args){ for(int i=1;i&lt;10;i++){ for(int j=1;j&lt;=i;j++){ System.out.print(j+\"*\"+i+\"=\"+i*j+'\\t'); } System.out.println(); // 输出一个换行 } }} 输出1~10000中的所有素数 12345678910111213141516171819202122232425262728293031323334353637/* 编写for循环找出1~10000中所有的素数 要求每8个换一行*/public class ForTest07{ public static void main(String[] args){ int count = 0; for(int i=2;i&lt;=10000;i++){ //设置标志位 boolean isSushu = true; for(int j=2;j&lt;=i/2;j++){ if(i%j == 0){ isSushu = false; break; } } // 第一种方法，使用三目运算符 // System.out.println(isSushu ?i+\"是素数\":i+\"不是素数\"); //第二种方法 if(isSushu){ System.out.print(i+\"\\t\"); count++; if (count%8==0) { System.out.println(); } } } System.out.println(\"素数共有：\"+count); }} 二、while循环 while循环基础语法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* while循环语句： 1、while循环的语法结构 while(布尔表达式){ 循环体 } 2、while循环的执行原理 先判断布尔表达式的结果： * true 执行循环体 * 判断布尔表达式的结果 * true ... * false ... * false - 循环结束 3、while循环的循环次数 0 ~ N次 注意：while循环的循环体可能执行次数为0次*/public class WhileTest01{ public static void main(String[] args){ //无限循环 /* while (true) { System.out.println(\"hello\"); } // 编译器检测到该程序永远都无法被访问 // 错误: 无法访问的语句 System.out.println(\"world!\"); */ int i = 10; int j = 3; // 改为10&gt;3时，无限循环下边的代码就会编译报错 while(i&gt;j){ System.out.println(\"呵呵\"); } // 以下程序不会编译报错 System.out.println(\"Hello World\"); }} 练习：while循环输出1~10 123456789101112131415161718192021222324252627282930/* 使用while循环输出1~10*/public class WhileTest02{ public static void main(String[] args){ int i = 1; while(i&lt;=10){ System.out.println(\"i-----&gt;\"+i);//1 2 3 4 5 6 7 8 9 10 i++; } System.out.println(\"end----&gt;\"+i); System.out.println(\"--------------------------&gt;\"); int j = 10; while(j&gt;0){ System.out.println(j--);//10 9 8 7 6 5 4 3 2 1 } System.out.println(\"end j------&gt;\"+j); int k = 10; while(k &gt;= 0){ System.out.println(--k);//9 8 7 6 5 4 3 2 1 0 -1 } System.out.println(\"end k------&gt;\"+k); }} 三、do…while循环123456789101112131415161718192021222324252627282930313233343536373839/* do...while循环： 1、do...while循环的语法结构 do{ 循环体; }while(布尔表达式); 2、do...while循环的执行原理 3、do...while循环的执行次数： 循环体代码片段执行次数是：1-N次【至少1次】 4、使用do...while循环的注意事项： do...while循环语句最终有一个\"分号(;)\"*/public class DoWhileTest01{ public static void main(String[] args){ int i =10; do{ //至少执行一次 System.out.println(\"i-------&gt;\"+i); i++; }while(i&gt;100); System.out.println(\"--------------\"); // 完整的do...while语句 int j = 1; do{ System.out.println(\"j--------&gt;\"+j); j++; }while(j&lt;10); }} 四、break用法break表示终止循环，可以终结当前循环，也可以终止某个命名的循环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* break语句： 1、break是java语句当中的关键字，被翻译为“终端/折断” 2、break + \";\"可以成为一个单独的完整的java语句： break; 3、break语句使用在switch语句当中，用来终止switch语句执行。 4、break语句同样可以使用在循环体中，用来终止循环的执行。 5、break可以终止哪个循环呢？ 6、使用在for、while、do...while循环语句当中，当某个条件成立时， 用来跳出循环。 7、默认情况下：break中断最近的循环语句， 可以给循环命名，使break中断某个循环 */public class BreakTest01{ public static void main(String[] args){ // 1、单个循环 for(int i=0;i&lt;10;i++){ if(i==5){ // 当 i=5 时跳出循环 break; } System.out.println(\"i-------&gt;\"+i); } // 分割线 System.out.println(\"————————————————————————————————&gt;\"); // 2、双层循环终止当前循环 for(int j=0;j&lt;3;j++){ for(int k=0;k&lt;10;k++){ if(k==5){ break; } System.out.println(\"k----------\"+k); } } System.out.println(\"-------------------\"); //3、给循环命名 for1:for(int j=0;j&lt;3;j++){ for2:for(int k=0;k&lt;10;k++){ if(k==5){ break for1; } System.out.println(\"k----------\"+k); } } System.out.println(\"Hello world！-----------\"); }} 五、continue用法continue表示终结本次循环，在continue之后的代码不再执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* continue语句： 1、continue表示：继续下一次循环 2、continue也是一个continue关键字加一个分号(;)构成的一个单独的完整的java语句， 主要出现循环语句当中用来控制循环的次数 3、break和continue的区别： * break 表示循环不再执行 * continue表示中断本次循环，继续下一次循环 * continue 也可以加循环名称*/public class ContinueTest01{ public static void main(String[] args){ // 1、break语句 for(int i=0;i&lt;5;i++){ if(i==3){ break; } System.out.println(\"i------\"+i); } System.out.println(\"---------------------\"); // 2、continue for(int i=0;i&lt;5;i++){ if(i==3){ continue; } System.out.println(\"i------\"+i); } System.out.println(\"----------------------\"); // 3、continue 加循环名称 for1:for(int j=0;j&lt;5;j++){ for2:for(int i=0;i&lt;5;i++){ if(i==3){ continue for1; } System.out.println(\"i------\"+i); } System.out.println(\"j+++++++++\"+j); } }} i); } System.out.println(\"---------------------\"); // 2、continue for(int i=0;i&lt;5;i++){ if(i==3){ continue; } System.out.println(\"i------\"+i); } System.out.println(\"----------------------\"); // 3、continue 加循环名称 for1:for(int j=0;j&lt;5;j++){ for2:for(int i=0;i&lt;5;i++){ if(i==3){ continue for1; } System.out.println(\"i------\"+i); } System.out.println(\"j+++++++++\"+j); } } }","categories":[],"tags":[]},{"title":"程序基础语法","slug":"TreasureBox/Go/Go基础/1.程序基础语法","date":"2022-05-19T01:14:40.365Z","updated":"2023-04-28T09:25:47.111Z","comments":true,"path":"2022/05/19/treasurebox/go/go-ji-chu/1.cheng-xu-ji-chu-yu-fa/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/go/go-ji-chu/1.cheng-xu-ji-chu-yu-fa/","excerpt":"","text":"Go基本命令1、查看版本 go version 2、查看go的环境变量","categories":[],"tags":[]},{"title":"运行过程","slug":"TreasureBox/Java/1.java基础/1.运行过程","date":"2022-05-19T01:14:40.365Z","updated":"2023-04-28T09:25:47.214Z","comments":true,"path":"2022/05/19/treasurebox/java/1.java-ji-chu/1.yun-xing-guo-cheng/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/1.java-ji-chu/1.yun-xing-guo-cheng/","excerpt":"","text":"初识java一、初识java1、初识java​ ——javac.exe怎么用​ javac A.java 生成编译文件 A.class ——java.exe怎么用：java 类名 例如： 硬盘上有一个A.class，那么就可以用java A 硬盘上有一个B.class，那么就可以用java B 不能写成 java A.class ——运行阶段的过程是： * 打开DOS命令窗口 * 输入：java A * java.exe命令会启动Java虚拟机（JVM），JVM会启动类加载器ClassLoader * ClassLoader会去硬盘上搜索A.class文件，找到改文件则将该字节码文件装载到JVM中。 * JVM将A.class字节码文件解释成二进制1010101010这样的数据。 * 然后操作系统执行二进制文件和底层硬件平台进行交互 bin目录介绍： javac.exe 负责编译(文件中有中文时编译需要加上：javac -encoding utf-8 HelloWorld.java) java.exe 负责运行 2、java中的注释* 什么是注释?注释的作用是什么？ ​ —— 出现在java的源程序当中，对java源代码的解释说明 ​ —— 注释不会被编译到.class字节码文件当中 ​ —— 一个好的开发习惯应该是多编写注释，这样程序的可读性就会提高 ​ * java中的注释怎么写？ ​ ——单行注释 ​ //单行注释，只注释当前行 ​ ——多行注释 ​ /* ​ 多行注释 ​ 多行注释 ​ 多行注释 ​ 多行注释 ​ */ ​ ——javadoc注释 ​ /** ​ * 多行注释 ​ * 多行注释 ​ * 多行注释 ​ * 多行注释 ​ **/ ​ 注意：这种注释是比较专业的注释，会被javadoc.exe解析并生成帮助文档 3、对HelloWorld程序进行解释12345public class HelloWorld{ public static void main(String[] args){ System.out.println(\"Hello World!\") }} ​ 需要记忆：​ public​ class​ static​ void​ System.out.println(); 向控制台输出消息​ 类体​ 方法体​ 类体中不能直接编写java语句【除声明变量之外】​ 一个java语句必须以分号(;)结束​ 方法体中可以编写多条java语句​ 主方法是程序入口 4、public class和class的区别：​ 一个java源文件当中可以定义多个class​ class A{}​ class B{}​ 一个java源文件当中public的class不是必须的​ 一个class会定义生成一个xxx.class字节码文件​ public class名称只能定义一个，且必须和文件名称相同​ 每一个class当中都可以编写main方法，都可以设定程序的入口，编译之后执行不同的class即可​ 当在窗口中执行某个class时，该class必须要有主方法，否则会报错 123public static void main(String[] args){ } 二、java语言基础​ OOA：面向对象分析 ​ OOD：面向对象设计 ​ OOP：面向对象编程 标识符： 数字、字母、下划线、$符组成，数字不能开头 关键字： public,static,void,class,int,float,char,double 字面值： 字面值就是数据。 是java源程序的组成部分之一，包括标识符、关键字都是源程序的组成之一。 数据在编程中具有类型，称为数据类型。 10、100 整数型字面值 3.14 浮点型字面值 true、false 布尔型字面值 “a”、”abc” 字符串型字面值 ‘a’、’A’ 字符型字面值(长度只能为1) 注意： java语言当中所有的字符串型字面值必须使用双引号(“”)括起来。 所有的字符型字面值必须使用单引号(‘’)括起来。 变量 1、什么是变量？ 变量本质上是内存中的一块空间， 包含三部分：”数据类型”、”字面值”、”变量名” 变量是内存中存储数据的最基本的单元 2、数据类型的作用？ 不同的数据有不同的类型，不同的数据类型底层会分配不同大小的空间。 数据类型是指导程序在运行阶段应该分配多大的内存空间。 3、变量要求： 变量中存储的具体的数据必须和变量的数据类型一致，当不一致时编译会报错。 4、声明/定义变量的语法格式： 数据类型 变量名; 数据类型： byte,short,int,long,float,double,boolean,char 变量名： 只要是合法的标识符就行。规范：首字母小写，剩余的每个单词首字母大写。 例如： int i; int age; 5、变量声明之后怎么赋值？ 语法格式： 变量名=字面值; 要求：字面值的数据类型必须和变量的数据类型一致。 等号(=)是一个运算符，叫做赋值运算符。 赋值运算符先运算等号右边的表达式，表达式执行结束之后的结果赋值给左边的变量。 6、声明和赋值可以放在一起完成。 int i = 10; 7、变量赋值之后，可以重新赋值，变量的值可变化： int i = 10; i = 20; 8、有了变量的概念之后，内存空间得到了重复的使用： int i = 10; System.out.println(i); 9、通常访问一个变量包括两种访问方式： 第一种：读取变量中的保存的具体数据 get/获取 第二种：修改变量中保存的具体数据 set/设置 int i = 10; i = 20; //set System.out.println(i); //get 10、变量在一行中可以声明多个 int a,b,c; 11、变量必须先声明，再赋值才能访问。 在同一个函数作用域中，变量名不能重名。 12、变量的作用域： 变量的作用域，其实描述的就是变量的有效范围。 在范围之内是可以访问的，只要出了这个范围该变量就无法访问了。 出了大括号就不认识。 13、变量的分类 ​ 根据变量声明的位置来分类： ​ 局部变量： ​ 在方法体内声明的变量叫做局部变量 ​ 成员变量 ​ 在方法体外【类体之内】声明的变量叫做成员变量 三、java中的数据类型 数据类型的作用是什么？ 程序当中有很多数据，每一个数据都是有相关类型的，不同类型的数据占用空间大小不同。 数据类型的作用是指导JVM运行程序的时候给该数据分配多大的内存空间。 java中的数据类型包括两种： 基本数据类型 引用数据类型 关于基本的数据类型 基本数据类型包括四大类、八小类： 第一类：整数型 byte,short,int,long 第二类：浮点型 float,double 第三类：布尔型 boolean 第四类：字符型 char 字符串”abc”不属于基本数据类型，属于引用数据类型 字符串使用双引号”” 字符使用单引号’’ 八种基本数据类型各自占用空间大小是多少？ 基本数据类型 占用的内存（字节） 范围 byte 1 -128~127。-2^7 ~ 2^7-1 short 2 -32768~32767 -2^15 ~ 2^15-1 int 4 -2147483648~2147483647 -2^31 ~ 2^31-1 long 8 -2^63 ~ 2^63-1 float 4 -3.4e+38 ~ 3.4e+38 double 8 -1.7e+308 ~ 1.7e+308 boolean 1 true/false char 2 0~65535 字节（byte）： 1 Byte = 8 bit 【1个字节=8个比特位】1个比特位表示一个二进制位：1/0 1KB = 1024 Byte 1MB = 1024 KB 1GB = 1024 MB 1TB = 1024 GB ​ 1TB = 1024 *1024 * 1024 * 1024 * 8 bit 整数型当中的byte类型，占用1个字节，所以byte类型的数据占用8个比特位，那么byte类型的取值范围是多少？ 关于java中的数字类型，数字都是有正负之分的，所以在数字的二进制当中有一个二进制位被称为符号位。 并且这个符号位在所有二进制位的最左边。0表示正数，1表示负数。 byte类型的最大值：0111 1111 【00000000 00000000 00000000 10000000(二进制) -1】 byte类型的最大值：2的7次方-1 127 byte类型的最小值：-128 byte类型的取值范围：-127~128，可表示256种不同的数字【256个不同的数字】。 ​ ​ ​ �型的最大值：2的7次方-1 127 byte类型的最小值：-128 byte类型的取值范围：-127~128，可表示256种不同的数字【256个不同的数字】。 ​ ​ ​","categories":[],"tags":[]},{"title":"数据类型","slug":"TreasureBox/Java/1.java基础/2.数据类型","date":"2022-05-19T01:14:40.365Z","updated":"2023-04-28T09:25:47.216Z","comments":true,"path":"2022/05/19/treasurebox/java/1.java-ji-chu/2.shu-ju-lei-xing/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/java/1.java-ji-chu/2.shu-ju-lei-xing/","excerpt":"","text":"基本数据类型一、数据类型概述1、编码发展 ASCII码–&gt; 随着计算机发展出现： ISO-8859-1(latin-1) 随着计算机向亚洲发展，开始逐渐支持中文： GB2312–&gt;GBK–&gt;GB18030 支持繁体中文：大五码 后来出现了一种编码方式统一了全球所有文字，容量较大，这种编码方式叫做unicode编码。unicode编码方式由多种具体实现。 UTF-8,UTF-16,UTF-322、基本数据类型的取值范围： 类型 范围 byte -128~127 short -32768~32767 int -2147483648~2147483647 long float double boolean true/false char 0~65535 3、基本数据类型的默认值,向0看齐 数据类型 默认值 byte,short,int,long 0 float,double 0.0f/0.0d boolean false char \\u0000 4、转义字符 关于java语言中的char类型，转义字符 转义字符: 反斜杠在java语言中具有转义功能 转义字符出现在特殊字符之前，会将特殊字符转义 \\n 换行 \\t制表符 '单引号 \"双引号 \\反斜杠5、JDK中的native2ascii将字符转化为unicode编码 二、类型之间的转换 在类体中定义的变量，系统会自动赋初值，向0看齐。 1234567891011121314151617181920212223242526272829public class DataTypeTest01{ //这里的static必须要加 static int k = 1000; // 1、成员变量没有赋值，系统会自动赋值，向0看齐 // byte 0 // short 0 // int 0 // long 0 // char \\u0000 static int f; public static void main(String[] args){ /* int i; //局部变量 System.out.println(i) */ System.out.println(f); //0 //2、定义一个char类型的变量，起名c，同时赋值为a char c = 'a'; System.out.println(c); //3、一个中文占用2个字节，char类型正好是2字节 //所以java中的char类型变量可以存储一个中文字符 char x = '中'; System.out.println(x); } } java中的char类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* 关于java语言中的char类型，转义字符 转义字符:\\ 反斜杠在java语言中具有转义功能 转义字符出现在特殊字符之前，会将特殊字符转义 \\n 换行 \\t制表符 \\'单引号 \\\"双引号 \\\\反斜杠*/public class DataTypeTest02{ public static void main(String[] args){ char c1 = 'n'; System.out.println(c1); char c2 = '\\n'; //并不是一个字符串\\n,表示换行 System.out.println(c2); //System.out.println() //具有换行功能，输出以后换行 //System.out.print() //输出但是不换行 char x = 't'; // \\t代表制表符，tab键 char y ='\\t'; System.out.print(x); System.out.print(y); System.out.println('B'); char z = '\\\\'; System.out.println(z); //char a = ''; //报错：java中不允许这样写 //char a = '''; //报错：第一个单引号和第二个单引号配对，最后的单引号找不到另一半 char b = '\\''; System.out.println(b); System.out.println(\"\\\"Hello World!\\\"\"); char m = '中'; System.out.println(m); char n = '\\u4e2d'; System.out.println(n); char c10 = '\\u0000'; //空字符 System.out.println(c10+1); //在java语言中整数表现形式有三种 //1、十进制：是一种缺省的表现形式 //2、八进制：以0开始 //3、十六进制：以ox开始 int d = 10; int e = 010; int f = 0x10; System.out.println(d); System.out.println(e); System.out.println(f); //在java语言中，整数默认为int类型进行处理，不能超出int类型的实际范围， //超出实际范围时需要在整数最后加l/L;推荐使用L //123这个整数属于int类型 //i声明时也是int类型， //所以不存在类型转换 int i = 123; System.out.println(i); //457是int类型 //y声明时是long类型 //小容量可以自动转换为大容量，存在类型转换 long j = 457; System.out.println(j); //2147483647字面值是int类型，占用4个字节 //y是long类型，占用8个字节，会自动类型转换 long c11 = 2147483647; System.out.println(c11); //错误: 过大的整数: 2147483648 // long c12 = 2147483648; //处理: long c12 = 2147483648L; System.out.println(c12); }} java中的变量需要先声明，再赋值 直接在类体中声明的变量叫做成员变量，在方法体中声明的变量叫做成员变量。同一个变量只能声明一个，不能重复声明。 类型之间的转换 123456789101112131415/*关于基本数据类型之间的互相转换：转换规则 1、八种基本数据局类型当中除布尔类型之外剩余的7中类型之间都可以相互转换。 2、小容量向大容量转换，称为自动类型转换，容量从小到大排序： byte &lt; short &lt; int &lt; long &lt; float &lt; double char&lt; 注： 任何浮点类型不管占用多少字节，都比整数型容量大 char和short可表示的种类数量相同，但是char可以取更大的正整数。 3、char c=97; //a 4、当整数字面值没有超出byte，short，char的取值范围，可以直接赋值给byte，short，char类型的变量 5、byte，short，char混合运算的时候，各自先转换成int类型再做运算 6、多种数据类型混合运算，先转换成容量最大的那种类型，再做运算。*/ ��各自先转换成int类型再做运算 6、多种数据类型混合运算，先转换成容量最大的那种类型，再做运算。 */ ```","categories":[],"tags":[]},{"title":"es索引与B+tree对比","slug":"TreasureBox/Elasticsearch/1.es索引与B+tree对比","date":"2022-05-19T01:14:40.359Z","updated":"2023-04-28T09:25:47.259Z","comments":true,"path":"2022/05/19/treasurebox/elasticsearch/1.es-suo-yin-yu-b-tree-dui-bi/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/elasticsearch/1.es-suo-yin-yu-b-tree-dui-bi/","excerpt":"","text":"Elasticsearch—索引原理一、介绍Elasticsearch 是一个分布式可扩展的实时搜索引擎和分析引擎，一个建立在全文搜索引擎A**pache Lucene(TM)**基础上的搜索引擎。当然Elasticsearch并不仅仅是Lucene，它不仅包括了全文搜索功能，还可以进行以下工作： 分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。 实时分析的分布式搜索引擎。 可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。 基本概念Elasticsearch的文件存储，Elasticsearch是面向文档型的数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式。示例： 12345678{ \"name\" : \"waltz\", \"sex\" : \"M\", \"age\" : 24, \"birthDate\": \"1996/4/25\", \"about\" : \"I love World！\", \"interests\": [ \"sports\", \"music\" ]} 用MySQL这样的数据库存储就会容易想到建立一张User表，有各种字段等，在Elasticsearch里这就是一个文档，这个文档会属于一个User的类型，各种各样的类型存在于一个索引当中。 123关系数据库 ——&gt; 数据库 ——&gt; 表 ——&gt; 行 ——&gt;列(Column)Elasticsearch ——&gt;索引(Index) ——&gt;类型(type) ——&gt;文档(Document) ——&gt;字段(Fields) 一个Elasticsearch集群可以包含多个索引（数据库），也就是说其中包含了很多类型（表）。这些表中包含了很多文档（行），然后每个文档中又包含了很多的字段（列）。Elasticsearch的交互，可以使用Java API，也可以使用HTTP的Restful API方式，比如打算插入一条数据，可以简单发起一个HTTP请求： 123456789PUT /user{ \"name\" : \"waltz\", \"sex\" : \"M\", \"age\" : 24, \"birthDate\": \"1996/4/25\", \"about\" : \"I love World！\", \"interests\": [ \"sports\", \"music\" ]} 更新，查询也是类似的操作。 二、索引Elasticsearch最关键的就是提供强大的索引能力。 Elasticsearch索引的精髓：一切的设计都是为了提高搜索的性能 另一层意思：为了提高搜索的性能，难免会牺牲某些其他的方面，比如插入/更新。前面的向Elasticsearch中插入一条数据，其实就是直接PUT一个json对象，这个对象有多个fields，比如上面的例子中的name，sex，age，about，interests，那么在插入这些数据到Elasticsearch的同时，Elasticsearch还默默的为这些字段建立索引——倒排索引，因为Elasticsearch最核心的功能是搜索。 Elasticsearch是如何做到快速索引的？ Elasticsearch使用的倒排索引比关系型数据库的B-Tree索引快，为什么呢？ 首先要知道什么是B-Tree索引？ 二叉树的查找效率是logN，同时插入新的节点不必移动全部节点，所以用树型结构存储索引，能同时兼顾插入和查询的性能。因此在这个基础上，再结合磁盘的读取特性（顺序读/随机读），传统关系型数据库采用了B-Tree/B+Tree这样的数据结构： 为了提高查询的效率，减少磁盘寻道次数，将多个值作为一个数组通过连续区间存放，一次寻道读取多个数据，同时也降低树的高度。 什么是倒排索引？ 继续上边的案例，假设有这么几条数据： ID Name Age Sex 1 Kate 24 Female 2 John 24 Male 3 Bill 25 Male ID是Elasticsearch自建的文档id，那么Elasticsearch简历的索引如下： Name： Term Posting List Kate 1 John 2 Bill 3 Age： Term Posting List 24 [1,2] 25 3 Sex： Term Posting List Femal 1 Male [2,3] Posting List: Elasticsearch分别为每一个field建立一个倒排索引，Kate，John，24，Female这些叫做term，而[1,2]这些就是Posting List。Posting List就是一个int的数组，存储所有符合某个term的文档id。 通过Posting list这种索引方式可以很快进行查找，比如要找age=24的同学，就查找id是1，2的同学。但是如果有千万的记录呢？如果是想通过name来查找呢？ Term Dictionary Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。现在看起来和，似乎和传统数据库通过B-Tree的方式一样，为什么说比B-Tree查询快呢？ Term Index B-Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过内存查找term，不读磁盘，但是如果term太多，term dictonary也会很大，放内存不真实，于是有了Term Index，就像字典中的索引页一样。 所以term index不需要存下所有的term，而仅仅是它们的一些前缀与Term Dictionary的block之间的映射关系，再结合FST（Finite State Transducers）的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了机读的次数。 这时候就有人会问：“FST是什么东西“？ 1FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output. 假设我们现在需要将mop，moth，pop，star，stop and top(term index里的term前缀)映射到序号：0，1，2，3，4，5(term dictionary的block位置)。最简单的做法就是定义个Map&lt;string，integer=””&gt;，大家找到自己的位置对应入座就好了，但从内存占用少的角度想想，有没有更优的办法呢？答案就是：FST。 1FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output. 1FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output. FST以字节的方式存储所有的term，这种压缩方式可以有效的缩减存储空间，使得term index足以放进内存，但这种方式也会导致查找时需要更多的CPU资源。 压缩技巧 Elasticsearch里除了上面说的用FST压缩term index外，对posting list也有压缩技巧。 可能又有人问了：posting list不是已经存储文档id了吗？为什么还需要压缩？ 我们再回看最开始的例子，如果Elasticsearch需要对同学的性别进行索引(这时关系型数据库已经哭晕在厕所…)，会怎样？如果有上千万个同学，而世界上只要男/女这样两个性别。每个Posting list都有百万个文档id。Elasticsearch如何有效的对这些文档id压缩呢？ Frame Of Reference： 1增量编码压缩，将大数变小数，按字节存储 首先Elasticsearch要求posting list是有序列的（为了提高搜索的性能，再任性的要求也得满足），这样的好处是方便压缩。示例： 原理就是通过增量，将原来的大数变成小数仅存储增量值，再精打细算按bit排好队，最后通过字节存储，而不是大大咧咧的尽管是2也是用int(4个字节)来存储。 Roaring btmaps 说到Roaring bitmaps，就必须先从Bitmap说起。Bitmap是一种数据结构，假设有某个Posting list：[1,3,4,7,10]。 对应的bitmap就是：[1,0,1,1,0,0,1,0,0,1]。 用0/1表示某个值是否存在，比如10这个值对应第10位，对应的bit值是1，这样用一个字节就可以代表8个文档id，旧版本(5.0)之前的Lucene就是用这样的方式压缩的，但这样的压缩方式仍然不够高效，如果有1亿个文档，那么需要12.5MB的存储空间，这仅仅是对应一个索引字段（我们往往会有很多个索引字段）。于是有人想出了Roaring bitmaps这样更高效的数据结构。 Bitmap的缺点是存储空间随着文档个数线性增长，Roaring bitmaps需要打破这个魔咒就一定要用到某些指数特性： 将posting list按照65535为界限分块，比如第一块所包含的文档id范围在065535之间，第二块的id范围是65536131071，以此类推。再用&lt;商，余数&gt;的组合表示每一组id，这样每组里的id范围都在0~65535内了，剩下的就好办了，既然每组id不会变得无限大，那么我们就可以通过最有效的方式对这里的id存储。 联合索引 上面说的都是单field索引，如果有多个field索引的联合索引，倒排索引该如何满足快速查询的要求呢？ 利用跳表(Skip list)的数据结构快速做“与”运算 利用上面提到的bitset按位“与” 先看跳表的数据结构： 将一个有序链表level0，挑出其中几个元素到level1及level2，每个level越往上，选出来的指针元素越少，查找时一次从高level往低查找，比如55，先找到level2的31，在找到level1的47，最后找到55，一共3次查找，查找效率和2叉树的效率相当，但是也用了一定的空间冗余来换取。 假设有下面三个posting list需要联合索引： 如果使用跳表，对最短的posting list中的每个id，逐个在另外两个posting list中查找看是否存在，最后得到交集的结果。 如果使用bitset，就很直观了，直接按位与，得到的结果就是最后的交集。 三、总结和思考Elasticsearch的索引思路: 1将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种奇技淫巧的压缩算法，用及其苛刻的态度使用内存。 所以，对于使用Elasticsearch进行索引时需要注意: 不需要索引的字段，一定要明确定义出来，因为默认是自动建索引的 同样的道理，对于String类型的字段，不需要analysis的也需要明确定义出来，因为默认也是会analysis的 选择有规律的ID很重要，随机性太大的ID(比如java的UUID)不利于查询 关于最后一点，个人认为有多个因素: 其中一个(也许不是最重要的)因素: 上面看到的压缩算法，都是对Posting list里的大量ID进行压缩的，那如果ID是顺序的，或者是有公共前缀等具有一定规律性的ID，压缩比会比较高； 另外一个因素: 可能是最影响查询性能的，应该是最后通过Posting list里的ID到磁盘中查找Document信息的那步，因为Elasticsearch是分Segment存储的，根据ID这个大范围的Term定位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数。��位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数。","categories":[],"tags":[]},{"title":"python操作es","slug":"TreasureBox/Elasticsearch/2.python操作es","date":"2022-05-19T01:14:40.359Z","updated":"2023-04-28T09:25:47.259Z","comments":true,"path":"2022/05/19/treasurebox/elasticsearch/2.python-cao-zuo-es/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/elasticsearch/2.python-cao-zuo-es/","excerpt":"","text":"python操作es示例1、首先在命令行启动elasticsearch： 1切换至elasticsearch的安装目录的bin目录中，输入：elasticsearch，启动es 2、安装python需要的包：pip install elasticsearch 3、使用python创建索引： 1234567# -*- coding: utf-8 -*-from elasticsearch import Elasticsearches = Elasticsearch()# 创建索引result = es.indices.create(index=\"news\", ignore=400)print(result) 4、插入数据 123data = {\"title\": \"美国留给伊拉克的是烂摊子吗？\", 'url': 'http://view.news.qq.com/zt2011/usa_iraq/index.htm'}# result = es.create(index=\"news\", doc_type=\"politics\", id=1, body=data) # 使用create方法插入数据result = es.index(index=\"news\", doc_type=\"politics\", body=data) # 使用index方法插入数据 5、更新数据 1234567data = { 'title': '美国留给伊拉克的是个烂摊子吗', 'url': 'http://view.news.qq.com/zt2011/usa_iraq/index.htm', 'date': '2011-12-16'}result = es.update(index='news', doc_type='politics', body={\"doc\": data}, id=1)print(result) t)","categories":[],"tags":[]},{"title":"Docker解决的问题","slug":"TreasureBox/Docker/1.Docker解决的问题","date":"2022-05-19T01:14:40.357Z","updated":"2023-04-28T09:25:47.106Z","comments":true,"path":"2022/05/19/treasurebox/docker/1.docker-jie-jue-de-wen-ti/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/docker/1.docker-jie-jue-de-wen-ti/","excerpt":"","text":"title: Docker解决的问题Docker解决的问题一、解决的问题​ 由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。 ​ Docker主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其他隔离的进程。使用Docker可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其他机器上。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为使用 runC 和 containerd。 二、与虚拟机的比较虚拟机也是一种虚拟化技术，它与Docker最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。 启动速度 启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢； 而启动Docker相当于启动宿主操作系统上的一个进程。 占用资源 虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和CPU资源，一台机器只能开启几十台的虚拟机。 而Docker只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个Docker。 三、优势除了启动速度快以及占用的资源少之外，Docker还具有以下优势： 更容易迁移 提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。 更容易维护 使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。 更容易扩展 可以试用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到想要的镜像。 四、使用场景 持续集成 持续集成指的是频繁地将代码集成到主干上，这样能够更快的发现错误。 Docker具有轻量级以及隔离性的特点，在将代码集成到一个Docker中不会对其他的Docker产生影响。 提供可伸缩的云服务 根据应用的负载情况，可以很容易地增加或者减少Docker。 搭建微服务架构 Docker轻量级的特点使得它很适用于部署、维护、组合微服务。 五、镜像与容器​ Docker是一种静态的结构，可以看成面向对象中的类，而容器是镜像的一个实例。 ​ 镜像包含着容器运行时所需要的代码以及其他组件，它是一种分层结构，每一层都是只读的(read-only layers)。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。 ​ 构建容器时，通过在镜像的基础上添加一个可写层（writeable layer），用来保存着容器运行过程中的修改。 参考资料：https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md","categories":[],"tags":[]},{"title":"Docker核心组件","slug":"TreasureBox/Docker/3.Docker核心组件","date":"2022-05-19T01:14:40.357Z","updated":"2023-04-28T09:25:47.109Z","comments":true,"path":"2022/05/19/treasurebox/docker/3.docker-he-xin-zu-jian/","link":"","permalink":"http://example.com/2022/05/19/treasurebox/docker/3.docker-he-xin-zu-jian/","excerpt":"","text":"title: Docker核心组件Docker核心组件 镜像(Image)在操作系统中分为内核和用户空间。对于linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像(Image)，就相当于是一个root文件系统，比如官方镜像ubuntu18.04就包含了完整的一套Ubuntu18.04最小系统的root文件系统。 Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一起为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容再构建之后也不会被改变。 分层存储因为镜像包含操作系统完整的root文件系统，其体积往往是庞大的，因此在设计Docker时，就充分利用 Union FS 的技术，将其设计为分层存储结构。所以严格来说，镜像并非像是一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说由多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变。后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已经删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件一直跟随镜像。因此，在构建镜像的时候需要额外小心，每一层尽量只包含需要添加的东西，任何额外的东西应该在层构建结束前清理掉。 分层存储的特征还使得镜像的复用、定制变得更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。 容器(Container) 仓库(Repository)123查找官方镜像：docker search 镜像名称","categories":[],"tags":[]}],"categories":[],"tags":[]}